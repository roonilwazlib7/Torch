// Generated by CoffeeScript 1.12.1
(function() {
  var AABB, AjaxLoader, Animation, AnimationManager, ArrayUtility, AssetManager, AtlasFrameAnimation, Audio, AudioPlayer, BindManager, BitmapText, BodyManager, Camera, CanvasGame, CanvasRenderer, Circle, CloneManager, Collision, CollisionDetector, CollisionManager, Color, DebugConsole, DrawParams, ER, EffectComponent, EffectManager, Event, EventDispatcher, EventManager, FunctionUtility, FutureEvent, Game, GamePad, GamePadButton, GamePadManager, GamePadStick, GameThing, GameThingFactory, GridManager, HookManager, JerkFollow, Key, Keys, Layer, Layers, Load, LoadJob, LoadType, Loop, MathUtility, Mouse, ObjectUtility, Orbit, ParticleEmitter, ParticleManager, Point, RandomPool, Rectangle, ScheduledEvent, Shapes, SizeManager, Sound, Sprite, SpriteGroup, SpriteSheetAnimation, State, StateMachine, StateMachineManager, StringUtility, Text, Texture, Timer, Torch, TorchModule, TorchModules, TrailEffect, Trashable, Tween, TweenManager, TweenSetup, Util, Utilities, Vector, Video, Viewport, _measureCanvas, exports, temp,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ER = {};

  ER.ER = (function() {
    ER.prototype.message = null;

    ER.prototype.nativeError = null;

    function ER(fatal) {
      if (fatal) {
        this.Fatal();
      }
      this.nativeError = new Error(this.message);
    }

    ER.prototype.Fatal = function() {
      return Torch.FatalError(this.message);
    };

    ER.prototype.toString = function() {
      return this.message;
    };

    return ER;

  })();

  ER.ArgumentError = (function(superClass) {
    extend(ArgumentError, superClass);

    ArgumentError.prototype.message = null;

    function ArgumentError(argument, valueProvided, argumentTypes, fatal) {
      var index, k, len, ref, t;
      this.argument = argument;
      this.valueProvided = valueProvided;
      this.argumentTypes = argumentTypes;
      if (fatal == null) {
        fatal = false;
      }
      this.message = "ArgumentError: value '" + this.valueProvided + "(" + (Util.Type(this.valueProvided)) + ")' is not a valid argument for " + this.argument;
      if (this.argumentTypes != null) {
        this.message += "(";
        ref = this.argumentTypes;
        for (index = k = 0, len = ref.length; k < len; index = ++k) {
          t = ref[index];
          if (index !== 0) {
            this.message += ",";
          }
          this.message += t;
        }
        this.message += ")";
      }
      ArgumentError.__super__.constructor.call(this, fatal);
    }

    return ArgumentError;

  })(ER.ER);

  ArrayUtility = (function() {
    function ArrayUtility(array1) {
      this.array = array1;
    }

    ArrayUtility.prototype.Array = function() {
      return this.array;
    };

    ArrayUtility.prototype.All = function(applier) {
      var item, k, len, ref, results;
      ref = this.array;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        results.push(applier(item));
      }
      return results;
    };

    ArrayUtility.prototype.Find = function(selector) {
      var item, k, len, ref;
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (selector(item)) {
          return item;
        }
      }
    };

    ArrayUtility.prototype.Filter = function(selector) {
      var item, k, len, ref, selectedItems;
      selectedItems = [];
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (selector(item)) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    };

    ArrayUtility.prototype.Reject = function(selector) {
      var item, k, len, ref, selectedItems;
      selectedItems = [];
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (!selector(item)) {
          selectedItems.push(item);
        }
      }
      return selectedItems;
    };

    ArrayUtility.prototype.Where = function(properties) {
      var items;
      items = this.Filter(function(item) {
        var key, value;
        for (key in properties) {
          value = properties[key];
          if (item[key] !== value) {
            return false;
          }
        }
        return true;
      });
      return items;
    };

    ArrayUtility.prototype.Every = function(selector) {
      var item, k, len, ref;
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (!selector(item)) {
          return false;
        }
      }
      return true;
    };

    ArrayUtility.prototype.Some = function(selector) {
      var item, k, len, ref;
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (selector(item)) {
          return true;
        }
      }
      return false;
    };

    ArrayUtility.prototype.Contains = function(item, startIndex) {
      var index;
      if (startIndex == null) {
        startIndex = 0;
      }
      index = this.array.indexOf(item);
      return index !== -1 && index >= startIndex;
    };

    ArrayUtility.prototype.Pluck = function(propertyName) {
      var item, k, len, properties, ref;
      properties = [];
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        properties.push(item[propertyName]);
      }
      return properties;
    };

    ArrayUtility.prototype.Max = function(selector) {
      var compareValue, currentMax, item, k, len, ref;
      currentMax = 0;
      if (selector == null) {
        selector = function(item) {
          return item;
        };
      }
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        compareValue = selector(item);
        if (compareValue > currentMax) {
          currentMax = item;
        }
      }
      return currentMax;
    };

    ArrayUtility.prototype.Min = function(selector) {
      var compareValue, currentMin, item, k, len, ref;
      currentMin = 0;
      if (selector == null) {
        selector = function(item) {
          return item;
        };
      }
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        compareValue = selector(item);
        if (compareValue < currentMin) {
          currentMin = compareValue;
        }
      }
      return currentMin;
    };

    ArrayUtility.prototype.SortBy = function(sorter) {};

    ArrayUtility.prototype.GroupBy = function(grouper) {
      var group, groups, item, k, len, ref;
      if (grouper == null) {
        grouper = function(item) {
          return item.toString().length;
        };
      }
      groups = {};
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        group = grouper(item);
        if (groups[group] == null) {
          groups[group] = [item];
        } else {
          groups[group].push(item);
        }
      }
      return groups;
    };

    ArrayUtility.prototype.CountBy = function(grouper) {
      var groups, key, value;
      groups = this.GroupBy(grouper);
      for (key in groups) {
        value = groups[key];
        groups[key] = value.length;
      }
      return groups;
    };

    ArrayUtility.prototype.Shuffle = function() {
      var currentIndex, randomIndex, temporaryValue;
      currentIndex = this.array.length;
      temporaryValue = currentIndex;
      randomIndex = currentIndex;
      while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = this.array[currentIndex];
        this.array[currentIndex] = this.array[randomIndex];
        this.array[randomIndex] = temporaryValue;
      }
      return this.array;
    };

    ArrayUtility.prototype.Sample = function(n) {
      var results, sample;
      if (n == null) {
        n = 1;
      }
      sample = [];
      results = [];
      while (n > 0) {
        results.push(n--);
      }
      return results;
    };

    ArrayUtility.prototype.Partition = function(checker) {
      return [this.Filter(checker), this.Reject(checker)];
    };

    ArrayUtility.prototype.First = function(n) {
      var items;
      if (n == null) {
        n = 1;
      }
      if (n === 1) {
        return this.array[0];
      }
      items = [];
      while (n <= this.array.length) {
        items.push(this.array[n - 1]);
        n++;
      }
      return items;
    };

    ArrayUtility.prototype.Last = function(n) {
      var items;
      if (n == null) {
        n = 1;
      }
      if (n === 1) {
        return this.array[this.array.length - 1];
      }
      items = [];
      while (n <= this.array.length) {
        items.push(this.array[this.array.length - (n - 1)]);
        n++;
      }
      return items;
    };

    ArrayUtility.prototype.Flatten = function() {};

    ArrayUtility.prototype.Without = function() {
      var filteredItems, item, k, len, ref, values;
      values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      filteredItems = [];
      ref = this.array;
      for (k = 0, len = ref.length; k < len; k++) {
        item = ref[k];
        if (values.indexOf(item) === -1) {
          filteredItems.push(item);
        }
      }
      return filteredItems;
    };

    ArrayUtility.prototype.Union = function() {
      var ar, arrays, ars, combinedArray, item, k, len, len1, m;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ars = [this.array].concat(slice.call(arrays));
      combinedArray = [];
      for (k = 0, len = ars.length; k < len; k++) {
        ar = ars[k];
        for (m = 0, len1 = ar.length; m < len1; m++) {
          item = ar[m];
          if (combinedArray.indexOf(item) === -1) {
            combinedArray.push(item);
          }
        }
      }
      return combinedArray;
    };

    ArrayUtility.prototype.Intersection = function() {
      var ar, arrays, ars, combinedArray, index, item, k, key, len, len1, m, value;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ars = [this.array].concat(slice.call(arrays));
      combinedArray = [];
      index = {};
      for (k = 0, len = ars.length; k < len; k++) {
        ar = ars[k];
        for (m = 0, len1 = ar.length; m < len1; m++) {
          item = ar[m];
          if (index[item] == null) {
            index[item] = 1;
          } else {
            index[item] += 1;
          }
        }
      }
      for (key in index) {
        value = index[key];
        if (value >= arrays.length) {
          combinedArray.push(key);
        }
      }
      return combinedArray;
    };

    ArrayUtility.prototype.Uniq = function() {};

    ArrayUtility.prototype.Zip = function() {
      var ar, arrays, combinedArray, index, item, k, len, len1, m, piece, ref;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      combinedArray = [];
      ref = this.array;
      for (index = k = 0, len = ref.length; k < len; index = ++k) {
        item = ref[index];
        piece = [item];
        for (m = 0, len1 = arrays.length; m < len1; m++) {
          ar = arrays[m];
          piece.push(ar[index]);
        }
        combinedArray.push(piece);
      }
      return combinedArray;
    };

    ArrayUtility.prototype.UnZip = function() {
      var arrays;
      arrays = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    };

    return ArrayUtility;

  })();

  StringUtility = (function() {
    function StringUtility(str1) {
      this.str = str1;
    }

    StringUtility.prototype.String = function() {
      return this.str;
    };

    StringUtility.prototype.Chunk = function(chunkLength) {
      this.str = this.str.match(new RegExp('.{1,' + chunkLength + '}', 'g'));
      return this.str;
    };

    StringUtility.prototype.Capitalize = function() {
      this.str[0] = this.str[0].toUpperCase();
      return this.str;
    };

    return StringUtility;

  })();

  FunctionUtility = (function() {
    function FunctionUtility(func1) {
      this.func = func1;
    }

    FunctionUtility.prototype.Defer = function() {
      var args, f;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      f = (function(_this) {
        return function() {
          return _this.func.apply(_this, args);
        };
      })(this);
      return setTimeout(f, 0);
    };

    FunctionUtility.prototype.Once = function() {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (this.called) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      return newFunc;
    };

    FunctionUtility.prototype.After = function(timesBeforeExecuted) {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.timesBeforeExecuted += 1;
        if (this.calledCount < timesBeforeExecuted) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      newFunc.timesBeforeExecuted = 0;
      return newFunc;
    };

    FunctionUtility.prototype.Before = function(timesExecuted) {
      var newFunc, oldFunc;
      oldFunc = this.func;
      newFunc = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        this.timesExecuted += 1;
        if (this.calledCount > timesExecuted) {
          return;
        }
        oldFunc.apply(null, args);
        return this.called = true;
      };
      newFunc.timesExecuted = 0;
      return newFunc;
    };

    FunctionUtility.prototype.Compose = function() {
      var allFuncs, funcs, i, newFunc;
      funcs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      allFuncs = [this.func].concat(slice.call(funcs));
      i = 0;
      newFunc = function() {
        var lastReturn, results;
        lastReturn = void 0;
        results = [];
        while (i < allFuncs.length) {
          lastReturn = allFuncs[i](lastReturn);
          results.push(i++);
        }
        return results;
      };
      return newFunc;
    };

    return FunctionUtility;

  })();

  ObjectUtility = (function() {
    function ObjectUtility(obj1) {
      this.obj = obj1;
    }

    ObjectUtility.prototype.Keys = function() {
      var key, keys, ref, value;
      keys = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        keys.push(key);
      }
      return keys;
    };

    ObjectUtility.prototype.Values = function() {
      var key, ref, value, values;
      values = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        values.push(value);
      }
      return values;
    };

    ObjectUtility.prototype.All = function(applier) {
      var key, ref, value;
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        this.obj[key] = applier(key, value);
      }
      return this.obj;
    };

    ObjectUtility.prototype.Invert = function() {
      var key, newObj, ref, value;
      newObj = {};
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        newObj[value] = key;
      }
      return newObj;
    };

    ObjectUtility.prototype.Functions = function() {
      var functionList, key, ref, value;
      functionList = [];
      ref = this.obj;
      for (key in ref) {
        value = ref[key];
        if (typeof value === "function") {
          functionList.push(value.name);
        }
      }
      return functionList;
    };

    ObjectUtility.prototype.Extend = function() {
      var k, key, len, obj, objects, value;
      objects = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (k = 0, len = objects.length; k < len; k++) {
        obj = objects[k];
        for (key in obj) {
          value = obj[key];
          this.obj[key] = value;
        }
      }
      return this.obj;
    };

    ObjectUtility.prototype.Pick = function() {
      var k, key, len, newObj, pickKeys, ref, value;
      pickKeys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      newObj = {};
      if (typeof pickKeys === "function") {
        ref = this.obj;
        for (key in ref) {
          value = ref[key];
          if (pickKeys(key, value, this.obj)) {
            newObj[key] = value;
          }
        }
      } else {
        for (k = 0, len = pickKeys.length; k < len; k++) {
          key = pickKeys[k];
          newObj[key] = this.obj[key];
        }
      }
      return newObj;
    };

    ObjectUtility.prototype.Omit = function() {
      var key, newObj, omitKeys, ref, ref1, value;
      omitKeys = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      newObj = {};
      if (typeof omitKeys === "function") {
        ref = this.obj;
        for (key in ref) {
          value = ref[key];
          if (!omitKeys(key, value, this.obj)) {
            newObj[key] = value;
          }
        }
      } else {
        ref1 = this.obj;
        for (key in ref1) {
          value = ref1[key];
          if (omitKeys.indexOf(key) === -1) {
            newObj[key] = this.obj[key];
          }
        }
      }
      return newObj;
    };

    ObjectUtility.prototype.Clone = function() {};

    ObjectUtility.prototype.Has = function(key) {
      if (this.obj[key] == null) {
        return false;
      }
      return true;
    };

    ObjectUtility.prototype.Matches = function(otherObj) {
      var key, value;
      for (key in otherObj) {
        value = otherObj[key];
        if (this.obj[key] !== value) {
          return false;
        }
      }
      return true;
    };

    ObjectUtility.prototype.Empty = function() {
      return this.Keys().length === 0;
    };

    return ObjectUtility;

  })();

  MathUtility = (function() {
    function MathUtility() {
      this.RandomPool = RandomPool;
    }

    MathUtility.prototype.RandomInRange = function(min, max) {
      return Math.random() * (max - min + 1) + min;
    };

    MathUtility.prototype.Sign = function(n) {
      if (n > 0) {
        return 1;
      } else if (n < 0) {
        return -1;
      }
      return 0;
    };

    return MathUtility;

  })();

  RandomPool = (function() {
    RandomPool.prototype.choices = null;

    function RandomPool() {
      this.choices = [];
    }

    RandomPool.prototype.AddChoice = function(item, probability) {
      var i, results;
      i = probability;
      results = [];
      while (i > 0) {
        i--;
        results.push(this.choices.push(item));
      }
      return results;
    };

    RandomPool.prototype.Pick = function() {
      this.choices = Util.Array(this.choices).Shuffle();
      return this.choices[0];
    };

    return RandomPool;

  })();

  TorchModules = [];

  TorchModule = function(mod, optionalName) {
    var name;
    name = mod.name;
    if (optionalName != null) {
      name = optionalName;
    }
    return TorchModules.push({
      name: name,
      mod: mod
    });
  };

  Utilities = (function() {
    function Utilities() {
      this.Math = new MathUtility();
    }

    Utilities.prototype.String = function(str) {
      return new StringUtility(str);
    };

    Utilities.prototype.Array = function(array) {
      return new ArrayUtility(array);
    };

    Utilities.prototype.Function = function(func) {
      return new FunctionUtility(func);
    };

    Utilities.prototype.Object = function(obj) {
      return new ObjectUtility(obj);
    };

    Utilities.prototype.Type = function(obj) {
      var classToType, k, len, name, strType, types;
      if (obj != null) {
        if (obj.torch_type != null) {
          return obj.torch_type;
        }
        classToType = {};
        types = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"];
        for (k = 0, len = types.length; k < len; k++) {
          name = types[k];
          classToType["[object " + name + "]"] = name.toLowerCase();
        }
        strType = Object.prototype.toString.call(obj);
        return classToType[strType] || "object";
      } else {
        return null;
      }
    };

    Utilities.prototype.Enum = function() {
      var i, k, len, obj, part, parts;
      parts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      obj = {
        nameMap: {}
      };
      obj.GetStringValue = function(en) {
        return this.nameMap[en];
      };
      for (i = k = 0, len = parts.length; k < len; i = ++k) {
        part = parts[i];
        obj[part] = i + 1;
        obj.nameMap[i + 1] = part;
      }
      return obj;
    };

    return Utilities;

  })();

  Util = new Utilities();

  AjaxLoader = (function() {
    AjaxLoader.prototype.onFinish = function() {};

    AjaxLoader.prototype.onError = function() {};

    function AjaxLoader(url, responseType) {
      if (responseType == null) {
        responseType = window.Torch.AjaxData.Text;
      }
      this.url = url;
      this.responseType = this.GetResponseTypeString(responseType);
    }

    AjaxLoader.prototype.GetResponseTypeString = function(responseType) {
      switch (responseType) {
        case window.Torch.AjaxData.DOMString:
          return "";
        case window.Torch.AjaxData.ArrayBuffer:
          return "arraybuffer";
        case window.Torch.AjaxData.Blob:
          return "blob";
        case window.Torch.AjaxData.Document:
          return "document";
        case window.Torch.AjaxData.Json:
          return "json";
        case window.Torch.AjaxData.Text:
          return "text";
      }
    };

    AjaxLoader.prototype.Error = function(func) {
      return this.onError = func;
    };

    AjaxLoader.prototype.Finish = function(func) {
      return this.onFinish = func;
    };

    AjaxLoader.prototype.Load = function() {
      var request;
      request = new XMLHttpRequest();
      request.open('GET', this.url, true);
      request.responseType = this.responseType;
      request.onload = (function(_this) {
        return function() {
          return _this.onFinish(request.response, _this);
        };
      })(this);
      return request.send();
    };

    return AjaxLoader;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.onerror = function() {
      var args, errorObj;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!window.Torch.STRICT_ERRORS) {
        return;
      }
      document.body.style.backgroundColor = "black";
      errorObj = args[4];
      if (errorObj !== void 0) {
        return Torch.FatalError(errorObj);
      } else {
        return Torch.FatalError("An error has occured");
      }
    };
  }

  Function.prototype.MixIn = Function.prototype.is = function(otherFunction) {
    var items, key, proto, value;
    proto = this.prototype;
    items = Object.create(otherFunction.prototype);
    for (key in items) {
      value = items[key];
      proto[key] = value;
    }
    return this;
  };

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  EventDispatcher = (function() {
    function EventDispatcher() {}

    EventDispatcher.dispatchers = [];

    EventDispatcher.prototype.InitEventDispatch = function() {
      this.events = {};
      return EventDispatcher.dispatchers.push(this);
    };

    EventDispatcher.prototype.On = function(eventName, eventHandle) {
      var eventNest;
      if (!this.events[eventName]) {
        eventNest = [];
        eventNest.triggers = 0;
        this.events[eventName] = eventNest;
      }
      this.events[eventName].push(eventHandle);
      return this;
    };

    EventDispatcher.prototype.Emit = function(eventName, eventArgs) {
      var ev, k, len, ref;
      if (this.events[eventName] !== void 0) {
        ref = this.events[eventName];
        for (k = 0, len = ref.length; k < len; k++) {
          ev = ref[k];
          this.events[eventName].triggers++;
          ev(eventArgs);
        }
      }
      return this;
    };

    EventDispatcher.prototype.Off = function(eventName) {
      var key, ref, val;
      if (eventName == null) {
        eventName = "";
      }
      if (eventName !== "") {
        this.events[eventName] = void 0;
      } else {
        ref = this.events;
        for (key in ref) {
          val = ref[key];
          this.events[key] = void 0;
        }
      }
      return this;
    };

    return EventDispatcher;

  })();

  Trashable = (function() {
    function Trashable() {}

    Trashable.prototype.trash = false;

    Trashable.prototype.trashed = false;

    Trashable.prototype.Trash = function() {
      return this.trash = true;
    };

    return Trashable;

  })();

  TorchModule(GameThing = (function() {
    function GameThing() {}

    GameThing.MixIn(Trashable);

    GameThing.prototype.torch_game_thing = true;

    GameThing.prototype.torch_uid = null;

    GameThing.prototype.torch_add_order = null;

    GameThing.prototype.game = null;

    GameThing.prototype.drawIndex = 0;

    GameThing.prototype.Update = function() {};

    GameThing.prototype.Draw = function() {};

    GameThing.prototype.Id = function(id) {
      return this.game.thingMap[id] = this;
    };

    return GameThing;

  })());

  TorchModule(DebugConsole = (function() {
    DebugConsole.prototype.enabled = false;

    DebugConsole.prototype.console = null;

    DebugConsole.prototype.consoleInput = null;

    DebugConsole.prototype.consoleOutput = null;

    DebugConsole.prototype.commands = null;

    DebugConsole.prototype.variables = null;

    function DebugConsole(game1) {
      var div, html;
      this.game = game1;
      html = "<div id = \"torch-console\" style = \"position: absolute;z-index: 100;top:0;border: 1px solid orange;background-color:black\">\n    <p style = \"color:white;margin-left:1%;font-family:monospace\">Torch Dev Console. Type /HELP for usage</p>\n    <input type=\"text\" id = \"torch-console-input\" placeholder=\"Torch Dev Console, type /HELP for usage\"/ style = \"outline: none;border: none;font-family: monospace;color: white;background-color: black;font-size: 16px;padding: 3%;width: 100%;\" />\n    <div id = \"torch-console-output\" style = \"overflow:auto;outline: none;border: none;font-family: monospace;color: white;background-color: black;font-size: 14px;padding: 1%;width: 98%;height:250px\"></div>\n</div>";
      div = document.createElement("div");
      div.innerHTML = html;
      div.style.display = "none";
      document.body.appendChild(div);
      this.console = div;
      this.consoleInput = document.getElementById("torch-console-input");
      this.consoleOutput = document.getElementById("torch-console-output");
      this.commands = {};
      this.variables = {};
      this.LoadDefaultCommands();
      document.addEventListener("keypress", (function(_this) {
        return function(e) {
          if (e.keyCode === 47) {
            return _this.Toggle(true);
          } else if (e.keyCode === 13) {
            return _this.ParseCommand();
          }
        };
      })(this));
      document.addEventListener("keydown", (function(_this) {
        return function(e) {
          if (e.keyCode === 27) {
            return _this.Toggle(false);
          }
        };
      })(this));
    }

    DebugConsole.prototype.Toggle = function(tog) {
      if (tog == null) {
        tog = true;
      }
      if (tog) {
        this.console.style.display = "block";
        this.consoleInput.focus();
        return this.enabled = true;
      } else {
        this.console.style.display = "none";
        this.consoleInput.value = "";
        return this.enabled = false;
      }
    };

    DebugConsole.prototype.Output = function(content, color) {
      if (color == null) {
        color = "white";
      }
      content = content.replace(/\n/g, "<br>");
      return this.consoleOutput.innerHTML += "<p style='color:orange'>TorchDev$</p><p style='color:" + color + "'>" + content + "</p>";
    };

    DebugConsole.prototype.ParseCommand = function() {
      var args, command, commandText, index, k, len, option, ref;
      if (!this.enabled) {
        return;
      }
      commandText = this.consoleInput.value;
      commandText = commandText.replace(/\$(.*?)\$/g, (function(_this) {
        return function(text) {
          var clippedText;
          clippedText = text.substring(1, text.length - 1);
          return _this.variables[clippedText];
        };
      })(this));
      command = commandText.split(" ")[0].split("/")[1];
      args = [];
      ref = commandText.split(" ");
      for (index = k = 0, len = ref.length; k < len; index = ++k) {
        option = ref[index];
        if (index !== 0) {
          args.push(option);
        }
      }
      return this.ExecuteCommand(command, args);
    };

    DebugConsole.prototype.ExecuteCommand = function(command, args) {
      var ref;
      if (!this.commands[command]) {
        this.Output("Command '" + command + "' does not exist.", "red");
      } else {
        return (ref = this.commands)[command].apply(ref, [this].concat(slice.call(args)));
      }
    };

    DebugConsole.prototype.AddCommand = function(name, callback) {
      return this.commands[name] = callback;
    };

    DebugConsole.prototype.LoadDefaultCommands = function() {
      this.AddCommand("HELP", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("type '/HELP' for help\ntype '/FPS' for frame rate\ntype '/TIME' for game time\ntype '/E [statement]' to execute a JavaScript statement\ntype '/RUN [path] to load and execute a JavaScript file'");
        };
      })(this));
      this.AddCommand("CLEAR", (function(_this) {
        return function(tConsole) {
          return _this.consoleOutput.innerHTML = "";
        };
      })(this));
      this.AddCommand("FPS", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("Current FPS: " + _this.game.fps + "\nAverage FPS: " + 0);
        };
      })(this));
      this.AddCommand("TIME", (function(_this) {
        return function(tConsole) {
          return tConsole.Output("Total Game Time: " + _this.game.time + "\nDelta Time: " + _this.game.deltaTime);
        };
      })(this));
      this.AddCommand("RUN", (function(_this) {
        return function(tConsole, filePath) {
          var loader;
          loader = new Torch.AjaxLoader(filePath, Torch.AjaxData.Text);
          loader.Finish(function(data) {
            var error;
            try {
              eval(data);
              return tConsole.Output("File Executed", "green");
            } catch (error1) {
              error = error1;
              return tConsole.Output("File: '" + statement + "' caused an error. " + error, "red");
            }
          });
          return loader.Load();
        };
      })(this));
      this.AddCommand("SET", (function(_this) {
        return function(tConsole, name, value) {
          if (isNaN(value)) {
            _this.variables[name] = value;
          } else {
            _this.variables[name] = parseFloat(value);
          }
          return _this.Output("Set " + name + " to " + value, "green");
        };
      })(this));
      this.AddCommand("E", (function(_this) {
        return function(tConsole, statement) {
          var error;
          try {
            eval(statement);
            return tConsole.Output("Statment Executed", "green");
          } catch (error1) {
            error = error1;
            return tConsole.Output("Statement: '" + statement + "' caused an error. " + error, "red");
          }
        };
      })(this));
      return this.AddCommand("EXP-S", (function(_this) {
        return function(tConsole, type) {
          var exportedSprite, json, k, len, len1, m, ref, ref1, thing, val;
          json = {
            sprites: []
          };
          ref = _this.game.things;
          for (k = 0, len = ref.length; k < len; k++) {
            thing = ref[k];
            if (thing.torch_type === "Sprite") {
              if (thing.exportValues === false) {
                continue;
              }
              exportedSprite = {};
              if (type === "c") {
                exportedSprite.constructor = thing.constructor.name;
                exportedSprite.x = thing.position.x;
                exportedSprite.y = thing.position.y;
                ref1 = thing.exportValues;
                for (m = 0, len1 = ref1.length; m < len1; m++) {
                  val = ref1[m];
                  exportedSprite[val] = thing[val];
                }
              }
              json.sprites.push(exportedSprite);
            }
          }
          return console.log(JSON.stringify(json, null, 4));
        };
      })(this));
    };

    return DebugConsole;

  })());

  temp = null;

  if (this["PF"]) {
    temp = this["PF"];
  }

  
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.PF=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports = _dereq_('./lib/heap');

},{"./lib/heap":2}],2:[function(_dereq_,module,exports){

(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Heap;
  } else {
    window.Heap = Heap;
  }

}).call(this);

},{}],3:[function(_dereq_,module,exports){
var DiagonalMovement = {
    Always: 1,
    Never: 2,
    IfAtMostOneObstacle: 3,
    OnlyWhenNoObstacles: 4
};

module.exports = DiagonalMovement;
},{}],4:[function(_dereq_,module,exports){
var Node = _dereq_('./Node');
var DiagonalMovement = _dereq_('./DiagonalMovement');

/**
 * The Grid class, which serves as the encapsulation of the layout of the nodes.
 * @constructor
 * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix
 * @param {number} height Number of rows of the grid.
 * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix
 *     representing the walkable status of the nodes(0 or false for walkable).
 *     If the matrix is not supplied, all the nodes will be walkable.  */
function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}

/**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
Grid.prototype._buildNodes = function(width, height, matrix) {
    var i, j,
        nodes = new Array(height);

    for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
};


Grid.prototype.getNodeAt = function(x, y) {
    return this.nodes[y][x];
};


/**
 * Determine whether the node at the given position is walkable.
 * (Also returns false if the position is outside the grid.)
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @return {boolean} - The walkability of the node.
 */
Grid.prototype.isWalkableAt = function(x, y) {
    return this.isInside(x, y) && this.nodes[y][x].walkable;
};


/**
 * Determine whether the position is inside the grid.
 * XXX: grid.isInside(x, y) is wierd to read.
 * It should be (x, y) is inside grid, but I failed to find a better
 * name for this method.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
Grid.prototype.isInside = function(x, y) {
    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
};


/**
 * Set whether the node on the given position is walkable.
 * NOTE: throws exception if the coordinate is not inside the grid.
 * @param {number} x - The x coordinate of the node.
 * @param {number} y - The y coordinate of the node.
 * @param {boolean} walkable - Whether the position is walkable.
 */
Grid.prototype.setWalkableAt = function(x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
};


/**
 * Get the neighbors of the given node.
 *
 *     offsets      diagonalOffsets:
 *  +---+---+---+    +---+---+---+
 *  |   | 0 |   |    | 0 |   | 1 |
 *  +---+---+---+    +---+---+---+
 *  | 3 |   | 1 |    |   |   |   |
 *  +---+---+---+    +---+---+---+
 *  |   | 2 |   |    | 3 |   | 2 |
 *  +---+---+---+    +---+---+---+
 *
 *  When allowDiagonal is true, if offsets[i] is valid, then
 *  diagonalOffsets[i] and
 *  diagonalOffsets[(i + 1) % 4] is valid.
 * @param {Node} node
 * @param {DiagonalMovement} diagonalMovement
 */
Grid.prototype.getNeighbors = function(node, diagonalMovement) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        s0 = false, d0 = false,
        s1 = false, d1 = false,
        s2 = false, d2 = false,
        s3 = false, d3 = false,
        nodes = this.nodes;

    // ↑
    if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
    }
    // →
    if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
    }
    // ↓
    if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
    }
    // ←
    if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
    }

    if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
    }

    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
    } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
    } else {
        throw new Error('Incorrect value of diagonalMovement');
    }

    // ↖
    if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
    }
    // ↗
    if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
    }
    // ↘
    if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
    }
    // ↙
    if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
    }

    return neighbors;
};


/**
 * Get a clone of this grid.
 * @return {Grid} Cloned grid.
 */
Grid.prototype.clone = function() {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height);

    for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
};

module.exports = Grid;

},{"./DiagonalMovement":3,"./Node":6}],5:[function(_dereq_,module,exports){
/**
 * @namespace PF.Heuristic
 * @description A collection of heuristic functions.
 */
module.exports = {

  /**
   * Manhattan distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} dx + dy
   */
  manhattan: function(dx, dy) {
      return dx + dy;
  },

  /**
   * Euclidean distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy)
   */
  euclidean: function(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
  },

  /**
   * Octile distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} sqrt(dx * dx + dy * dy) for grids
   */
  octile: function(dx, dy) {
      var F = Math.SQRT2 - 1;
      return (dx < dy) ? F * dx + dy : F * dy + dx;
  },

  /**
   * Chebyshev distance.
   * @param {number} dx - Difference in x.
   * @param {number} dy - Difference in y.
   * @return {number} max(dx, dy)
   */
  chebyshev: function(dx, dy) {
      return Math.max(dx, dy);
  }

};

},{}],6:[function(_dereq_,module,exports){
/**
 * A node in grid.
 * This class holds some basic information about a node and custom
 * attributes may be added, depending on the algorithms' needs.
 * @constructor
 * @param {number} x - The x coordinate of the node on the grid.
 * @param {number} y - The y coordinate of the node on the grid.
 * @param {boolean} [walkable] - Whether this node is walkable.
 */
function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}

module.exports = Node;

},{}],7:[function(_dereq_,module,exports){
/**
 * Backtrace according to the parent records and return the path.
 * (including both start and end nodes)
 * @param {Node} node End node
 * @return {Array<Array<number>>} the path
 */
function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}
exports.backtrace = backtrace;

/**
 * Backtrace from start and end node, and return the path.
 * (including both start and end nodes)
 * @param {Node}
 * @param {Node}
 */
function biBacktrace(nodeA, nodeB) {
    var pathA = backtrace(nodeA),
        pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
}
exports.biBacktrace = biBacktrace;

/**
 * Compute the length of the path.
 * @param {Array<Array<number>>} path The path
 * @return {number} The length of the path
 */
function pathLength(path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i < path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}
exports.pathLength = pathLength;


/**
 * Given the start and end coordinates, return all the coordinates lying
 * on the line formed by these coordinates, based on Bresenham's algorithm.
 * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
 * @param {number} x0 Start x coordinate
 * @param {number} y0 Start y coordinate
 * @param {number} x1 End x coordinate
 * @param {number} y1 End y coordinate
 * @return {Array<Array<number>>} The coordinates on the line
 */
function interpolate(x0, y0, x1, y1) {
    var abs = Math.abs,
        line = [],
        sx, sy, dx, dy, err, e2;

    dx = abs(x1 - x0);
    dy = abs(y1 - y0);

    sx = (x0 < x1) ? 1 : -1;
    sy = (y0 < y1) ? 1 : -1;

    err = dx - dy;

    while (true) {
        line.push([x0, y0]);

        if (x0 === x1 && y0 === y1) {
            break;
        }

        e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }

    return line;
}
exports.interpolate = interpolate;


/**
 * Given a compressed path, return a new path that has all the segments
 * in it interpolated.
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} expanded path
 */
function expandPath(path) {
    var expanded = [],
        len = path.length,
        coord0, coord1,
        interpolated,
        interpolatedLen,
        i, j;

    if (len < 2) {
        return expanded;
    }

    for (i = 0; i < len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];

        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j < interpolatedLen - 1; ++j) {
            expanded.push(interpolated[j]);
        }
    }
    expanded.push(path[len - 1]);

    return expanded;
}
exports.expandPath = expandPath;


/**
 * Smoothen the give path.
 * The original path will not be modified; a new path will be returned.
 * @param {PF.Grid} grid
 * @param {Array<Array<number>>} path The path
 */
function smoothenPath(grid, path) {
    var len = path.length,
        x0 = path[0][0],        // path start x
        y0 = path[0][1],        // path start y
        x1 = path[len - 1][0],  // path end x
        y1 = path[len - 1][1],  // path end y
        sx, sy,                 // current start coordinate
        ex, ey,                 // current end coordinate
        newPath,
        i, j, coord, line, testCoord, blocked;

    sx = x0;
    sy = y0;
    newPath = [[sx, sy]];

    for (i = 2; i < len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);

        blocked = false;
        for (j = 1; j < line.length; ++j) {
            testCoord = line[j];

            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                blocked = true;
                break;
            }
        }
        if (blocked) {
            lastValidCoord = path[i - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
        }
    }
    newPath.push([x1, y1]);

    return newPath;
}
exports.smoothenPath = smoothenPath;


/**
 * Compress a path, remove redundant nodes without altering the shape
 * The original path is not modified
 * @param {Array<Array<number>>} path The path
 * @return {Array<Array<number>>} The compressed path
 */
function compressPath(path) {

    // nothing to compress
    if(path.length < 3) {
        return path;
    }

    var compressed = [],
        sx = path[0][0], // start x
        sy = path[0][1], // start y
        px = path[1][0], // second point x
        py = path[1][1], // second point y
        dx = px - sx, // direction between the two points
        dy = py - sy, // direction between the two points
        lx, ly,
        ldx, ldy,
        sq, i;

    // normalize the direction
    sq = Math.sqrt(dx*dx + dy*dy);
    dx /= sq;
    dy /= sq;

    // start the new path
    compressed.push([sx,sy]);

    for(i = 2; i < path.length; i++) {

        // store the last point
        lx = px;
        ly = py;

        // store the last direction
        ldx = dx;
        ldy = dy;

        // next point
        px = path[i][0];
        py = path[i][1];

        // next direction
        dx = px - lx;
        dy = py - ly;

        // normalize
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // if the direction has changed, store the point
        if ( dx !== ldx || dy !== ldy ) {
            compressed.push([lx,ly]);
        }
    }

    // store the last point
    compressed.push([px,py]);

    return compressed;
}
exports.compressPath = compressPath;

},{}],8:[function(_dereq_,module,exports){
module.exports = {
    'Heap'                      : _dereq_('heap'),
    'Node'                      : _dereq_('./core/Node'),
    'Grid'                      : _dereq_('./core/Grid'),
    'Util'                      : _dereq_('./core/Util'),
    'DiagonalMovement'          : _dereq_('./core/DiagonalMovement'),
    'Heuristic'                 : _dereq_('./core/Heuristic'),
    'AStarFinder'               : _dereq_('./finders/AStarFinder'),
    'BestFirstFinder'           : _dereq_('./finders/BestFirstFinder'),
    'BreadthFirstFinder'        : _dereq_('./finders/BreadthFirstFinder'),
    'DijkstraFinder'            : _dereq_('./finders/DijkstraFinder'),
    'BiAStarFinder'             : _dereq_('./finders/BiAStarFinder'),
    'BiBestFirstFinder'         : _dereq_('./finders/BiBestFirstFinder'),
    'BiBreadthFirstFinder'      : _dereq_('./finders/BiBreadthFirstFinder'),
    'BiDijkstraFinder'          : _dereq_('./finders/BiDijkstraFinder'),
    'IDAStarFinder'             : _dereq_('./finders/IDAStarFinder'),
    'JumpPointFinder'           : _dereq_('./finders/JumpPointFinder'),
};

},{"./core/DiagonalMovement":3,"./core/Grid":4,"./core/Heuristic":5,"./core/Node":6,"./core/Util":7,"./finders/AStarFinder":9,"./finders/BestFirstFinder":10,"./finders/BiAStarFinder":11,"./finders/BiBestFirstFinder":12,"./finders/BiBreadthFirstFinder":13,"./finders/BiDijkstraFinder":14,"./finders/BreadthFirstFinder":15,"./finders/DijkstraFinder":16,"./finders/IDAStarFinder":17,"./finders/JumpPointFinder":22,"heap":1}],9:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder. Based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;

    // set the g and f value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum f value.
        node = openList.pop();
        node.closed = true;

        // if reached the end position, construct the path and return it
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = AStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],10:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Best-First-Search path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BestFirstFinder.prototype = new AStarFinder();
BestFirstFinder.prototype.constructor = BestFirstFinder;

module.exports = BestFirstFinder;

},{"./AStarFinder":9}],11:[function(_dereq_,module,exports){
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * A* path-finder.
 * based upon https://github.com/bgrins/javascript-astar
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 */
function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var cmp = function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        },
        startOpenList = new Heap(cmp),
        endOpenList = new Heap(cmp),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng,
        BY_START = 1, BY_END = 2;

    // set the  and  value of the start node to be 0
    // and push it into the start open list
    startNode.g = 0;
    startNode.f = 0;
    startOpenList.push(startNode);
    startNode.opened = BY_START;

    // set theand value of the end node to be 0
    // and push it into the open open list
    endNode.g = 0;
    endNode.f = 0;
    endOpenList.push(endNode);
    endNode.opened = BY_END;

    // while both the open lists are not empty
    while (!startOpenList.empty() && !endOpenList.empty()) {


        node = startOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_END) {
                return Util.biBacktrace(node, neighbor);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    startOpenList.push(neighbor);
                    neighbor.opened = BY_START;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    startOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor


        // pop the position of end node which has the
        node = endOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_START) {
                return Util.biBacktrace(neighbor, node);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - startX), abs(y - startY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    endOpenList.push(neighbor);
                    neighbor.opened = BY_END;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    endOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};

module.exports = BiAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}],12:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-direcitional Best-First-Search path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}

BiBestFirstFinder.prototype = new BiAStarFinder();
BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;

module.exports = BiBestFirstFinder;

},{"./BiAStarFinder":11}],13:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Bi-directional Breadth-First-Search path finder.
 * @constructor
 * @param {object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}


/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        startOpenList = [], endOpenList = [],
        neighbors, neighbor, node,
        diagonalMovement = this.diagonalMovement,
        BY_START = 0, BY_END = 1,
        i, l;

    // push the start and end nodes into the queues
    startOpenList.push(startNode);
    startNode.opened = true;
    startNode.by = BY_START;

    endOpenList.push(endNode);
    endNode.opened = true;
    endNode.by = BY_END;

    // while both the queues are not empty
    while (startOpenList.length && endOpenList.length) {

        // expand start open list

        node = startOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                // if this node has been inspected by the reversed search,
                // then a path is found.
                if (neighbor.by === BY_END) {
                    return Util.biBacktrace(node, neighbor);
                }
                continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
        }

        // expand end open list

        node = endOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                if (neighbor.by === BY_START) {
                    return Util.biBacktrace(neighbor, node);
                }
                continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
        }
    }

    // fail to find the path
    return [];
};

module.exports = BiBreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],14:[function(_dereq_,module,exports){
var BiAStarFinder = _dereq_('./BiAStarFinder');

/**
 * Bi-directional Dijkstra path-finder.
 * @constructor
 * @extends BiAStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

BiDijkstraFinder.prototype = new BiAStarFinder();
BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;

module.exports = BiDijkstraFinder;

},{"./BiAStarFinder":11}],15:[function(_dereq_,module,exports){
var Util = _dereq_('../core/Util');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Breadth-First-Search path finder.
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = [],
        diagonalMovement = this.diagonalMovement,
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        neighbors, neighbor, node, i, l;

    // push the start pos into the queue
    openList.push(startNode);
    startNode.opened = true;

    // while the queue is not empty
    while (openList.length) {
        // take the front node from the queue
        node = openList.shift();
        node.closed = true;

        // reached the end position
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            // skip this neighbor if it has been inspected before
            if (neighbor.closed || neighbor.opened) {
                continue;
            }

            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
        }
    }

    // fail to find the path
    return [];
};

module.exports = BreadthFirstFinder;

},{"../core/DiagonalMovement":3,"../core/Util":7}],16:[function(_dereq_,module,exports){
var AStarFinder = _dereq_('./AStarFinder');

/**
 * Dijkstra path-finder.
 * @constructor
 * @extends AStarFinder
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 */
function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}

DijkstraFinder.prototype = new AStarFinder();
DijkstraFinder.prototype.constructor = DijkstraFinder;

module.exports = DijkstraFinder;

},{"./AStarFinder":9}],17:[function(_dereq_,module,exports){
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var Node       = _dereq_('../core/Node');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Iterative Deeping A Star (IDA*) path-finder.
 *
 * Recursion based on:
 *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html
 *
 * Path retracing based on:
 *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh
 *  "A Parallel Implementation of Iterative-Deeping-A*", January 1987.
 *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf
 *
 * @author Gerard Meier (www.gerardmeier.com)
 *
 * @constructor
 * @param {Object} opt
 * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.
 *     Deprecated, use diagonalMovement instead.
 * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching
 *     block corners. Deprecated, use diagonalMovement instead.
 * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {number} opt.weight Weight to apply to the heuristic to allow for
 *     suboptimal paths, in order to speed up the search.
 * @param {boolean} opt.trackRecursion Whether to track recursion for
 *     statistical purposes.
 * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.
 */
function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}

/**
 * Find and return the the path. When an empty array is returned, either
 * no path is possible, or the maximum execution time is reached.
 *
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    // Used for statistics:
    var nodesVisited = 0;

    // Execution time limitation:
    var startTime = new Date().getTime();

    // Heuristic helper:
    var h = function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }.bind(this);

    // Step cost from a to b:
    var cost = function(a, b) {
        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
    };

    /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {Array<Array<number>>} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
    var search = function(node, g, cutoff, route, depth) {
        nodesVisited++;

        // Enforce timelimit:
        if (this.timeLimit > 0 &&
            new Date().getTime() - startTime > this.timeLimit * 1000) {
            // Enforced as "path-not-found".
            return Infinity;
        }

        var f = g + h(node, end) * this.weight;

        // We've searched too deep for this iteration.
        if (f > cutoff) {
            return f;
        }

        if (node == end) {
            route[depth] = [node.x, node.y];
            return node;
        }

        var min, t, k, neighbour;

        var neighbours = grid.getNeighbors(node, this.diagonalMovement);

        // Sort the neighbours, gives nicer paths. But, this deviates
        // from the original algorithm - so I left it out.
        //neighbours.sort(function(a, b){
        //    return h(a, end) - h(b, end);
        //});


        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
            if (this.trackRecursion) {
                // Retain a copy for visualisation. Due to recursion, this
                // node may be part of other paths too.
                neighbour.retainCount = neighbour.retainCount + 1 || 1;

                if(neighbour.tested !== true) {
                    neighbour.tested = true;
                }
            }

            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

            if (t instanceof Node) {
                route[depth] = [node.x, node.y];

                // For a typical A* linked list, this would work:
                // neighbour.parent = node;
                return t;
            }

            // Decrement count, then determine whether it's actually closed.
            if (this.trackRecursion && (--neighbour.retainCount) === 0) {
                neighbour.tested = false;
            }

            if (t < min) {
                min = t;
            }
        }

        return min;

    }.bind(this);

    // Node instance lookups:
    var start = grid.getNodeAt(startX, startY);
    var end   = grid.getNodeAt(endX, endY);

    // Initial search depth, given the typical heuristic contraints,
    // there should be no cheaper route possible.
    var cutOff = h(start, end);

    var j, route, t;

    // With an overflow protection.
    for (j = 0; true; ++j) {

        route = [];

        // Search till cut-off depth:
        t = search(start, 0, cutOff, route, 0);

        // Route not possible, or not found in time limit.
        if (t === Infinity) {
            return [];
        }

        // If t is a node, it's also the end node. Route is now
        // populated with a valid path to the end node.
        if (t instanceof Node) {
            return route;
        }

        // Try again, this time with a deeper cut-off. The t score
        // is the closest we got to the end node.
        cutOff = t;
    }

    // This _should_ never to be reached.
    return [];
};

module.exports = IDAStarFinder;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Node":6,"../core/Util":7}],18:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which always moves
 * diagonally irrespective of the number of obstacles.
 */
function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x + dx, y + dy)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (!grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y + dy]);
                }
                if (!grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y + dy]);
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (!grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x + dx, y + 1]);
                }
                if (!grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x + dx, y - 1]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFAlwaysMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],19:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there is at most one obstacle.
 */
function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],20:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm which moves
 * diagonally only when there are no obstacles.
 */
function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 && dy !== 0) {
        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||
            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
            // return [x, y];
        // }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            // When moving vertically, must check for horizontal jump points
            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                // return [x, y];
            // }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 && dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
        }
        // search horizontally/vertically
        else {
            var isNextWalkable;
            if (dx !== 0) {
                isNextWalkable = grid.isWalkableAt(x + dx, y);
                var isTopWalkable = grid.isWalkableAt(x, y + 1);
                var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                if (isNextWalkable) {
                    neighbors.push([x + dx, y]);
                    if (isTopWalkable) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
                if (isTopWalkable) {
                    neighbors.push([x, y + 1]);
                }
                if (isBottomWalkable) {
                    neighbors.push([x, y - 1]);
                }
            }
            else if (dy !== 0) {
                isNextWalkable = grid.isWalkableAt(x, y + dy);
                var isRightWalkable = grid.isWalkableAt(x + 1, y);
                var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                if (isNextWalkable) {
                    neighbors.push([x, y + dy]);
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                if (isRightWalkable) {
                    neighbors.push([x + 1, y]);
                }
                if (isLeftWalkable) {
                    neighbors.push([x - 1, y]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFMoveDiagonallyIfNoObstacles;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],21:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var JumpPointFinderBase = _dereq_('./JumpPointFinderBase');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Path finder using the Jump Point Search algorithm allowing only horizontal
 * or vertical movements.
 */
function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}

JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;

/**
 * Search recursively in the direction (parent -> child), stopping only when a
 * jump point is found.
 * @protected
 * @return {Array<Array<number>>} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    if (dx !== 0) {
        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||
            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
            return [x, y];
        }
    }
    else if (dy !== 0) {
        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||
            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
            return [x, y];
        }
        //When moving vertically, must check for horizontal jump points
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
            return [x, y];
        }
    }
    else {
        throw new Error("Only horizontal and vertical movements are allowed");
    }

    return this._jump(x + dx, y + dy, x, y);
};

/**
 * Find the neighbors for the given node. If the node has a parent,
 * prune the neighbors based on the jump point search algorithm, otherwise
 * return all available neighbors.
 * @return {Array<Array<number>>} The neighbors found.
 */
JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        if (dx !== 0) {
            if (grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x, y - 1]);
            }
            if (grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x, y + 1]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
        }
        else if (dy !== 0) {
            if (grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y]);
            }
            if (grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y]);
            }
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
};

module.exports = JPFNeverMoveDiagonally;

},{"../core/DiagonalMovement":3,"./JumpPointFinderBase":23}],22:[function(_dereq_,module,exports){
/**
 * @author aniero / https://github.com/aniero
 */
var DiagonalMovement = _dereq_('../core/DiagonalMovement');
var JPFNeverMoveDiagonally = _dereq_('./JPFNeverMoveDiagonally');
var JPFAlwaysMoveDiagonally = _dereq_('./JPFAlwaysMoveDiagonally');
var JPFMoveDiagonallyIfNoObstacles = _dereq_('./JPFMoveDiagonallyIfNoObstacles');
var JPFMoveDiagonallyIfAtMostOneObstacle = _dereq_('./JPFMoveDiagonallyIfAtMostOneObstacle');

/**
 * Path finder using the Jump Point Search algorithm
 * @param {Object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal
 *      movement will be allowed.
 */
function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}

module.exports = JumpPointFinder;

},{"../core/DiagonalMovement":3,"./JPFAlwaysMoveDiagonally":18,"./JPFMoveDiagonallyIfAtMostOneObstacle":19,"./JPFMoveDiagonallyIfNoObstacles":20,"./JPFNeverMoveDiagonally":21}],23:[function(_dereq_,module,exports){
/**
 * @author imor / https://github.com/imor
 */
var Heap       = _dereq_('heap');
var Util       = _dereq_('../core/Util');
var Heuristic  = _dereq_('../core/Heuristic');
var DiagonalMovement = _dereq_('../core/DiagonalMovement');

/**
 * Base class for the Jump Point Search algorithm
 * @param {object} opt
 * @param {function} opt.heuristic Heuristic function to estimate the distance
 *     (defaults to manhattan).
 */
function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}

/**
 * Find and return the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = this.openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = this.startNode = grid.getNodeAt(startX, startY),
        endNode = this.endNode = grid.getNodeAt(endX, endY), node;

    this.grid = grid;


    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this._identifySuccessors(node);
    }

    // fail to find the path
    return [];
};

/**
 * Identify successors for the given node. Runs a jump point search in the
 * direction of each available neighbor, adding any points found to the open
 * list.
 * @protected
 */
JumpPointFinderBase.prototype._identifySuccessors = function(node) {
    var grid = this.grid,
        heuristic = this.heuristic,
        openList = this.openList,
        endX = this.endNode.x,
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this._findNeighbors(node);
    for(i = 0, l = neighbors.length; i < l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);

            if (jumpNode.closed) {
                continue;
            }

            // include distance, as parent may not be immediately adjacent:
            d = Heuristic.octile(abs(jx - x), abs(jy - y));
            ng = node.g + d;

            if (!jumpNode.opened || ng < jumpNode.g) {
                jumpNode.g = ng;
                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.updateItem(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;

},{"../core/DiagonalMovement":3,"../core/Heuristic":5,"../core/Util":7,"heap":1}]},{},[8])
(8)
});;

  TorchModule(this["PF"], "PF");

  this["PF"] = temp;

  BodyManager = (function() {
    function BodyManager(sprite1) {
      this.sprite = sprite1;
      this.game = this.sprite.game;
      this.velocity = new Vector(0, 0);
      this.acceleration = new Vector(0, 0);
      this.omega = 0;
      this.alpha = 0;
      this.distance = 0;
      this.orbit = null;
    }

    BodyManager.prototype.Update = function() {
      var dX, dY;
      dX = this.velocity.x * this.game.Loop.updateDelta;
      dY = this.velocity.y * this.game.Loop.updateDelta;
      this.distance += Math.sqrt((dX * dX) + (dY * dY));
      this.sprite.position.x += dX;
      this.sprite.position.y += dY;
      this.velocity.x += this.acceleration.x * this.game.Loop.updateDelta;
      this.velocity.y += this.acceleration.y * this.game.Loop.updateDelta;
      this.sprite.rotation += this.omega * this.game.Loop.updateDelta;
      this.sprite.omega += this.alpha * this.game.Loop.updateDelta;
      if (this.orbit != null) {
        return this.orbit.Update();
      }
    };

    BodyManager.prototype.Orbit = function(spriteToOrbit, speed, length) {
      var startPosition;
      this.orbit = new Orbit(this.sprite, spriteToOrbit, speed, length);
      startPosition = this.orbit.GetStartPosition();
      return this.sprite.game.Tweens.Tween(this.sprite.position, 2000, Torch.Easing.Smooth).To({
        x: startPosition.x,
        y: startPosition.y
      }).On("Finish", (function(_this) {
        return function() {
          return _this.orbit.enabled = true;
        };
      })(this));
    };

    BodyManager.prototype.Debug = function(color) {
      if (color == null) {
        color = "red";
      }
      return this.DEBUG = color;
    };

    BodyManager.prototype.AngleTo = function(otherSprite) {
      var directionVector;
      directionVector = this.DirectionTo(otherSprite);
      return directionVector.angle;
    };

    BodyManager.prototype.DistanceTo = function(otherSprite) {
      var otherVec, thisVec;
      thisVec = new Vector(this.sprite.position.x, this.sprite.position.y);
      otherVec = new Vector(otherSprite.position.x, otherSprite.position.y);
      otherVec.SubtractVector(thisVec);
      return otherVec.magnitude;
    };

    BodyManager.prototype.DirectionTo = function(otherSprite) {
      var vec;
      vec = new Vector(otherSprite.position.x - this.sprite.position.x, otherSprite.position.y - this.sprite.position.y);
      vec.Normalize();
      return vec;
    };

    return BodyManager;

  })();

  Orbit = (function() {
    Orbit.prototype.sprite = null;

    Orbit.prototype.game = null;

    Orbit.prototype.spriteToOrbit = null;

    Orbit.prototype.enabled = false;

    Orbit.prototype.orbitSpeed = 0;

    Orbit.prototype.orbitAngle = 0;

    Orbit.prototype.orbitLength = 0;

    function Orbit(sprite1, spriteToOrbit1, orbitSpeed, orbitLength) {
      this.sprite = sprite1;
      this.spriteToOrbit = spriteToOrbit1;
      this.orbitSpeed = orbitSpeed;
      this.orbitLength = orbitLength;
      this.game = this.sprite.game;
    }

    Orbit.prototype.Update = function() {
      if (!this.enabled) {
        return;
      }
      this.orbitAngle += this.orbitSpeed * this.game.Loop.updateDelta;
      this.sprite.position.x = this.orbitLength * Math.cos(this.orbitAngle) + (this.spriteToOrbit.position.x + this.spriteToOrbit.rectangle.width / 2);
      return this.sprite.position.y = this.orbitLength * Math.sin(this.orbitAngle) + (this.spriteToOrbit.position.y + this.spriteToOrbit.rectangle.height / 2);
    };

    Orbit.prototype.GetStartPosition = function() {
      var startX, startY;
      startX = this.orbitLength * Math.cos(0) + (this.spriteToOrbit.position.x + this.spriteToOrbit.rectangle.width / 2);
      startY = this.orbitLength * Math.sin(0) + (this.spriteToOrbit.position.y + this.spriteToOrbit.rectangle.height / 2);
      return new Vector(startX, startY);
    };

    return Orbit;

  })();

  SizeManager = (function() {
    SizeManager.prototype.width = 0;

    SizeManager.prototype.height = 0;

    SizeManager.prototype.scale = null;

    function SizeManager(sprite1) {
      var rect;
      this.sprite = sprite1;
      rect = this.sprite.rectangle;
      this.width = rect.width;
      this.height = rect.height;
      this.scale = {
        width: 1,
        height: 1
      };
    }

    SizeManager.prototype.Update = function() {
      var rect;
      rect = this.sprite.rectangle;
      if (this.sprite.torch_shape) {
        rect.width = this.sprite.width;
        return rect.height = this.sprite.height;
      }
    };

    SizeManager.prototype.Set = function(width, height) {
      this.width = this.sprite.rectangle.width = width * this.scale.width;
      return this.height = this.sprite.rectangle.height = height * this.scale.height;
    };

    SizeManager.prototype.Scale = function(widthScale, heightScale) {
      var rect;
      rect = this.sprite.rectangle;
      this.scale.width = widthScale;
      this.scale.height = heightScale;
      rect.width = this.width * this.scale.width;
      return rect.height = this.height * this.scale.height;
    };

    return SizeManager;

  })();

  EventManager = (function() {
    EventManager.prototype.mouseOver = false;

    EventManager.prototype.clickTrigger = false;

    EventManager.prototype.clickAwayTrigger = false;

    EventManager.prototype.draw = true;

    EventManager.prototype.wasClicked = false;

    function EventManager(sprite1) {
      this.sprite = sprite1;
      this.game = this.sprite.game;
    }

    EventManager.prototype.Update = function() {
      var mouseRec, reComputedMouseRec;
      if (!this.game.Mouse.GetRectangle().Intersects(this.sprite.rectangle) && this.mouseOver) {
        this.mouseOver = false;
        this.sprite.Emit("MouseLeave", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
      }
      if (this.game.Mouse.GetRectangle().Intersects(this.sprite.rectangle)) {
        if (!this.mouseOver) {
          this.sprite.Emit("MouseOver", new Torch.Event(this.game, {
            sprite: this.sprite
          }));
        }
        this.mouseOver = true;
      } else if (this.sprite.fixed) {
        mouseRec = this.game.Mouse.GetRectangle();
        reComputedMouseRec = new Rectangle(mouseRec.x, mouseRec.y, mouseRec.width, mouseRec.height);
        reComputedMouseRec.x += this.game.Camera.position.x;
        reComputedMouseRec.y += this.game.Camera.position.y;
        if (reComputedMouseRec.Intersects(this.sprite.rectangle)) {
          this.mouseOver = true;
        } else {
          this.mouseOver = false;
        }
      } else {
        this.mouseOver = false;
      }
      if (this.mouseOver && this.game.Mouse.down && !this.clickTrigger) {
        this.clickTrigger = true;
        this.sprite.Emit("MouseDown", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
      }
      if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        this.wasClicked = true;
        this.sprite.Emit("MouseUp", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
        this.sprite.Emit("Click", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
        this.clickTrigger = false;
      }
      if (this.clickTrigger && !this.game.Mouse.down && !this.mouseOver) {
        this.clickTrigger = false;
      }
      if (!this.game.Mouse.down && !this.mouseOver && this.clickAwayTrigger) {
        this.sprite.Emit("ClickAway", new Torch.Event(this.game, {
          sprite: this.sprite
        }));
        this.wasClicked = false;
        return this.clickAwayTrigger = false;
      } else if (this.clickTrigger && !this.game.Mouse.down && this.mouseOver) {
        return this.clickAwayTrigger = false;
      } else if (this.game.Mouse.down && !this.mouseOver) {
        return this.clickAwayTrigger = true;
      }
    };

    return EventManager;

  })();

  EffectManager = (function() {
    EffectManager.prototype.tint = null;

    EffectManager.prototype.mask = null;

    EffectManager.prototype.effects = null;

    function EffectManager(sprite1) {
      this.sprite = sprite1;
      this.effects = [];
      this.tint = new EffectComponent.Tint();
      this.mask = new EffectComponent.Mask();
    }

    EffectManager.prototype.Update = function() {
      var effect;
      return this.effects = (function() {
        var k, len, ref, results;
        ref = this.effects;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          effect = ref[k];
          effect.Update();
          if (!effect.trash) {
            results.push(effect);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }).call(this);
    };

    EffectManager.prototype.Blink = function(interval) {
      var t;
      if (interval == null) {
        interval = 300;
      }
      t = this.sprite.game.Tweens.Tween(this.sprite, interval, Torch.Easing.Smooth).To({
        opacity: 0
      }).Cycle();
      return t;
    };

    EffectManager.prototype.Flash = function(color, time) {
      var t;
      if (color == null) {
        color = "red";
      }
      if (time == null) {
        time = 100;
      }
      this.tint.color = color;
      t = this.sprite.game.Tweens.Tween(this.tint, time, Torch.Easing.Smooth).From({
        opacity: 0
      }).To({
        opacity: 1
      });
      return t.On("Finish", (function(_this) {
        return function() {
          var t2;
          t2 = _this.sprite.game.Tweens.Tween(_this.tint, time, Torch.Easing.Smooth).To({
            opacity: 0
          });
          return t2.On("Finish", function() {
            _this.tint.color = null;
            return _this.tint.opacity = 0.5;
          });
        };
      })(this));
    };

    EffectManager.prototype.Crumple = function(ratio, time) {
      var targetHeight;
      targetHeight = this.sprite.rectangle.height * ratio;
      return this.sprite.game.Tweens.Tween(this.sprite.rectangle, time, Torch.Easing.Smooth).To({
        height: targetHeight
      });
    };

    EffectManager.prototype.Stretch = function(ratio, time) {
      var targetWidth;
      targetWidth = this.sprite.rectangle.width * ratio;
      return this.sprite.game.Tweens.Tween(this.sprite.rectangle, time, Torch.Easing.Smooth).To({
        width: targetWidth
      });
    };

    EffectManager.prototype.Squirt = function(point, time) {
      var heightDiff, origHeight, origWidth, tween, widthDiff;
      origWidth = this.sprite.rectangle.width;
      origHeight = this.sprite.rectangle.height;
      widthDiff = Math.abs(point.x - this.sprite.position.x);
      heightDiff = Math.abs(point.y - this.sprite.position.y);
      if (widthDiff > 0) {
        this.sprite.game.Tweens.Tween(this.sprite.rectangle, time, Torch.Easing.Smooth).To({
          width: widthDiff
        });
      }
      if (heightDiff > 0) {
        this.sprite.game.Tweens.Tween(this.sprite.rectangle, time, Torch.Easing.Smooth).To({
          height: heightDiff
        });
      }
      tween = this.sprite.game.Tweens.Tween(this.sprite.position, time, Torch.Easing.Smooth).To({
        x: point.x,
        y: point.y
      });
      return tween.On("Finish", (function(_this) {
        return function() {
          return _this.sprite.game.Tweens.Tween(_this.sprite.rectangle, time, Torch.Easing.Smooth).To({
            width: origWidth,
            height: origHeight
          });
        };
      })(this));
    };

    EffectManager.prototype.Trail = function() {
      return this.effects.push(new TrailEffect(this.sprite));
    };

    return EffectManager;

  })();

  EffectComponent = {};

  EffectComponent.Tint = (function() {
    function Tint() {}

    Tint.prototype._color = null;

    Tint.prototype._opacity = 0.5;

    Tint.property('color', {
      get: function() {
        return this._color;
      },
      set: function(value) {
        return this._color = value;
      }
    });

    Tint.property('opacity', {
      get: function() {
        return this._opacity;
      },
      set: function(value) {
        return this._opacity = value;
      }
    });

    return Tint;

  })();

  EffectComponent.Mask = (function() {
    function Mask() {}

    Mask.prototype._texture = null;

    Mask.prototype._in = false;

    Mask.prototype._out = false;

    Mask.property('texture', {
      get: function() {
        return this._texture;
      },
      set: function(value) {
        return this._texture = value;
      }
    });

    Mask.property('in', {
      get: function() {
        return this._in;
      },
      set: function(value) {
        return this._in = value;
      }
    });

    Mask.property('out', {
      get: function() {
        return this._out;
      },
      set: function(value) {
        return this._out = value;
      }
    });

    return Mask;

  })();

  TrailEffect = (function() {
    TrailEffect.prototype.fadeTime = 200;

    function TrailEffect(sprite1) {
      this.sprite = sprite1;
    }

    TrailEffect.prototype.Update = function() {
      var t;
      t = new Sprite(this.sprite.game, this.sprite.position.x, this.sprite.position.y);
      t.Bind.Texture(this.sprite.texture.image);
      t.Size.Scale(1, 1);
      t.drawIndex = this.sprite.drawIndex - 1;
      t.rotation = this.sprite.rotation;
      return this.sprite.game.Tweens.Tween(t, this.fadeTime, Torch.Easing.Smooth).From({
        opacity: 0.2
      }).To({
        opacity: 0
      }).On("Finish", (function(_this) {
        return function() {
          return t.Trash();
        };
      })(this));
    };

    return TrailEffect;

  })();

  StateMachineManager = (function() {
    function StateMachineManager(sprite1) {
      this.sprite = sprite1;
      this.stateMachines = {};
    }

    StateMachineManager.prototype.CreateStateMachine = function(name) {
      this.stateMachines[name] = new StateMachine(this.sprite);
      return this.stateMachines[name];
    };

    StateMachineManager.prototype.GetStateMachine = function(name) {
      return this.stateMachines[name];
    };

    StateMachineManager.prototype.Update = function() {
      var key, ref, results, sm;
      ref = this.stateMachines;
      results = [];
      for (key in ref) {
        sm = ref[key];
        results.push(sm.Update());
      }
      return results;
    };

    return StateMachineManager;

  })();


  /*
      @class GridManager
  
      Manages the relative position of sprites
   */

  GridManager = (function() {
    GridManager.prototype.parent = null;

    GridManager.prototype.children = null;

    GridManager.prototype.centered = false;

    GridManager.prototype.centerVertical = false;

    GridManager.prototype.alignLeft = false;

    GridManager.prototype.alignRight = false;

    GridManager.prototype.alignTop = false;

    GridManager.prototype.alignBottom = false;

    GridManager.prototype.margin = null;

    function GridManager(sprite1) {
      this.sprite = sprite1;
      this.position = new Point(0, 0);
      this.children = [];
      this.margin = {
        left: 0,
        top: 0
      };
    }

    GridManager.prototype.Align = function() {
      var k, len, positionTags, tag;
      positionTags = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (k = 0, len = positionTags.length; k < len; k++) {
        tag = positionTags[k];
        switch (tag) {
          case "left":
            this.alignLeft = true;
            break;
          case "right":
            this.alignRight = true;
            break;
          case "top":
            this.alignTop = true;
            break;
          case "bottom":
            this.alignBottom = true;
        }
      }
      return this;
    };

    GridManager.prototype.Center = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      this.centered = turnOn;
      return this;
    };

    GridManager.prototype.CenterVertical = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      this.centerVertical = turnOn;
      return this;
    };

    GridManager.prototype.Margin = function(left, top) {
      if (left == null) {
        left = 0;
      }
      if (top == null) {
        top = 0;
      }
      this.margin.left = left;
      this.margin.top = top;
      return this;
    };

    GridManager.prototype.Append = function(sprite) {
      sprite.Grid.parent = this.sprite;
      sprite.drawIndex = this.sprite.drawIndex + 1;
      sprite.fixed = this.sprite.fixed;
      return this;
    };

    GridManager.prototype.Parent = function() {
      return this.parent;
    };

    GridManager.prototype.Children = function(matcher) {
      var child, children, k, key, len, matching, ref, value;
      if (!matcher) {
        return this.children;
      }
      children = [];
      ref = this.children;
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        matching = true;
        for (key in matcher) {
          value = matcher[key];
          if (!child[key] === value) {
            matching = false;
          }
        }
        if (matching) {
          children.append(child);
        }
      }
      return children;
    };

    GridManager.prototype.Ancestors = function(matcher) {
      var ancestor, ancestors, key, matched, results, value;
      if (!this.parent) {
        return null;
      }
      ancestors = [];
      ancestor = this.parent;
      results = [];
      while (ancestor.Parent() !== null) {
        if (!matcher) {
          ancestors.push(ancestor);
        } else {
          matched = true;
          for (key in matcher) {
            value = matcher[key];
            if (ancestor[key] !== value) {
              matched = false;
            }
          }
          if (matched) {
            ancestors.push(ancestor);
          }
        }
        results.push(ancestor = ancestor.Parent());
      }
      return results;
    };

    GridManager.prototype.ApplyCentering = function(point) {
      if (this.centered) {
        point.x = (point.x + this.parent.rectangle.width / 2) - (this.sprite.rectangle.width / 2);
      }
      if (this.centerVertical) {
        point.y = (point.y + this.parent.rectangle.height / 2) - (this.sprite.rectangle.height / 2);
      }
      return point;
    };

    GridManager.prototype.ApplyAlignment = function(point) {
      if (this.alignLeft) {
        point.x = 0;
      }
      if (this.alignRight) {
        point.x = point.x + (this.parent.rectangle.width - this.sprite.rectangle.width);
      }
      if (this.alignTop) {
        point.y = 0;
      }
      if (this.alignBottom) {
        point.y = point.y + (this.parent.rectangle.height - this.sprite.rectangle.height);
      }
      return point;
    };

    GridManager.prototype.ResolveAbosolutePosition = function() {
      var basePoint;
      if (this.parent === null) {
        return this.sprite.position;
      }
      basePoint = this.parent.position.Clone();
      basePoint = this.ApplyCentering(basePoint);
      basePoint = this.ApplyAlignment(basePoint);
      basePoint.x += this.position.x;
      basePoint.y += this.position.y;
      basePoint.x += this.margin.left;
      basePoint.y += this.margin.top;
      return basePoint;
    };

    GridManager.prototype.Update = function() {
      this.sprite.position = this.ResolveAbosolutePosition();
      if (this.parent !== null) {
        this.sprite.drawIndex = this.parent.drawIndex + 1;
        return this.sprite.fixed = this.parent.fixed;
      }
    };

    return GridManager;

  })();

  Animation = (function(superClass) {
    extend(Animation, superClass);

    Animation.MixIn(Trashable);

    Animation.MixIn(EventDispatcher);

    Animation.prototype.loop = false;

    Animation.prototype.stopped = false;

    Animation.prototype.intervalTime = 0;

    Animation.prototype.stepTime = 0;

    function Animation() {
      this.InitEventDispatch();
    }

    Animation.prototype.Loop = function() {
      this.loop = true;
      return this;
    };

    return Animation;

  })(Trashable);

  AnimationManager = (function() {
    AnimationManager.prototype.animations = null;

    function AnimationManager(sprite1) {
      this.sprite = sprite1;
      this.animations = [];
    }

    AnimationManager.prototype.Update = function() {
      var anim, cleanedAnims, k, len, ref;
      cleanedAnims = [];
      ref = this.animations;
      for (k = 0, len = ref.length; k < len; k++) {
        anim = ref[k];
        anim.Update();
        if (!anim.trash) {
          cleanedAnims.push(anim);
        }
      }
      return this.animations = cleanedAnims;
    };

    AnimationManager.prototype.SpriteSheet = function(width, height, numberOfFrames, config) {
      var anim;
      if (config == null) {
        config = {
          step: 200
        };
      }
      anim = new SpriteSheetAnimation(this.sprite, width, height, numberOfFrames, config.step);
      this.animations.push(anim);
      return anim;
    };

    AnimationManager.prototype.AtlasFrame = function(atlasId, textureId, frames, config) {
      var anim;
      if (config == null) {
        config = {
          step: 200
        };
      }
      anim = new AtlasFrameAnimation(this.sprite, atlasId, textureId, frames, config.step);
      this.animations.push(anim);
      return anim;
    };

    return AnimationManager;

  })();

  SpriteSheetAnimation = (function(superClass) {
    extend(SpriteSheetAnimation, superClass);

    SpriteSheetAnimation.prototype.index = -1;

    SpriteSheetAnimation.prototype.clipX = 0;

    SpriteSheetAnimation.prototype.clipY = 0;

    SpriteSheetAnimation.prototype.game = null;

    SpriteSheetAnimation.prototype.clipWidth = null;

    SpriteSheetAnimation.prototype.clipHeight = null;

    SpriteSheetAnimation.prototype.numberOfFrames = null;

    SpriteSheetAnimation.prototype.stepTime = null;

    function SpriteSheetAnimation(sprite1, clipWidth, clipHeight, numberOfFrames1, stepTime) {
      this.sprite = sprite1;
      this.clipWidth = clipWidth;
      this.clipHeight = clipHeight;
      this.numberOfFrames = numberOfFrames1;
      this.stepTime = stepTime;
      SpriteSheetAnimation.__super__.constructor.call(this);
      this.loop = true;
      this.game = this.sprite.game;
      this.Reset();
    }

    SpriteSheetAnimation.prototype.Update = function() {
      if (this.stopped) {
        return;
      }
      this.intervalTime += this.game.Loop.updateDelta;
      if (this.intervalTime >= this.stepTime) {
        return this.AdvanceFrame();
      }
    };

    SpriteSheetAnimation.prototype.AdvanceFrame = function() {
      this.intervalTime = 0;
      this.index += 1;
      this.sprite.texture.drawParams.clipX = this.index * this.clipWidth;
      if (this.index >= this.numberOfFrames - 1) {
        if (this.loop) {
          return this.index = -1;
        } else {
          return this.Trash();
        }
      }
    };

    SpriteSheetAnimation.prototype.Stop = function() {
      return this.stopped = true;
    };

    SpriteSheetAnimation.prototype.Start = function() {
      return this.stopped = false;
    };

    SpriteSheetAnimation.prototype.Index = function(index) {
      this.index = index - 1;
      return this.sprite.texture.drawParams.clipX = (this.index + 1) * this.clipWidth;
    };

    SpriteSheetAnimation.prototype.Reset = function() {
      this.intervalTime = 0;
      this.index = -1;
      this.sprite.texture.drawParams.clipX = 0;
      this.sprite.texture.drawParams.clipY = 0;
      this.sprite.texture.drawParams.clipWidth = this.clipWidth;
      this.sprite.texture.drawParams.clipHeight = this.clipHeight;
      this.sprite.Size.width = this.clipWidth;
      return this.sprite.Size.height = this.clipHeight;
    };

    SpriteSheetAnimation.prototype.SyncFrame = function() {
      this.sprite.texture.drawParams.clipX = 0;
      this.sprite.texture.drawParams.clipY = 0;
      this.sprite.texture.drawParams.clipWidth = this.clipWidth;
      this.sprite.texture.drawParams.clipHeight = this.clipHeight;
      this.sprite.Size.width = this.clipWidth;
      return this.sprite.Size.height = this.clipHeight;
    };

    return SpriteSheetAnimation;

  })(Animation);

  AtlasFrameAnimation = (function(superClass) {
    extend(AtlasFrameAnimation, superClass);

    AtlasFrameAnimation.prototype.index = 0;

    function AtlasFrameAnimation(sprite1, atlasId1, textureId1, frames1, stepTime) {
      this.sprite = sprite1;
      this.atlasId = atlasId1;
      this.textureId = textureId1;
      this.frames = frames1;
      this.stepTime = stepTime;
      AtlasFrameAnimation.__super__.constructor.call(this);
      this.game = this.sprite.game;
      this.numberOfFrames = this.frames.length;
    }

    AtlasFrameAnimation.prototype.Update = function() {
      if (this.stopped) {
        return;
      }
      this.intervalTime += this.game.Loop.updateDelta;
      if (this.intervalTime >= this.stepTime) {
        return this.AdvanceFrame();
      }
    };

    AtlasFrameAnimation.prototype.AdvanceFrame = function() {
      this.intervalTime = 0;
      this.index += 1;
      this.sprite.Bind.Atlas(this.atlasId, this.textureId, this.frames[this.index]);
      if (this.index >= this.numberOfFrames - 1) {
        if (this.loop) {
          return this.index = 0;
        } else {
          this.Emit("Finish", new Torch.Event(this.game, {
            animation: this
          }));
          return this.Trash();
        }
      }
    };

    return AtlasFrameAnimation;

  })(Animation);

  BindManager = (function() {
    function BindManager(sprite1) {
      this.sprite = sprite1;
    }

    BindManager.prototype.Texture = function(textureId, optionalParameters) {
      var rawImage, tex, textureIdType;
      tex = null;
      textureIdType = Util.Type(textureId);
      if (textureIdType === "string") {
        rawImage = this.sprite.game.Assets.GetTexture(textureId);
        tex = new Texture(rawImage);
      } else if (textureIdType === "object") {
        tex = new Texture(textureId);
      } else {
        throw new ER.ArgumentError("textureId", textureId, ["string", "object"]);
      }
      this.sprite.Size.Set(tex.width, tex.height);
      return this.sprite.texture = tex;
    };

    BindManager.prototype.Video = function(videoId) {
      var rawVideo, video, videoIdType;
      video = null;
      videoIdType = Util.Type(videoId);
      if (videoIdType === "string") {
        rawVideo = this.sprite.game.Assets.GetVideo(videoId);
        video = new Video(rawVideo);
      } else if (videoIdType === "object") {
        video = new Video(rawVideo);
      } else {
        throw new ER.ArgumentError("videoId", videoId, ["string", "object"]);
      }
      this.sprite.video = video;
      return this.sprite.Size.Set(video.width, video.height);
    };

    BindManager.prototype.Atlas = function(textureId, textureAtlasId, textureName) {
      var atlasItem, textureAtlas;
      this.Texture(textureId);
      textureAtlas = this.sprite.game.Assets.GetTextureAtlas(textureAtlasId);
      atlasItem = textureAtlas.textures[textureName];
      this.sprite.texture.drawParams.clipX = atlasItem.x;
      this.sprite.texture.drawParams.clipY = atlasItem.y;
      this.sprite.texture.drawParams.clipWidth = atlasItem.width;
      this.sprite.texture.drawParams.clipHeight = atlasItem.height;
      return this.sprite.Size.Set(atlasItem.width, atlasItem.height);
    };

    return BindManager;

  })();

  CanvasRenderer = (function() {
    function CanvasRenderer(sprite1) {
      this.sprite = sprite1;
      this.game = this.sprite.game;
      this.previousPosition = new Point(this.sprite.position.x, this.sprite.position.y);
    }

    CanvasRenderer.prototype.Draw = function() {
      var cameraTransform, drawRec;
      drawRec = new Rectangle(this.sprite.position.x, this.sprite.position.y, this.sprite.rectangle.width, this.sprite.rectangle.height);
      drawRec.x = (this.sprite.position.x - this.previousPosition.x) * this.game.Loop.lagOffset + this.previousPosition.x;
      drawRec.y = (this.sprite.position.y - this.previousPosition.y) * this.game.Loop.lagOffset + this.previousPosition.y;
      this.previousPosition = new Point(this.sprite.position.x, this.sprite.position.y);
      cameraTransform = new Point(0, 0);
      if (!this.sprite.fixed) {
        drawRec.x += this.game.Camera.position.x + this.game.Hooks.positionTransform.x;
        drawRec.y += this.game.Camera.position.y + this.game.Hooks.positionTransform.y;
      }
      if (!this.sprite.draw) {
        return;
      }
      switch (this.sprite.torch_render_type) {
        case "Image":
          return this.RenderImageSprite(drawRec);
        case "Line":
          return this.RenderLineSprite(drawRec);
        case "Box":
          return this.RenderBoxSprite(drawRec);
        case "Circle":
          return this.RenderCircleSprite(drawRec);
        case "Polygon":
          return this.RenderPolygonSprite(drawRec);
      }
    };

    CanvasRenderer.prototype.RenderImageSprite = function(drawRec) {
      var canvas, frame, params, ref;
      if ((this.sprite.texture != null) || (this.sprite.video != null)) {
        frame = this.sprite.texture || this.sprite.video;
        params = frame.drawParams;
        canvas = this.game.canvas;
        canvas.save();
        this.SetCanvasStates(canvas, drawRec.x + drawRec.width / 2, drawRec.y + drawRec.height / 2);
        if (this.sprite.Effects.tint.color !== null) {
          canvas.fillStyle = this.sprite.Effects.tint.color;
          canvas.globalAlpha = this.sprite.Effects.tint.opacity;
          canvas.globalCompositeOperation = "destination-atop";
          canvas.fillRect(-drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
          canvas.globalAlpha = this.sprite.opacity;
        }
        canvas.drawImage(((ref = this.sprite.video) != null ? ref.video : void 0) || this.sprite.texture.image, params.clipX, params.clipY, params.clipWidth, params.clipHeight, -drawRec.width / 2 + this.sprite.rotationOffset.x, -drawRec.height / 2 + this.sprite.rotationOffset.y, drawRec.width, drawRec.height);
        if (this.sprite.Body.DEBUG) {
          canvas.fillStyle = this.sprite.Body.DEBUG;
          canvas.globalAlpha = 0.5;
          canvas.fillRect(-drawRec.width / 2, -drawRec.height / 2, drawRec.width, drawRec.height);
        }
        return canvas.restore();
      }
    };

    CanvasRenderer.prototype.RenderLineSprite = function(drawRec) {
      var ref;
      this.game.canvas.save();
      this.game.canvas.globalAlpha = this.sprite.opacity;
      this.game.canvas.strokeStyle = this.sprite.color;
      this.game.canvas.lineWidth = this.sprite.lineWidth;
      if (((ref = this.sprite.DrawTexture) != null ? ref.image : void 0) != null) {
        this.game.canvas.strokeStyle = this.game.canvas.createPattern(this.sprite.DrawTexture.image, "repeat");
      }
      this.game.canvas.beginPath();
      this.game.canvas.moveTo(drawRec.x, drawRec.y);
      this.game.canvas.lineTo(this.sprite.endPosition.x + this.game.Camera.position.x, this.sprite.endPosition.y + this.game.Camera.position.y);
      this.game.canvas.stroke();
      return this.game.canvas.restore();
    };

    CanvasRenderer.prototype.RenderCircleSprite = function(drawRec) {
      this.game.canvas.save();
      this.game.canvas.translate(drawRec.x + this.sprite.radius / 2, drawRec.y + this.sprite.radius / 2);
      this.game.canvas.globalAlpha = this.sprite.opacity;
      this.game.canvas.strokeStyle = this.sprite.strokeColor;
      this.game.canvas.fillStyle = this.sprite.fillColor;
      this.game.canvas.beginPath();
      this.game.canvas.arc(0, 0, this.sprite.radius, this.sprite.startAngle, this.sprite.endAngle, this.sprite.drawDirection === "counterclockwise");
      this.game.canvas.fill();
      this.game.canvas.stroke();
      return this.game.canvas.restore();
    };

    CanvasRenderer.prototype.RenderBoxSprite = function(drawRec) {
      this.game.canvas.save();
      this.SetCanvasStates(this.game.canvas, drawRec.x + this.sprite.width / 2, drawRec.y + this.sprite.height / 2);
      this.game.canvas.beginPath();
      this.game.canvas.rect(-this.sprite.width / 2, -this.sprite.height / 2, this.sprite.width, this.sprite.height);
      this.game.canvas.fill();
      this.game.canvas.stroke();
      return this.game.canvas.restore();
    };

    CanvasRenderer.prototype.RenderPolygonSprite = function(drawRec) {
      var centerPoint, k, len, point, ref;
      this.game.canvas.save();
      centerPoint = Point.GetCenterPoint(this.sprite.points);
      this.SetCanvasStates(this.game.canvas, drawRec.x + centerPoint.x / 2, drawRec.y + centerPoint.y / 2);
      this.game.canvas.beginPath();
      this.game.canvas.moveTo(0, 0);
      ref = this.sprite.points;
      for (k = 0, len = ref.length; k < len; k++) {
        point = ref[k];
        this.game.canvas.lineTo(point.x, point.y);
      }
      this.game.canvas.closePath();
      this.game.canvas.stroke();
      this.game.canvas.fill();
      return this.game.canvas.restore();
    };

    CanvasRenderer.prototype.SetCanvasStates = function(canvas, transFormX, transFormY) {
      if (this.sprite.opacity != null) {
        canvas.globalAlpha = this.sprite.opacity;
      }
      if (this.sprite.strokeColor != null) {
        canvas.strokeStyle = this.sprite.strokeColor;
      }
      if (this.sprite.fillColor != null) {
        canvas.fillStyle = this.sprite.fillColor;
      }
      canvas.translate(transFormX, transFormY);
      return canvas.rotate(this.sprite.rotation);
    };

    return CanvasRenderer;

  })();

  CloneManager = (function() {
    CloneManager.prototype.sprite = null;

    function CloneManager(sprite1) {
      this.sprite = sprite1;
    }

    CloneManager.prototype._defaultClone = function(keepGame) {
      var clone, key, ref, value;
      clone = {};
      ref = this.sprite;
      for (key in ref) {
        value = ref[key];
        if (key === "game") {
          continue;
        }
        if (Util.Type(value) === "object") {
          value = Object.create(value);
        }
        clone[key] = value;
      }
      if (keepGame) {
        this.sprite.game.Add(clone);
      }
      return clone;
    };

    CloneManager.prototype.WithConstructor = function() {
      var SpriteConstructor, args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.sprite.constructor == null) {
        throw new Error("Unable to clone with constructor: sprite has no constructor");
      }
      SpriteConstructor = this.sprite.constructor;
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(SpriteConstructor, args, function(){});
    };

    CloneManager.prototype.WithGame = function(keepGame) {
      if (keepGame == null) {
        keepGame = false;
      }
      return this._defaultClone(keepGame);
    };

    return CloneManager;

  })();

  TorchModule(Sprite = (function(superClass) {
    extend(Sprite, superClass);

    Sprite.MixIn(EventDispatcher);

    Sprite.prototype.torch_render_type = "Image";

    Sprite.prototype.torch_type = "Sprite";

    function Sprite(game, x, y) {
      this.InitSprite(game, x, y);
    }

    Sprite.prototype.InitSprite = function(game, x, y) {
      var gameType, xType, yType;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      gameType = Util.Type(game);
      xType = Util.Type(x);
      yType = Util.Type(y);
      if ((game == null) || gameType !== "Game") {
        throw new ER.ArgumentError("game", game, ["Torch.Game"]);
      }
      if (xType !== "number") {
        throw new ER.ArgumentError("x", x, ["number"]);
      }
      if (yType !== "number") {
        throw new ER.ArgumentError("y", y, ["number"]);
      }
      this.InitEventDispatch();
      this.game = game;
      this.rectangle = new Rectangle(x, y, 0, 0);
      this.position = new Vector(x, y);
      this.rotationOffset = new Vector(0, 0);
      this.Bind = new BindManager(this);
      this.Collisions = new CollisionManager(this);
      this.Body = new BodyManager(this);
      this.Size = new SizeManager(this);
      this.Events = new EventManager(this);
      this.Effects = new EffectManager(this);
      this.States = new StateMachineManager(this);
      this.Grid = new GridManager(this);
      this.Animations = new AnimationManager(this);
      this.Clone = new CloneManager(this);
      this.texture = null;
      this.video = null;
      this.fixed = false;
      this.draw = true;
      this.paused = false;
      this.drawIndex = 0;
      this.rotation = 0;
      this.opacity = 1;
      this._torch_add = "Sprite";
      this._torch_uid = "";
      this.events = {};
      this.renderer = new CanvasRenderer(this);
      this.exportValues = [];
      return game.Add(this);
    };

    Sprite.prototype.UpdateSprite = function() {
      if (this.paused) {
        return;
      }
      this.rectangle.x = this.position.x;
      this.rectangle.y = this.position.y;
      this.Body.Update();
      this.Size.Update();
      this.Events.Update();
      this.States.Update();
      this.Grid.Update();
      this.Animations.Update();
      this.Effects.Update();
      this.Collisions.Update();
      if (this.game.boundary && !this.rectangle.Intersects(this.game.boundary)) {
        return this.Emit("OutOfBounds", new Event(this.game, {
          sprite: this
        }));
      }
    };

    Sprite.prototype.Update = function() {
      return this.UpdateSprite();
    };

    Sprite.prototype.Draw = function() {
      return this.renderer.Draw();
    };

    Sprite.prototype.NotSelf = function(otherSprite) {
      return otherSprite.torch_uid !== this.torch_uid;
    };

    Sprite.prototype.Wrap = function() {
      return this.On("OutOfBounds", (function(_this) {
        return function() {
          if (!_this.game.boundary) {
            return;
          }
          if (_this.position.y < _this.game.boundary.y) {
            _this.position.y = _this.game.boundary.height - _this.rectangle.height;
          }
          if (_this.position.y > _this.game.boundary.height) {
            _this.position.y = _this.game.boundary.y + _this.rectangle.height;
          }
          if (_this.position.x > _this.game.boundary.width) {
            _this.position.x = _this.game.boundary.x + _this.rectangle.width;
          }
          if (_this.position.x < _this.game.boundary.x) {
            return _this.position.x = _this.game.boundary.width - _this.rectangle.width;
          }
        };
      })(this));
    };

    Sprite.prototype.Clone = function() {
      return Object.create(this);
    };

    Sprite.prototype.Center = function() {
      var width, x;
      width = this.game.canvasNode.width;
      x = (width / 2) - (this.rectangle.width / 2);
      this.position.x = x;
      return this;
    };

    Sprite.prototype.CenterVertical = function() {
      var height, y;
      height = this.game.canvasNode.height;
      y = (height / 2) - (this.rectangle.height / 2);
      this.position.y = y;
      return this;
    };

    Sprite.prototype.CollidesWith = function(otherSprite) {
      return new CollisionDetector(this, otherSprite);
    };

    Sprite.prototype.Pause = function(shouldPause) {
      if (shouldPause == null) {
        shouldPause = true;
      }
      return this.paused = shouldPause;
    };

    Sprite.prototype.Export = function() {
      var attribsToExport;
      attribsToExport = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.exportValues = attribsToExport;
    };

    return Sprite;

  })(GameThing));

  if (typeof document !== "undefined" && document !== null) {
    _measureCanvas = document.createElement("CANVAS");
    _measureCanvas.width = 500;
    _measureCanvas.height = 500;
  } else {
    _measureCanvas = {
      getContext: function() {}
    };
  }

  TorchModule(Text = (function(superClass) {
    extend(Text, superClass);

    Text.prototype.TEXT = true;

    Text.measureCanvas = _measureCanvas.getContext("2d");

    Text.property('fontSize', {
      get: function() {
        return this._fontSize;
      },
      set: function(fontSize) {
        this._fontSize = fontSize;
        return Util.Function((function(_this) {
          return function() {
            return _this.Render();
          };
        })(this)).Defer();
      }
    });

    Text.property('font', {
      get: function() {
        return this._font;
      },
      set: function(font) {
        this._font = font;
        return Util.Function((function(_this) {
          return function() {
            return _this.Render();
          };
        })(this)).Defer();
      }
    });

    Text.property('fontWeight', {
      get: function() {
        return this._fontWeight;
      },
      set: function(fontWeight) {
        this._fontWeight = fontWeight;
        return Util.Function((function(_this) {
          return function() {
            return _this.Render();
          };
        })(this)).Defer();
      }
    });

    Text.property('color', {
      get: function() {
        return this._color;
      },
      set: function(color) {
        this._color = color;
        return Util.Function((function(_this) {
          return function() {
            return _this.Render();
          };
        })(this)).Defer();
      }
    });

    Text.property('text', {
      get: function() {
        return this._text;
      },
      set: function(text) {
        this._text = text;
        return Util.Function((function(_this) {
          return function() {
            return _this.Render();
          };
        })(this)).Defer();
      }
    });

    function Text(game, x, y, data) {
      this.InitText(game, x, y, data);
    }

    Text.prototype.InitText = function(game, x, y, data) {
      this.InitSprite(game, x, y);
      this.data = data;
      this._font = "Arial";
      this._fontSize = 16;
      this._fontWeight = "";
      this._color = "#2b4531";
      this._text = "";
      this.width = 100;
      this.height = 100;
      this.Size.scale = {
        width: 1,
        height: 1
      };
      return this.Init();
    };

    Text.prototype.Init = function() {
      if (this.data.font) {
        this._font = this.data.font;
      }
      if (this.data.fontSize) {
        this._fontSize = this.data.fontSize;
      }
      if (this.data.fontWeight) {
        this._fontWeight = this.data.fontWeight;
      }
      if (this.data.color) {
        this._color = this.data.color;
      }
      if (this.data.text) {
        this._text = this.data.text;
      }
      if (this.data.rectangle) {
        this.rectangle = this.data.rectangle;
      }
      if (this.data.buffHeight) {
        this.buffHeight = this.data.buffHeight;
      }
      return this.Render();
    };

    Text.prototype.Render = function() {
      var canvas, cnv, image;
      cnv = document.createElement("CANVAS");
      Text.measureCanvas.font = this._fontSize + "px " + this._font;
      cnv.width = Text.measureCanvas.measureText(this._text).width;
      cnv.height = this._fontSize;
      if (this.buffHeight) {
        cnv.height += this.buffHeight;
      }
      canvas = cnv.getContext("2d");
      canvas.fillStyle = this._color;
      canvas.font = this._fontWeight + " " + this._fontSize + "px " + this._font;
      canvas.fillText(this._text, 0, cnv.height);
      image = new Image();
      image.src = cnv.toDataURL();
      image.onload = (function(_this) {
        return function() {
          return _this.Bind.Texture(image);
        };
      })(this);
      this.rectangle.width = cnv.width;
      return this.rectangle.height = this._fontSize;
    };

    Text.prototype.Update = function() {
      return Text.__super__.Update.call(this);
    };

    return Text;

  })(Sprite));

  TorchModule(BitmapText = (function() {
    function BitmapText() {}

    return BitmapText;

  })());


  /*
      We need to have circles, rectangles, lines, and polys
   */

  Shapes = {
    name: "Shapes"
  };

  TorchModule(Shapes);

  Shapes.Circle = (function(superClass) {
    extend(Circle, superClass);

    Circle.prototype.torch_render_type = "Circle";

    Circle.prototype.radius = 0;

    Circle.prototype.fillColor = "black";

    Circle.prototype.strokeColor = "black";

    Circle.prototype.startAngle = 0;

    Circle.prototype.endAngle = 2 * Math.PI;

    Circle.prototype.drawDirection = "clockwise";

    function Circle(game, x, y, radius, fillColor, strokeColor) {
      if (fillColor == null) {
        fillColor = "black";
      }
      if (strokeColor == null) {
        strokeColor = "black";
      }
      this.InitSprite(game, x, y);
      this.radius = radius;
      this.fillColor = fillColor;
      this.strokeColor = strokeColor;
    }

    return Circle;

  })(Sprite);

  Shapes.Line = (function(superClass) {
    extend(Line, superClass);

    Line.prototype.torch_render_type = "Line";

    Line.prototype.color = "black";

    Line.prototype.lineWidth = 1;

    Line.prototype.endPosition = null;

    function Line(game, x, y, endX, endY, color1, config) {
      this.color = color1;
      this.InitSprite(game, x, y);
      this.endPosition = new Point(endX, endY);
      Util.Object(this).Extend(config);
    }

    return Line;

  })(Sprite);

  Shapes.Box = (function(superClass) {
    extend(Box, superClass);

    Box.prototype.torch_render_type = "Box";

    Box.prototype.torch_shape = true;

    Box.prototype.fillColor = "black";

    Box.prototype.strokeColor = "black";

    Box.prototype.width = 0;

    Box.prototype.height = 0;

    function Box(game, x, y, width, height, fillColor, strokeColor) {
      if (fillColor == null) {
        fillColor = "black";
      }
      if (strokeColor == null) {
        strokeColor = "black";
      }
      this.InitSprite(game, x, y);
      this.width = width;
      this.height = height;
      this.fillColor = fillColor;
      this.strokeColor = strokeColor;
    }

    return Box;

  })(Sprite);

  Shapes.Polygon = (function(superClass) {
    extend(Polygon, superClass);

    Polygon.prototype.torch_render_type = "Polygon";

    function Polygon(game, x, y, points1, fillColor1, strokeColor1) {
      this.points = points1;
      this.fillColor = fillColor1;
      this.strokeColor = strokeColor1;
      this.InitSprite(game, x, y);
    }

    Polygon.Regular = function(game, x, y, sides, width, fillColor, strokeColor) {
      var angle, angleInterval, points, px, py, shape;
      angleInterval = (Math.PI * 2) / sides;
      points = [];
      angle = 0;
      while (angle <= Math.PI * 2) {
        px = Math.cos(angle) * width;
        py = Math.sin(angle) * width;
        points.push(new Point(px, py));
        angle += angleInterval;
      }
      shape = new Shapes.Polygon(game, x, y, points, fillColor, strokeColor);
      shape.rectangle.width = shape.rectangle.height = width;
      return shape;
    };

    return Polygon;

  })(Sprite);

  TorchModule(SpriteGroup = (function(superClass) {
    extend(SpriteGroup, superClass);

    SpriteGroup.MixIn(EventDispatcher);

    SpriteGroup.prototype.sprites = null;

    SpriteGroup.prototype.position = null;

    function SpriteGroup(game1, x, y) {
      this.game = game1;
      this.InitEventDispatch();
      this.game.Add(this);
      this.sprites = [];
      this.position = new Vector(x, y);
    }

    SpriteGroup.prototype.Update = function() {
      var filtered, k, len, ref, sprite;
      filtered = [];
      ref = this.sprites;
      for (k = 0, len = ref.length; k < len; k++) {
        sprite = ref[k];
        if (!sprite.trash) {
          filtered.push(sprite);
        }
      }
      this.sprites = filtered;
      if (filtered.length <= 0) {
        return this.Emit("Empty", new Event(this.game, {
          spriteGroup: this
        }));
      }
    };

    SpriteGroup.prototype.Every = function(calback) {
      var k, len, ref, results, sprite;
      ref = this.sprites;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        sprite = ref[k];
        results.push(calback(sprite));
      }
      return results;
    };

    SpriteGroup.prototype.Grid = function(spriteToCopy, rows, columns, padding) {
      var copy, distribution, first, height, i, index, j, results, width;
      if (padding == null) {
        padding = 0;
      }
      distribution = null;
      if (Util.Type(spriteToCopy) !== "array") {
        first = new spriteToCopy(this.game, this.position.x, this.position.y);
      } else {
        distribution = spriteToCopy;
        first = new distribution[0](this.game, this.position.x, this.position.y);
      }
      width = first.rectangle.width;
      height = first.rectangle.height;
      first.Trash();
      width += padding;
      height += padding;
      i = 0;
      results = [];
      while (i < rows) {
        j = 0;
        while (j < columns) {
          if (distribution === null) {
            copy = new spriteToCopy(this.game, this.position.x + (i * width), this.position.y + (j * height));
          } else {
            index = Util.Math.RandomInRange(0, distribution.length - 1);
            index = Math.floor(index);
            console.log(distribution, index);
            copy = new distribution[index](this.game, this.position.x + (i * width), this.position.y + (j * height));
          }
          this.sprites.push(copy);
          j++;
        }
        results.push(i++);
      }
      return results;
    };

    return SpriteGroup;

  })(GameThing));

  CollisionDetector = (function() {
    function CollisionDetector(sprite1, otherSprite1) {
      this.sprite = sprite1;
      this.otherSprite = otherSprite1;
    }

    CollisionDetector.prototype.AABB = function() {
      return new AABB(this.sprite, this.otherSprite).Execute();
    };

    CollisionDetector.prototype.Circle = function() {
      return new Circle(this.sprite, this.otherSprite).Execute();
    };

    CollisionDetector.prototype.SAT = function() {
      return new SAT(this.sprite, this.otherSprite).Execute();
    };

    return CollisionDetector;

  })();

  AABB = (function() {
    function AABB(sprite1, otherSprite1) {
      this.sprite = sprite1;
      this.otherSprite = otherSprite1;
    }

    AABB.prototype.Execute = function() {
      return this.sprite.rectangle.Intersects(this.otherSprite.rectangle);
    };

    return AABB;

  })();

  Circle = (function() {
    function Circle(sprite1, otherSprite1) {
      this.sprite = sprite1;
      this.otherSprite = otherSprite1;
    }

    Circle.prototype.Execute = function() {
      var circle1, circle2, distance, dx, dy;
      circle1 = {
        radius: this.sprite.Width(),
        x: this.sprite.Position("x"),
        y: this.sprite.Position("y")
      };
      circle2 = {
        radius: this.otherSprite.Width(),
        x: this.otherSprite.Position("x"),
        y: this.otherSprite.Position("y")
      };
      dx = circle1.x - circle2.x;
      dy = circle1.y - circle2.y;
      distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < circle1.radius + circle2.radius) {
        return true;
      }
      return false;
    };

    return Circle;

  })();

  Collision = {
    AABB: 1,
    Circle: 2,
    SAT: 3
  };

  CollisionManager = (function() {
    CollisionManager.prototype.mode = Collision.AABB;

    CollisionManager.prototype.sprite = null;

    CollisionManager.prototype.filter = null;

    CollisionManager.prototype.limit = null;

    CollisionManager.prototype.enabled = false;

    function CollisionManager(sprite1) {
      this.sprite = sprite1;
      this.filter = {};
      this.game = this.sprite.game;
    }

    CollisionManager.prototype.Monitor = function() {
      return this.enabled = true;
    };

    CollisionManager.prototype.NotFiltered = function(sprite) {
      var key, ref, ref1, value;
      ref = this.game.filter;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      ref1 = this.filter;
      for (key in ref1) {
        value = ref1[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return false;
          }
        } else {
          if (value === sprite[key]) {
            return false;
          }
        }
      }
      return true;
    };

    CollisionManager.prototype.InLimit = function(sprite) {
      var key, ref, value;
      ref = this.limit;
      for (key in ref) {
        value = ref[key];
        if (key === "__type__") {
          if (value.constructor.name === sprite.constructor.name) {
            return true;
          }
        } else {
          if (value === sprite[key]) {
            return true;
          }
        }
      }
      return false;
    };

    CollisionManager.prototype.Valid = function(sprite) {
      if (this.limit !== null) {
        return this.InLimit(sprite);
      }
      return this.NotFiltered(sprite);
    };

    CollisionManager.prototype.Filter = function(_filter) {
      return this.filter = _filter;
    };

    CollisionManager.prototype.Limit = function(_limit) {
      return this.limit = _limit;
    };

    CollisionManager.prototype.Mode = function(_mode) {
      var mode;
      return mode = _mode;
    };

    CollisionManager.prototype.Update = function() {
      var anyCollisions, collisionData, collisionDetected, k, len, otherSprite, ref;
      if (!this.sprite.game || !this.enabled) {
        return;
      }
      this.game = this.sprite.game;
      anyCollisions = false;
      ref = this.game.things;
      for (k = 0, len = ref.length; k < len; k++) {
        otherSprite = ref[k];
        if (otherSprite.torch_type === "Sprite") {
          if (this.sprite.NotSelf(otherSprite) && this.Valid(otherSprite)) {
            collisionDetected = false;
            collisionData = {};
            switch (this.mode) {
              case Collision.AABB:
                collisionData = this.sprite.CollidesWith(otherSprite).AABB();
                collisionDetected = collisionData !== false;
            }
            if (collisionDetected) {
              collisionData.self = this.sprite;
              collisionData.collider = otherSprite;
              anyCollisions === true;
              this.sprite.Emit("Collision", new Torch.Event(this.game, {
                collisionData: collisionData
              }));
            }
          }
        }
      }
      return this.sprite.Emit("NoCollision", new Torch.Event(this.game, {}));
    };

    CollisionManager.prototype.SimpleCollisionHandle = function(event, sink) {
      var offset, touching;
      if (sink == null) {
        sink = 1;
      }
      offset = event.collisionData;
      touching = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      if (offset.vx < offset.halfWidths && offset.vy < offset.halfHeights) {
        if (offset.x < offset.y) {
          if (offset.vx > 0) {
            event.collisionData.self.position.x += offset.x * sink;
            touching.left = true;
          } else if (offset.vx < 0) {
            event.collisionData.self.position.x -= offset.x * sink;
            touching.right = true;
          }
        } else if (offset.x > offset.y) {
          if (offset.vy > 0) {
            event.collisionData.self.position.y += offset.y * sink;
            touching.top = true;
          } else if (offset.vy < 0) {
            event.collisionData.self.position.y -= offset.y * sink;
            touching.bottom = true;
          }
        }
      }
      return touching;
    };

    CollisionManager.prototype.CastRay = function() {};

    return CollisionManager;

  })();

  Loop = (function() {
    function Loop(game1) {
      this.game = game1;
      this.fps = 50;
      this.frameTime = 1000 / this.fps;
      this.lag = 0;
      this.updateDelta = 0;
      this.drawDelta = 0;
      this.lagOffset;
    }

    Loop.prototype.Update = function() {
      this.game.update(this.game);
      this.game.State.Update();
      this.game.GamePads.Update();
      return this.game.UpdateThings();
    };

    Loop.prototype.Draw = function() {
      this.game.draw(this.game);
      return this.game.DrawThings();
    };

    Loop.prototype.AdvanceFrame = function(timestamp) {
      var elapsed;
      if (this.game.time === void 0) {
        this.game.time = timestamp;
      }
      this.game.deltaTime = Math.round(timestamp - this.game.time);
      this.game.time = timestamp;
      elapsed = this.game.deltaTime;
      this.drawDelta = elapsed;
      this.updateDelta = this.frameTime;
      if (elapsed > 1000) {
        elapsed = this.frameTime;
      }
      this.lag += elapsed;
      while (this.lag >= this.frameTime) {
        this.Update();
        this.lag -= this.frameTime;
      }
      this.lagOffset = this.lag / this.frameTime;
      this.Draw();
      return window.requestAnimationFrame((function(_this) {
        return function(timestamp) {
          return _this.AdvanceFrame(timestamp);
        };
      })(this));
    };

    Loop.prototype.Run = function(timestamp) {
      return this.AdvanceFrame(0);
    };

    return Loop;

  })();

  AssetManager = (function() {
    AssetManager.prototype.game = null;

    AssetManager.prototype.textures = null;

    AssetManager.prototype.audio = null;

    AssetManager.prototype.video = null;

    AssetManager.prototype.files = null;

    AssetManager.prototype.textureAtlases = null;

    function AssetManager(game1) {
      this.game = game1;
      this.textures = {};
      this.audio = {};
      this.video = {};
      this.textureAtlases = {};
      this.files = {};
    }

    AssetManager.prototype.GetTexture = function(id) {
      return this.textures[id];
    };

    AssetManager.prototype.GetAudio = function(id) {
      return this.audio[id];
    };

    AssetManager.prototype.GetVideo = function(id) {
      return this.video[id];
    };

    AssetManager.prototype.GetTextureAtlas = function(id) {
      return this.textureAtlases[id];
    };

    AssetManager.prototype.GetFile = function(id) {
      return this.files[id];
    };

    return AssetManager;

  })();

  LoadType = Util.Enum("Texture", "Audio", "Video", "File", "TextureAtlas");

  LoadJob = (function() {
    function LoadJob(loadType, id1, path1) {
      this.loadType = loadType;
      this.id = id1;
      this.path = path1;
    }

    return LoadJob;

  })();

  Load = (function() {
    Load.MixIn(EventDispatcher);

    function Load(game1) {
      this.game = game1;
      this.InitEventDispatch();
      this.files = this.game.Assets.files;
      this.textures = this.game.Assets.textures;
      this.audio = this.game.Assets.audio;
      this.video = this.game.Assets.video;
      this.textureAtlases = this.game.Assets.textureAtlases;
      this.loadJobs = [];
      this.itemsLeftToLoad = 0;
      this.progress = 0;
      this.loaded = false;
      this.loadLog = "";
    }

    Load.prototype.Audio = function(path, id) {
      return this.loadJobs.push(new LoadJob(LoadType.Audio, id, path));
    };

    Load.prototype.Texture = function(path, id) {
      return this.loadJobs.push(new LoadJob(LoadType.Texture, id, path));
    };

    Load.prototype.TextureAtlas = function(path, id) {
      return this.loadJobs.push(new LoadJob(LoadType.TextureAtlas, id, path));
    };

    Load.prototype.Video = function(path, id) {
      return this.loadJobs.push(new LoadJob(LoadType.Video, id, path));
    };

    Load.prototype.File = function(path, id) {
      return this.loadJobs.push(new LoadJob(LoadType.File, id, path));
    };

    Load.prototype.Font = function(path, name) {
      var cssFontRule, manualLoader, style;
      style = document.createElement("style");
      manualLoader = document.createElement("p");
      cssFontRule = "@font-face{\n    font-family: " + name + ";\n    src: url(" + path + ");\n}";
      cssFontRule = document.createTextNode(cssFontRule);
      style.appendChild(cssFontRule);
      manualLoader.innerHTML = "TEST";
      manualLoader.style.fontFamily = name;
      document.head.appendChild(style);
      return document.body.appendChild(manualLoader);
    };

    Load.prototype.LoadItemFinished = function() {
      var ref, timeToLoad;
      this.itemsLeftToLoad -= 1;
      this.progress = (this.totalLoad - this.itemsLeftToLoad) / this.totalLoad;
      this.game.Emit("LoadProgressed", new Event(this.game, {
        progress: this.progress
      }));
      if (this.itemsLeftToLoad <= 0) {
        if ((ref = document.getElementsByClassName("font-loader")[0]) != null) {
          ref.remove();
        }
        timeToLoad = (new Date().getTime() - this.startTime) / 1000;
        this.Emit("LoadFinished", new Event(this.game, {
          timeToLoad: timeToLoad
        }));
        return console.log("%c" + this.game.name + " loaded in " + timeToLoad + "s", "background-color:green;\ncolor:white;\npadding:2px;\npadding-right:5px;\npadding-left:5px");
      }
    };

    Load.prototype.Load = function() {
      var e, k, len, loadJob, ref, results;
      this.totalLoad = this.loadJobs.length;
      this.itemsLeftToLoad = this.totalLoad;
      this.startTime = new Date().getTime();
      try {
        ref = this.loadJobs;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          loadJob = ref[k];
          switch (loadJob.loadType) {
            case LoadType.Texture:
              results.push(this.LoadTexture(loadJob));
              break;
            case LoadType.Video:
              results.push(this.LoadVideo(loadJob));
              break;
            case LoadType.Audio:
              results.push(this.LoadAudio(loadJob));
              break;
            case LoadType.File:
              results.push(this.LoadFile(loadJob));
              break;
            case LoadType.TextureAtlas:
              results.push(this.LoadTextureAtlas(loadJob));
              break;
            default:
              results.push(void 0);
          }
        }
        return results;
      } catch (error1) {
        e = error1;
        console.log("%c" + this.game.name + " could not load!", "background-color:" + Color.Ruby + ";\ncolor:white;\npadding:2px;\npadding-right:5px;\npadding-left:5px");
        return Torch.FatalError(e);
      }
    };

    Load.prototype.LoadTexture = function(loadJob) {
      var im;
      im = new Image();
      im.src = loadJob.path;
      this.textures[loadJob.id] = im;
      return im.onload = (function(_this) {
        return function() {
          return _this.LoadItemFinished();
        };
      })(this);
    };

    Load.prototype.LoadTextureAtlas = function(loadJob) {
      var loader;
      loader = new Torch.AjaxLoader(loadJob.path, Torch.AjaxData.Text);
      loader.loadJob = loadJob;
      loader.Finish((function(_this) {
        return function(data, loader) {
          _this.LoadItemFinished();
          return _this.textureAtlases[loader.loadJob.id] = JSON.parse(data);
        };
      })(this));
      return loader.Load();
    };

    Load.prototype.LoadVideo = function(loadJob) {
      var video;
      video = document.createElement("video");
      video.src = loadJob.path;
      this.video[loadJob.id] = video;
      return video.addEventListener("loadeddata", (function(_this) {
        return function() {
          return _this.LoadItemFinished();
        };
      })(this));
    };

    Load.prototype.LoadAudio = function(loadJob) {
      var loader;
      loader = new Torch.AjaxLoader(loadJob.path, Torch.AjaxData.ArrayBuffer);
      loader.loadJob = loadJob;
      loader.Finish((function(_this) {
        return function(data, loader) {
          _this.audio[loader.loadJob.id] = {};
          _this.audio[loader.loadJob.id].encodedAudioData = data;
          return _this.game.Audio.DecodeAudioData(data, function(buffer) {
            _this.audio[loader.loadJob.id].audioData = buffer;
            return _this.LoadItemFinished();
          });
        };
      })(this));
      return loader.Load();
    };

    Load.prototype.LoadFile = function(loadJob) {
      var loader;
      loader = new Torch.AjaxLoader(loadJob.path, Torch.AjaxData.Text);
      loader.loadJob = loadJob;
      loader.Finish((function(_this) {
        return function(data, loader) {
          _this.LoadItemFinished();
          return _this.files[loader.loadJob.id] = data;
        };
      })(this));
      return loader.Load();
    };

    return Load;

  })();

  Timer = (function() {
    function Timer(game1) {
      this.game = game1;
    }

    Timer.prototype.SetFutureEvent = function(timeToOccur, handle) {
      var ev;
      ev = new FutureEvent(timeToOccur, handle, this.game);
      this.game.Add(ev);
      return ev;
    };

    Timer.prototype.SetScheduledEvent = function(interval, handle) {
      var ev;
      ev = new ScheduledEvent(interval, handle, this.game);
      this.game.Add(ev);
      return ev;
    };

    return Timer;

  })();

  FutureEvent = (function(superClass) {
    extend(FutureEvent, superClass);

    function FutureEvent(timeToOccur1, handle1, game1) {
      this.timeToOccur = timeToOccur1;
      this.handle = handle1;
      this.game = game1;
      this.time = 0;
    }

    FutureEvent.prototype.Update = function() {
      this.time += this.game.Loop.updateDelta;
      if (this.time >= this.timeToOccur) {
        if (this.handle !== null && this.handle !== void 0) {
          this.handle();
          return this.handle = null;
        }
      }
    };

    return FutureEvent;

  })(GameThing);

  ScheduledEvent = (function(superClass) {
    extend(ScheduledEvent, superClass);

    function ScheduledEvent(interval1, handle1, game1) {
      this.interval = interval1;
      this.handle = handle1;
      this.game = game1;
      this.elapsedTime = 0;
    }

    ScheduledEvent.prototype.Update = function() {
      this.elapsedTime += this.game.Loop.updateDelta;
      if (this.elapsedTime >= this.interval) {
        if (this.handle != null) {
          this.handle();
        }
        return this.elapsedTime = 0;
      }
    };

    return ScheduledEvent;

  })(GameThing);

  Mouse = (function() {
    function Mouse(game1) {
      this.game = game1;
      this.x = 0;
      this.y = 0;
      this.down = false;
    }

    Mouse.prototype.SetMousePos = function(c, evt) {
      var rect;
      rect = c.getBoundingClientRect();
      this.x = evt.clientX - rect.left;
      return this.y = evt.clientY - rect.top;
    };

    Mouse.prototype.GetRectangle = function() {
      return new Rectangle(this.x, this.y, 5, 5);
    };

    Mouse.prototype.SetCursor = function(textureId) {
      var texture;
      texture = this.game.Assets.GetTexture(textureId);
      return this.game.canvasNode.style.cursor = "url(" + texture.src + "), auto";
    };

    return Mouse;

  })();

  Camera = (function() {
    Camera.prototype.position = null;

    Camera.prototype._jerkFollow = null;

    function Camera(game1) {
      this.game = game1;
      this.position = new Point(0, 0);
      this.Viewport = new Viewport(this);
    }

    Camera.prototype.JerkFollow = function(sprite, offset, config) {
      if (offset == null) {
        offset = 5;
      }
      if (config == null) {
        config = {
          maxLeft: -500,
          maxRight: 2000,
          maxTop: -500,
          maxBottom: 2000
        };
      }
      this._jerkFollow = new JerkFollow(this, sprite, offset, config);
      return this.game.Add(this._jerkFollow);
    };

    return Camera;

  })();

  Viewport = (function() {
    Viewport.prototype.width = 0;

    Viewport.prototype.height = 0;

    Viewport.prototype.maxWidth = 0;

    Viewport.prototype.maxHeight = 0;

    function Viewport(camera) {
      this.camera = camera;
      this.maxWidth = this.width = window.innerWidth;
      this.maxHeight = this.height = window.innerHeight;
      this.rectangle = new Rectangle(this.camera.position.x, this.camera.position.y, this.width, this.height);
    }

    Viewport.prototype.Update = function() {
      this.rectangle.x = this.camera.position.x;
      this.rectangle.y = this.camera.position.y;
      this.rectangle.width = this.width;
      return this.rectangle.height = this.height;
    };

    return Viewport;

  })();

  JerkFollow = (function(superClass) {
    extend(JerkFollow, superClass);

    JerkFollow.prototype.boundLeft = 0;

    JerkFollow.prototype.boundRight = 0;

    JerkFollow.prototype.boundTop = 0;

    JerkFollow.prototype.boundBottom = 0;

    JerkFollow.prototype.Inc = 0;

    function JerkFollow(camera, sprite1, offset, config1) {
      var v;
      this.camera = camera;
      this.sprite = sprite1;
      this.config = config1;
      v = this.camera.Viewport;
      this.game = this.camera.game;
      this.Inc = v.width / offset;
      this.boundLeft = v.width / offset;
      this.boundRight = v.width - this.boundLeft;
      this.boundTop = 0;
    }

    JerkFollow.prototype.Update = function() {
      if (this.sprite.position.x >= this.boundRight) {
        if (this.sprite.position.x >= this.config.maxRight) {
          this.sprite.position.x = this.boundRight;
          return;
        }
        this.boundRight += this.Inc;
        this.boundLeft += this.Inc;
        this.game.Tweens.Tween(this.camera.position, 500, Torch.Easing.Smooth).To({
          x: this.camera.position.x - this.Inc
        });
      }
      if (this.sprite.position.x <= this.boundLeft) {
        if (this.sprite.position.x <= this.config.maxLeft) {
          this.sprite.position.x = this.boundLeft;
          return;
        }
        this.boundRight -= this.Inc;
        this.boundLeft -= this.Inc;
        this.game.Tweens.Tween(this.camera.position, 500, Torch.Easing.Smooth).To({
          x: this.camera.position.x + this.Inc
        });
      }
      if (this.sprite.position.y <= this.boundTop) {
        if (this.sprite.position.y <= this.config.maxTop) {
          this.sprite.position.y = this.boundTop;
          return;
        }
        this.boundTop -= this.Inc;
        this.boundBottom -= this.Inc;
        return this.game.Tweens.Tween(this.camera.position, 500, Torch.Easing.Smooth).To({
          x: this.camera.position.y + this.Inc
        });
      }
    };

    return JerkFollow;

  })(GameThing);

  Layer = (function() {
    function Layer(drawIndex) {
      this.drawIndex = drawIndex;
      this.children = [];
      this.mapIndex - this.drawIndex;
    }

    Layer.prototype.DrawIndex = function(index) {
      var child, k, len, ref;
      if (!index) {
        return this.drawIndex;
      }
      this.drawIndex = index;
      ref = this.children;
      for (k = 0, len = ref.length; k < len; k++) {
        child = ref[k];
        child.DrawIndex(index);
      }
      return this;
    };

    Layer.prototype.Add = function(child) {
      child.DrawIndex(this.index);
      return this.children.push(child);
    };

    return Layer;

  })();

  Layers = (function() {
    function Layers(game1) {
      this.game = game1;
      this.layers = [];
      this.layerMap = {};
    }

    Layers.prototype.Add = function(layerName) {
      var k, layer, len, name, results;
      layer = null;
      if (typeof layerName === "string") {
        layer = new Layer(this.layers.length);
        this.layerName[layerName] = layer;
        return this.layers.add(layer);
      } else {
        results = [];
        for (k = 0, len = layerName.length; k < len; k++) {
          name = layerName[k];
          layer = new Layer(this.layers.length);
          this.layerMap[name] = layer;
          results.push(this.layers.add(layer));
        }
        return results;
      }
    };

    Layers.prototype.Remove = function(layerName, tryToFill) {
      var cleanedLayers, index, item, k, l, layer, len, ref, results;
      if (!this.layerMap[layerName]) {
        return Torch.FatalError("Unable to remove layer '" + layerName + "'. Layer does not exist");
      } else {
        cleanedLayers = [];
        layer = layerMap[layerName];
        layer.Trash();
        delete this.layerMap[layerName];
        ref = this.layers;
        results = [];
        for (index = k = 0, len = ref.length; k < len; index = ++k) {
          item = ref[index];
          l = cleanedLayers[index];
          if (index !== layer.mapIndex) {
            cleanedLayers.push(l);
            if (tryToFill) {
              results.push(l.DrawIndex(l.DrawIndex() - 1));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    Layers.prototype.Get = function(layerName) {
      if (!this.layerMap[layerName]) {
        return Torch.FatalError("Unable to get layer '" + layerName + "'. Layer does not exist");
      } else {
        return this.layerMap[layerName];
      }
    };

    return Layers;

  })();

  Key = (function() {
    Key.MixIn(EventDispatcher);

    Key.prototype.down = false;

    function Key(keyCode1) {
      this.keyCode = keyCode1;
      this.InitEventDispatch();
    }

    return Key;

  })();

  Keys = (function() {
    Keys.MixIn(EventDispatcher);

    function Keys() {
      this.specialKeys = {
        8: "Delete",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "PauseBreak",
        20: "CapsLock",
        27: "Escape",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "LeftArrow",
        38: "UpArrow",
        39: "RightArrow",
        40: "DownArrow",
        45: "Insert",
        46: "Delete2",
        48: "Num0",
        49: "Num1",
        50: "Num2",
        51: "Num3",
        52: "Num4",
        53: "Num5",
        54: "Num6",
        55: "Num7",
        56: "Num8",
        57: "Num9",
        96: "NumPad0",
        97: "NumPad1",
        98: "NumPad2",
        99: "NumPad3",
        100: "NumPad4",
        101: "NumPad5",
        102: "NumPad6",
        103: "NumPad7",
        104: "NumPad8",
        105: "NumPad9",
        106: "NumPadMultiply",
        107: "NumPadPlus",
        109: "NumPadMinus",
        110: "NumPadPeriod",
        111: "NumPadDivide",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        186: "Colon",
        187: "NumPlus",
        188: "Comma",
        189: "NumMinus",
        190: "Period",
        191: "ForwardSlash",
        192: "Tilda",
        219: "BracketLeft",
        221: "BracketRight",
        220: "BackSlash",
        222: "Quote"
      };
      this.InitKeys();
    }

    Keys.prototype.SpecialKey = function(keyCode) {
      var key, ref, value;
      ref = this.specialKeys;
      for (key in ref) {
        value = ref[key];
        if (keyCode.toString() === key.toString()) {
          return this[value];
        }
      }
      return null;
    };

    Keys.prototype.InitKeys = function() {
      var _char, _keys, i, keyCode, ref, results, value;
      _keys = this;
      i = 0;
      while (i < 230) {
        _char = String.fromCharCode(i).toUpperCase();
        _keys[_char] = new Key(i);
        i++;
      }
      ref = this.specialKeys;
      results = [];
      for (keyCode in ref) {
        value = ref[keyCode];
        results.push(_keys[value] = new Key(keyCode));
      }
      return results;
    };

    return Keys;

  })();

  Tween = (function(superClass) {
    extend(Tween, superClass);

    Tween.MixIn(EventDispatcher);

    Tween.prototype.objectToTween = null;

    Tween.prototype.tweenProperties = null;

    Tween.prototype.originalObjectValues = null;

    Tween.prototype.elapsedTime = 0;

    Tween.prototype.timeTweenShouldTake = 0;

    Tween.prototype.easing = null;

    Tween.prototype.repeat = false;

    Tween.prototype.cycle = false;

    function Tween(game1, objectToTween, tweenProperties1, timeTweenShouldTake1, easing1) {
      var key, ref, value;
      this.game = game1;
      this.objectToTween = objectToTween;
      this.tweenProperties = tweenProperties1;
      this.timeTweenShouldTake = timeTweenShouldTake1;
      this.easing = easing1;
      this.InitEventDispatch();
      this.game.Tweens.tweens.push(this);
      this.game.Add(this);
      this.originalObjectValues = {};
      ref = this.tweenProperties;
      for (key in ref) {
        value = ref[key];
        this.originalObjectValues[key] = this.objectToTween[key];
      }
    }

    Tween.prototype.Update = function() {
      var easedTime, key, normalizedTime, ref, tmp, value;
      normalizedTime = this.elapsedTime / this.timeTweenShouldTake;
      easedTime = this.Ease(normalizedTime);
      ref = this.tweenProperties;
      for (key in ref) {
        value = ref[key];
        this.objectToTween[key] = (this.tweenProperties[key] * easedTime) + (this.originalObjectValues[key] * (1 - easedTime));
      }
      this.elapsedTime += this.game.Loop.updateDelta;
      if (this.elapsedTime >= this.timeTweenShouldTake) {
        this.Emit("Finish", new Torch.Event(this.game, {
          tween: this
        }));
        if (this.cycle) {
          this.elapsedTime = 0;
          tmp = Object.create(this.originalObjectValues);
          this.originalObjectValues = Object.create(this.tweenProperties);
          return this.tweenProperties = tmp;
        } else {
          return this.Trash();
        }
      }
    };

    Tween.prototype.Cycle = function() {
      this.cycle = true;
      return this;
    };

    Tween.prototype.Ease = function(normalizedTime) {
      switch (this.easing) {
        case Torch.Easing.Linear:
          return normalizedTime;
        case Torch.Easing.Square:
          return Math.pow(normalizedTime, 2);
        case Torch.Easing.Cube:
          return Math.pow(normalizedTime, 3);
        case Torch.Easing.InverseSquare:
          return 1 - Math.pow(1 - normalizedTime, 2);
        case Torch.Easing.InverseCube:
          return 1 - Math.pow(1 - normalizedTime, 3);
        case Torch.Easing.Smooth:
          return normalizedTime * normalizedTime * (3 - 2 * normalizedTime);
        case Torch.Easing.SmoothSquare:
          return Math.pow(normalizedTime * normalizedTime * (3 - 2 * normalizedTime), 2);
        case Torch.Easing.SmoothCube:
          return Math.pow(normalizedTime * normalizedTime * (3 - 2 * normalizedTime), 3);
        case Torch.Easing.Sine:
          return Math.sin(normalizedTime * Math.PI / 2);
        case Torch.Easing.InverseSine:
          return 1 - Math.sin((1 - normalizedTime) * Math.PI / 2);
      }
    };

    return Tween;

  })(GameThing);

  TweenSetup = (function() {
    function TweenSetup(game1, object1, timeTweenShouldTake1, easing1) {
      this.game = game1;
      this.object = object1;
      this.timeTweenShouldTake = timeTweenShouldTake1;
      this.easing = easing1;
    }

    TweenSetup.prototype.To = function(tweenProperties) {
      return new Tween(this.game, this.object, tweenProperties, this.timeTweenShouldTake, this.easing);
    };

    TweenSetup.prototype.From = function(setProperties) {
      var key, value;
      for (key in setProperties) {
        value = setProperties[key];
        this.object[key] = value;
      }
      return this;
    };

    return TweenSetup;

  })();

  TweenManager = (function() {
    function TweenManager(game1) {
      this.game = game1;
      this.tweens = [];
    }

    TweenManager.prototype.Tween = function(object, timeTweenShouldTake, easing) {
      if (easing == null) {
        easing = Torch.Easing.Smooth;
      }
      return new TweenSetup(this.game, object, timeTweenShouldTake, easing);
    };

    TweenManager.prototype.All = function(callback) {
      var k, len, ref, results, tween;
      ref = this.game.tweens;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        tween = ref[k];
        results.push(callback(tween));
      }
      return results;
    };

    return TweenManager;

  })();

  ParticleEmitter = (function(superClass) {
    extend(ParticleEmitter, superClass);

    ParticleEmitter.prototype.particle = null;

    ParticleEmitter.prototype.auto = true;

    function ParticleEmitter(game1, x, y, interval1, loop, particle1, config1) {
      this.game = game1;
      this.interval = interval1;
      this.loop = loop;
      this.particle = particle1;
      this.config = config1;
      this.InitSprite(this.game, x, y);
      this.elapsedTime = 0;
      this.hasEmitted = false;
    }

    ParticleEmitter.prototype.Update = function() {
      ParticleEmitter.__super__.Update.call(this);
      if (this.interval !== void 0) {
        if (this.hasEmitted) {
          if (this.loop) {
            return this.UpdateParticleEmitter();
          }
        } else {
          return this.UpdateParticleEmitter();
        }
      }
    };

    ParticleEmitter.prototype.Particle = function(particle) {
      return particle = particle;
    };

    ParticleEmitter.prototype.UpdateParticleEmitter = function() {
      if (!this.auto) {
        return;
      }
      this.elapsedTime += this.game.Loop.updateDelta;
      if (this.elapsedTime >= this.interval) {
        this.EmitParticles();
        this.hasEmitted = true;
        return this.elapsedTime = 0;
      }
    };

    ParticleEmitter.prototype.EmitParticles = function(removeEmitterWhenDone) {
      var i;
      if (removeEmitterWhenDone == null) {
        removeEmitterWhenDone = false;
      }
      i = 0;
      while (i < this.config.spread) {
        i++;
        this.EmitParticle();
      }
      if (removeEmitterWhenDone) {
        return this.Trash();
      }
    };

    ParticleEmitter.prototype.EmitParticle = function() {
      var alphaDecay, angle, p, radius, scale, x, y;
      angle = Util.Math.RandomInRange(this.config.minAngle, this.config.maxAngle);
      scale = Util.Math.RandomInRange(this.config.minScale, this.config.maxScale);
      alphaDecay = Util.Math.RandomInRange(this.config.minAlphaDecay, this.config.maxAlphaDecay);
      radius = Util.Math.RandomInRange(this.config.minRadius, this.config.maxRadius);
      x = this.position.x;
      y = this.position.y;
      if (typeof this.particle !== "string") {
        p = new this.particle(this.game, x, y);
      } else {
        p = this.game.Factory.Sprite(x, y, this.particle);
      }
      p.Body.velocity.x = Math.cos(angle) * Util.Math.RandomInRange(this.config.minVelocity, this.config.maxVelocity);
      p.Body.velocity.y = Math.sin(angle) * Util.Math.RandomInRange(this.config.minVelocity, this.config.maxVelocity);
      p.Body.omega = Util.Math.RandomInRange(this.config.minOmega, this.config.maxOmega);
      p.Size.Scale(scale, scale);
      p.drawIndex = 1000;
      return this.game.Tweens.Tween(p, alphaDecay, Torch.Easing.Smooth).To({
        opacity: 0
      }).On("Finish", function() {
        return p.Trash();
      });
    };

    return ParticleEmitter;

  })(Sprite);

  ParticleManager = (function() {
    function ParticleManager(game1) {
      this.game = game1;
    }

    ParticleManager.prototype.ParticleEmitter = function(x, y, interval, shouldLoop, particle, config) {
      return new ParticleEmitter(this.game, x, y, interval, shouldLoop, particle, config);
    };

    return ParticleManager;

  })();

  Sound = (function() {
    Sound.prototype.volume = 1;

    Sound.prototype.pan = 0;

    function Sound(soundId) {
      this.soundId = soundId;
    }

    return Sound;

  })();

  Audio = (function() {
    Audio.prototype.audioContext = null;

    Audio.prototype.MasterVolume = 1;

    function Audio(game1) {
      this.game = game1;
      this.GetAudioContext();
    }

    Audio.prototype.GetAudioContext = function() {
      var e;
      try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        return this.audioContext = new AudioContext();
      } catch (error1) {
        e = error1;
        return console.warn("Unable to initialize audio...");
      }
    };

    Audio.prototype.DecodeAudioData = function(data, callback) {
      return this.audioContext.decodeAudioData(data, function(buffer) {
        return callback(buffer);
      });
    };

    Audio.prototype.CreateAudioPlayer = function() {
      return new AudioPlayer(this);
    };

    return Audio;

  })();

  AudioPlayer = (function() {
    AudioPlayer.prototype.volume = 1;

    function AudioPlayer(aud) {
      this.audioContext = aud.audioContext;
      this.game = aud.game;
    }

    AudioPlayer.prototype.CreateGain = function(gain) {
      var gainNode;
      if (gain == null) {
        gain = 1;
      }
      gainNode = this.audioContext.createGain();
      gainNode.gain.value = gain;
      return gainNode;
    };

    AudioPlayer.prototype.Play = function(sound) {
      return this.game.FatalError("Cannot play sound. sound must be Torch.Sound");
    };

    AudioPlayer.prototype.PlaySound = function(id, time, filters) {
      var filter, index, k, lastFilter, len, source;
      if (time == null) {
        time = 0;
      }
      if (filters == null) {
        filters = null;
      }
      source = this.audioContext.createBufferSource();
      source.buffer = this.game.Assets.audio[id].audioData;
      if (this.game.Audio.MasterVolume !== 1) {
        if (filters === null) {
          filters = [this.CreateGain(this.game.Audio.MasterVolume)];
        } else {
          filters.push(this.CreateGain(this.game.Audio.MasterVolume));
        }
      }
      if (filters === null) {
        filters = [this.CreateGain(this.volume)];
      } else {
        filters = slice.call(filters).concat([this.CreateGain(this.volume)]);
      }
      lastFilter = null;
      for (index = k = 0, len = filters.length; k < len; index = ++k) {
        filter = filters[index];
        if (lastFilter === null) {
          source.connect(filter);
        } else {
          lastFilter.connect(filter);
        }
        lastFilter = filter;
        if (index === filters.length - 1) {
          filter.connect(this.audioContext.destination);
          source.start(time);
          return;
        }
      }
      source.connect(this.audioContext.destination);
      return source.start(time);
    };

    return AudioPlayer;

  })();

  HookManager = (function() {
    HookManager.prototype.positionTransform = null;

    function HookManager(game1) {
      this.game = game1;
      this.positionTransform = new Point(0, 0);
    }

    return HookManager;

  })();

  GameThingFactory = (function() {
    GameThingFactory.prototype.game = null;

    function GameThingFactory(game1) {
      this.game = game1;
    }

    GameThingFactory.prototype.Sprite = function(x, y, texture) {
      var sprite;
      sprite = new Sprite(this.game, x, y);
      if (texture != null) {
        sprite.Bind.Texture(texture);
      }
      return sprite;
    };

    GameThingFactory.prototype.Group = function(x, y) {
      var group;
      group = new SpriteGroup(this.game, x, y);
      return group;
    };

    GameThingFactory.prototype.Text = function(x, y, config) {
      var text;
      if (config == null) {
        config = {};
      }
      text = new Text(this.game, x, y, config);
      return text;
    };

    GameThingFactory.prototype.Thing = function(update, draw) {
      var thing;
      thing = new GameThing();
      if (update != null) {
        thing.Update = update;
      }
      if (draw != null) {
        thing.Draw = draw;
      }
      this.game.Add(thing);
      return thing;
    };

    GameThingFactory.prototype.Button = function(x, y, textConfig, backgroundConfig) {
      var button, text;
      text = this.Text(x, y, {
        text: textConfig.text || "button",
        color: textConfig.color || "white",
        font: textConfig.font || "monospace",
        fontSize: textConfig.fontSize || 12
      });
      button = this.Sprite(x, y, backgroundConfig.mainBackground);
      text.Grid.Center().CenterVertical();
      button.Grid.Append(text);
      button.On("Trash", function() {
        return text.Trash();
      });
      button.On("MouseDown", function() {
        return button.Bind.Texture(backgroundConfig.mouseDownBackground || backgroundConfig.mainBackground);
      });
      button.On("MouseUp", function() {
        return button.Bind.Texture(backgroundConfig.mainBackground);
      });
      return button;
    };

    return GameThingFactory;

  })();

  GamePad = (function() {
    GamePad.MixIn(EventDispatcher);

    GamePad.prototype.connected = false;

    GamePad.prototype.buttons = null;

    GamePad.prototype.sticks = null;

    function GamePad(game1, index1) {
      this.game = game1;
      this.index = index1;
      this.InitEventDispatch();
      this.buttons = {
        A: new GamePadButton(this, 1),
        B: new GamePadButton(this, 2),
        X: new GamePadButton(this, 3),
        Y: new GamePadButton(this, 4),
        LeftBumper: new GamePadButton(this, 5),
        RightBumper: new GamePadButton(this, 6),
        LeftTrigger: new GamePadButton(this, 7),
        RightTrigger: new GamePadButton(this, 8),
        Back: new GamePadButton(this, 9),
        Start: new GamePadButton(this, 10),
        LeftStick: new GamePadButton(this, 11),
        RightStick: new GamePadButton(this, 12),
        DPadUp: new GamePadButton(this, 13),
        DPadDown: new GamePadButton(this, 14),
        DPadLeft: new GamePadButton(this, 15),
        DPadRight: new GamePadButton(this, 16)
      };
      this.buttonMap = ["A", "B", "X", "Y", "LeftBumper", "RightBumper", "LeftTrigger", 'RightTrigger', "Back", "Start", "LeftStick", "RightStick", "DPadUp", "DPadDown", "DPadLeft", "DPadRight"];
      this.sticks = {
        LeftStick: new GamePadStick(this),
        RightStick: new GamePadStick(this)
      };
    }

    GamePad.prototype.SetState = function(nativeGamePad) {
      var axes, button, index, k, len, nativeButton, ref;
      this.connected = nativeGamePad.connected;
      ref = nativeGamePad.buttons;
      for (index = k = 0, len = ref.length; k < len; index = ++k) {
        nativeButton = ref[index];
        button = this.buttons[this.buttonMap[index]];
        if (button != null) {
          button.SetState(nativeButton);
        }
      }
      axes = nativeGamePad.axes;
      this.sticks.LeftStick.SetState(axes[0], axes[1]);
      return this.sticks.RightStick.SetState(axes[2], axes[3]);
    };

    return GamePad;

  })();

  GamePadManager = (function() {
    GamePadManager.prototype._pads = null;

    function GamePadManager(game1) {
      this.game = game1;
      this._pads = [new GamePad(this.game), new GamePad(this.game), new GamePad(this.game), new GamePad(this.game)];
    }

    GamePadManager.prototype.Pad = function(index) {
      return this._pads[index];
    };

    GamePadManager.prototype.Update = function() {
      var index, k, len, nativeGamePads, pad, results;
      nativeGamePads = navigator.getGamepads();
      results = [];
      for (index = k = 0, len = nativeGamePads.length; k < len; index = ++k) {
        pad = nativeGamePads[index];
        if (pad != null) {
          results.push(this._pads[index].SetState(pad));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return GamePadManager;

  })();

  GamePadButton = (function() {
    GamePadButton.MixIn(EventDispatcher);

    GamePadButton.prototype._wasDown = false;

    GamePadButton.prototype.down = false;

    function GamePadButton(gamePad, buttonCode) {
      this.gamePad = gamePad;
      this.buttonCode = buttonCode;
      this.InitEventDispatch();
      this.game = this.gamePad.game;
    }

    GamePadButton.prototype.SetState = function(nativeGamePadButton) {
      if (this._wasDown && !nativeGamePadButton.pressed) {
        this.Emit("ButtonPressed", new Torch.Event(this.game, {
          button: this
        }));
      }
      this.down = nativeGamePadButton.pressed;
      return this._wasDown = this.down;
    };

    return GamePadButton;

  })();

  GamePadStick = (function() {
    GamePadStick.MixIn(EventDispatcher);

    GamePadStick.prototype.horizontalAxis = 0;

    GamePadStick.prototype.verticalAxis = 0;

    GamePadStick.prototype.EPSILON = 0.1;

    function GamePadStick(gamePad) {
      this.gamePad = gamePad;
    }

    GamePadStick.prototype.SetState = function(horizontalAxis, verticalAxis) {
      if (Math.abs(horizontalAxis) > this.EPSILON) {
        this.horizontalAxis = horizontalAxis;
      } else {
        this.horizontalAxis = 0;
      }
      if (Math.abs(verticalAxis) > this.EPSILON) {
        return this.verticalAxis = verticalAxis;
      } else {
        return this.verticalAxis = 0;
      }
    };

    return GamePadStick;

  })();

  CanvasGame = (function() {
    CanvasGame.prototype.torch_type = "Game";

    function CanvasGame(canvasId, width1, height1, name1, graphicsType, pixel) {
      this.canvasId = canvasId;
      this.width = width1;
      this.height = height1;
      this.name = name1;
      this.graphicsType = graphicsType;
      this.pixel = pixel != null ? pixel : 0;
      this.InitGame();
    }

    CanvasGame.MixIn(EventDispatcher);

    CanvasGame.prototype.InitGame = function() {
      this.InitEventDispatch();
      this.InitGraphics();
      this.InitComponents();
      return this.Style();
    };

    CanvasGame.prototype.InitComponents = function() {
      var graphicsString, styleString;
      styleString = "background-color:" + (Color.Flame.GetHtmlString()) + "; color:" + (Color.Ruby.GetHtmlString()) + "; font-weight: bold; padding:2px; padding-right:5px;padding-left:5px";
      graphicsString = "WebGL";
      if (this.graphicsType === Torch.CANVAS) {
        graphicsString = "Canvas";
      }
      console.log("%c Torch v" + Torch.prototype.version + " |" + graphicsString + "| - " + this.name, styleString);
      this.Loop = new Loop(this);
      this.Assets = new AssetManager(this);
      this.Load = new Load(this);
      this.Mouse = new Mouse(this);
      this.Timer = new Timer(this);
      this.Camera = new Camera(this);
      this.Layers = new Layers(this);
      this.Keys = new Keys(this);
      this.Tweens = new TweenManager(this);
      this.Particles = new ParticleManager(this);
      this.Audio = new Audio(this);
      this.Hooks = new HookManager(this);
      this.Factory = new GameThingFactory(this);
      this.State = new StateMachine(this);
      this.GamePads = new GamePadManager(this);
      this.deltaTime = 0;
      this.fps = 0;
      this.averageFps = 0;
      this.allFPS = 0;
      this.ticks = 0;
      this.zoom = 1;
      this.uidCounter = 0;
      this.paused = false;
      this.boundary = null;
      this.time = null;
      this.LastTimeStamp = null;
      this.things = [];
      this.DrawStack = [];
      this.AddStack = [];
      this.thingMap = {};
      return this.filter = {};
    };

    CanvasGame.prototype.InitGraphics = function() {
      this.canvasNode = document.createElement("CANVAS");
      this.canvasNode.width = window.innerWidth;
      this.canvasNode.height = window.innerHeight;
      document.getElementById(this.canvasId).appendChild(this.canvasNode);
      this.canvas = this.canvasNode.getContext("2d");
      return this.Clear("#cc5200");
    };

    CanvasGame.prototype.PixelScale = function() {
      this.canvas.mozImageSmoothingEnabled = false;
      this.canvas.imageSmoothingEnabled = false;
      return this;
    };

    CanvasGame.prototype.Start = function(configObject) {
      var defaultConfigObject;
      defaultConfigObject = {
        Load: function() {},
        Update: function() {},
        Draw: function() {},
        Init: function() {}
      };
      Util.Object(defaultConfigObject).Extend(configObject);
      this.load = defaultConfigObject.Load;
      this.update = defaultConfigObject.Update;
      this.draw = defaultConfigObject.Draw;
      this.init = defaultConfigObject.Init;
      this.load(this);
      this.Load.Load();
      this.Load.On("LoadFinished", (function(_this) {
        return function() {
          _this.init(_this);
          _this.WireUpEvents();
          return _this.Run();
        };
      })(this));
      this.canvasNode.width = this.width;
      this.canvasNode.height = this.height;
      if (typeof this.width === "string") {
        this.canvasNode.width = document.body.clientWidth;
      }
      if (typeof this.height === "string") {
        return this.canvasNode.height = document.body.clientHeight;
      }
    };

    CanvasGame.prototype.Add = function(o) {
      if (!o.torch_game_thing) {
        throw new ER.ArgumentError();
      }
      this.uidCounter++;
      o.torch_uid = "thing" + this.uidCounter;
      o.torch_add_order = this.uidCounter;
      return this.AddStack.push(o);
    };

    CanvasGame.prototype.GetById = function(id) {
      return this.thingMap[id];
    };

    CanvasGame.prototype.Run = function(timestamp) {
      return this.Loop.Run(0);
    };

    CanvasGame.prototype.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (typeof error === "string") {
        error = new Error(error);
      }
      this.Clear("#000");
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302Cmargin-left:15%font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302Cfont-size:20pxfont-weight:bold'>Stack Trace:</code>\n<br>\n<code style='color:#C9302Cfont-size:20px'>" + stack + "</code>\n<br>\n<code style='color:#C9302Cfont-size:18px'>Time: " + this.time + "</code>";
      document.body.innerHTML = errorHtml;
      this.RunGame = function() {};
      this.Run = function() {};
      this.Emit("FatalError", new Torch.Event(this, {
        error: error
      }));
      throw error;
    };

    CanvasGame.prototype.UpdateThings = function() {
      var filtered, k, len, ref, thing;
      filtered = [];
      ref = this.things;
      for (k = 0, len = ref.length; k < len; k++) {
        thing = ref[k];
        if (!thing.trash) {
          if (!thing.paused) {
            thing.Update();
            filtered.push(thing);
          }
        } else {
          thing.trashed = true;
          if (thing.Emit != null) {
            thing.Emit("Trash", new Torch.Event(this));
          }
        }
      }
      this.things = filtered;
      this.things = this.things.concat(this.AddStack);
      return this.AddStack = [];
    };

    CanvasGame.prototype.DrawThings = function() {
      var k, len, ref, results, sprite;
      this.canvas.clearRect(0, 0, this.Camera.Viewport.maxWidth, this.Camera.Viewport.maxHeight);
      this.things.sort(function(a, b) {
        if (a.drawIndex === b.drawIndex) {
          return a.torch_add_order - b.torch_add_order;
        }
        return a.drawIndex - b.drawIndex;
      });
      ref = this.things;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        sprite = ref[k];
        if (!sprite.trash) {
          results.push(sprite.Draw());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    CanvasGame.prototype.Clear = function(color) {
      if (color === void 0) {
        this.FatalError("Cannot clear undefined color");
      }
      if (typeof color === "object") {
        color = color.hex;
      }
      this.canvasNode.style.backgroundColor = color;
      return this;
    };

    CanvasGame.prototype.SetBoundaries = function(x, y, width, height) {
      return this.boundary = new Rectangle(x, y, width, height);
    };

    CanvasGame.prototype.getCanvasEvents = function() {
      var evts;
      evts = [
        [
          "mousemove", (function(_this) {
            return function(e) {
              _this.Mouse.SetMousePos(_this.canvasNode, e);
              return _this.Emit("MouseMove", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "mousedown", (function(_this) {
            return function(e) {
              _this.Mouse.down = true;
              return _this.Emit("MouseDown", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "mouseup", (function(_this) {
            return function(e) {
              _this.Mouse.down = false;
              return _this.Emit("MouseUp", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "touchstart", (function(_this) {
            return function(e) {
              return _this.Mouse.down = true;
            };
          })(this)
        ], [
          "touchend", (function(_this) {
            return function(e) {
              return _this.Mouse.down = false;
            };
          })(this)
        ], [
          "click", (function(_this) {
            return function(e) {
              e.preventDefault();
              e.stopPropagation();
              _this.Emit("Click", new Torch.Event(_this, {
                nativeEvent: e
              }));
              return false;
            };
          })(this)
        ]
      ];
      return evts;
    };

    CanvasGame.prototype.getBodyEvents = function() {
      var bodyEvents;
      bodyEvents = [
        [
          "keydown", (function(_this) {
            return function(e) {
              var c, key;
              c = e.keyCode;
              key = _this.Keys.SpecialKey(c);
              if (key === null) {
                key = _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()];
              }
              key.down = true;
              return key.Emit("KeyDown", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ], [
          "keyup", (function(_this) {
            return function(e) {
              var c, key;
              c = e.keyCode;
              key = _this.Keys.SpecialKey(c);
              if (key === null) {
                key = _this.Keys[String.fromCharCode(e.keyCode).toUpperCase()];
              }
              key.down = false;
              return key.Emit("KeyUp", new Torch.Event(_this, {
                nativeEvent: e
              }));
            };
          })(this)
        ]
      ];
      return bodyEvents;
    };

    CanvasGame.prototype.WireUpEvents = function() {
      var eventItem, k, len, len1, m, pads, ref, ref1, resize;
      ref = this.getCanvasEvents();
      for (k = 0, len = ref.length; k < len; k++) {
        eventItem = ref[k];
        this.canvasNode.addEventListener(eventItem[0], eventItem[1], false);
      }
      ref1 = this.getBodyEvents();
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        eventItem = ref1[m];
        document.body.addEventListener(eventItem[0], eventItem[1], false);
      }
      resize = (function(_this) {
        return function(event) {
          return _this.Emit("Resize", new Torch.Event(_this, {
            nativeEvent: event
          }));
        };
      })(this);
      window.addEventListener('resize', resize, false);
      return pads = navigator.getGamepads();
    };

    CanvasGame.prototype.TogglePause = function() {
      if (!this.paused) {
        this.paused = true;
      } else {
        this.paused = false;
      }
      return this;
    };

    CanvasGame.prototype.Style = function() {
      var body, canvas;
      body = document.body;
      body.style.backgroundColor = "black";
      body.style.overflow = "hidden";
      body.style.margin = 0;
      canvas = document.getElementsByTagName("CANVAS")[0];
      return canvas.style.cursor = "pointer";
    };

    return CanvasGame;

  })();

  Game = CanvasGame;

  TorchModule(Game, "Game");

  TorchModule(Texture = (function() {
    Texture.prototype.image = null;

    Texture.prototype.drawParams = null;

    Texture.prototype.width = 0;

    Texture.prototype.height = 0;

    function Texture(image1) {
      this.image = image1;
      this.width = this.image.width;
      this.height = this.image.height;
      this.drawParams = new DrawParams(this.width, this.height);
    }

    return Texture;

  })());

  DrawParams = (function() {
    DrawParams.prototype.clipX = 0;

    DrawParams.prototype.clipY = 0;

    DrawParams.prototype.clipWidth = 0;

    DrawParams.prototype.clipHeight = 0;

    function DrawParams(clipWidth, clipHeight) {
      this.clipWidth = clipWidth;
      this.clipHeight = clipHeight;
    }

    return DrawParams;

  })();

  TorchModule(Video = (function() {
    Video.prototype.video = null;

    Video.prototype.drawParams = null;

    Video.prototype.width = 0;

    Video.prototype.height = 0;

    function Video(video1) {
      this.video = video1;
      this.width = this.video.videoWidth;
      this.height = this.video.videoHeight;
      this.drawParams = new DrawParams(this.width, this.height);
    }

    Video.prototype.Play = function() {
      this.video.play();
      return this;
    };

    Video.prototype.Stop = function() {
      this.video.stop();
      return this;
    };

    Video.prototype.Loop = function(turnOn) {
      if (turnOn == null) {
        turnOn = true;
      }
      this.video.loop = turnOn;
      return this;
    };

    return Video;

  })());

  TorchModule(StateMachine = (function() {
    function StateMachine(obj1) {
      this.obj = obj1;
      this.currentState = null;
      this.states = {};
      this.game = this.obj.game;
    }

    StateMachine.prototype.State = function(stateName, stateObj) {
      if (stateObj === void 0) {
        if (this.states[stateName] === void 0) {
          Torch.FatalError("Unable to get state. State '" + stateName + "' has not been added to the state machine");
        }
        return this.states[stateName];
      } else {
        stateObj.stateMachine = this;
        stateObj.game = this.game;
        return this.states[stateName] = stateObj;
      }
    };

    StateMachine.prototype.AddState = function(stateName, stateObj) {
      this.states[stateName] = stateObj;
      stateObj.game = this.game;
      return stateObj.stateMachine = this;
    };

    StateMachine.prototype.Switch = function() {
      var args, newState, ref, ref1;
      newState = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.currentState && this.currentState.End !== void 0) {
        (ref = this.currentState).End.apply(ref, [this.obj].concat(slice.call(args)));
      }
      if (this.State(newState).Start !== void 0) {
        (ref1 = this.State(newState)).Start.apply(ref1, [this.obj].concat(slice.call(args)));
      }
      return this.currentState = this.State(newState);
    };

    StateMachine.prototype.Update = function() {
      if (this.currentState !== null && this.currentState !== void 0) {
        return this.currentState.Execute(this.obj);
      }
    };

    return StateMachine;

  })());

  State = (function() {
    function State(Execute, Start, End) {
      this.Execute = Execute;
      this.Start = Start;
      this.End = End;
    }

    return State;

  })();

  TorchModule(Color = (function() {
    Color.prototype.hex = null;

    Color.prototype.r = null;

    Color.prototype.g = null;

    Color.prototype.b = null;

    function Color(rOrHex, g, b) {
      this.Set(rOrHex, g, b);
    }

    Color.prototype.Set = function(rOrHex, g, b) {
      if (typeof rOrHex === "string") {
        this.hex = rOrHex;
        return this.DecodeHex();
      } else {
        this.r = rOrHex;
        this.g = g;
        this.b = b;
        return this.EncodeHex();
      }
    };

    Color.prototype.DecodeHex = function() {
      var chunks;
      chunks = Util.String(this.hex).Chunk(2);
      this.r = parseInt(chunks[0], 16);
      this.g = parseInt(chunks[1], 16);
      return this.b = parseInt(chunks[2], 16);
    };

    Color.prototype.EncodeHex = function() {
      this.hex = "";
      this.hex += this.r.toString(16);
      this.hex += this.g.toString(16);
      return this.hex += this.b.toString(16);
    };

    Color.prototype.GetHtmlString = function() {
      return "#" + this.hex;
    };

    Color.prototype.Invert = function() {
      return this.Set(Math.floor(Math.abs(255 - this.r)), Math.floor(Math.abs(255 - this.g)), Math.floor(Math.abs(255 - this.b)));
    };

    Color.Random = function() {
      return new Color(Math.floor(Util.Math.RandomInRange(0, 255)), Math.floor(Util.Math.RandomInRange(0, 255)), Math.floor(Util.Math.RandomInRange(0, 255)));
    };

    return Color;

  })());

  Color.Red = new Color(256, 0, 0, 1);

  Color.Green = new Color(0, 256, 0, 1);

  Color.Blue = new Color(0, 0, 256, 1);

  Color.Flame = new Color("ff8000");

  Color.Ruby = new Color("e60000");

  TorchModule(Rectangle = (function() {
    function Rectangle(x1, y1, width1, height1) {
      this.x = x1;
      this.y = y1;
      this.width = width1;
      this.height = height1;
      this.z = 0;
    }

    Rectangle.prototype.GetOffset = function(rectangle) {
      var halfHeights, halfWidths, offset, sharedXPlane, sharedYPlane, vx, vy;
      vx = (this.x + (this.width / 2)) - (rectangle.x + (rectangle.width / 2));
      vy = (this.y + (this.height / 2)) - (rectangle.y + (rectangle.height / 2));
      halfWidths = (this.width / 2) + (rectangle.width / 2);
      halfHeights = (this.height / 2) + (rectangle.height / 2);
      sharedXPlane = (this.x + this.width) - (rectangle.x + rectangle.width);
      sharedYPlane = (this.y + this.height) - (rectangle.y + rectangle.height);
      offset = {
        x: halfWidths - Math.abs(vx),
        y: halfHeights - Math.abs(vy),
        vx: vx,
        vy: vy,
        halfWidths: halfWidths,
        halfHeights: halfHeights,
        sharedXPlane: sharedXPlane,
        sharedYPlane: sharedYPlane
      };
      return offset;
    };

    Rectangle.prototype.Intersects = function(rectangle) {
      var a, b;
      a = this;
      b = rectangle;
      if (a.x < (b.x + b.width) && (a.x + a.width) > b.x && a.y < (b.y + b.height) && (a.y + a.height) > b.y) {
        return a.GetOffset(b);
      } else {
        return false;
      }
    };

    Rectangle.prototype.ShiftFrom = function(rectangle, transX, transY) {
      var x, y;
      x = null;
      y = null;
      if (transX === void 0) {
        x = rectangle.x;
      } else {
        x = rectangle.x + transX;
      }
      if (transY === void 0) {
        y = rectangle.y;
      } else {
        y = rectangle.y + transY;
      }
      this.x = x;
      return this.y = y;
    };

    return Rectangle;

  })());

  TorchModule(Vector = (function() {
    Vector.prototype.x = null;

    Vector.prototype.y = null;

    Vector.prototype.angle = null;

    Vector.prototype.magnitude = null;

    function Vector(x1, y1) {
      this.x = x1;
      this.y = y1;
      this.ResolveVectorProperties();
    }

    Vector.prototype.ResolveVectorProperties = function() {
      this.magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
      return this.angle = Math.atan2(this.y, this.x);
    };

    Vector.prototype.Resolve = function() {
      return this.ResolveVectorProperties();
    };

    Vector.prototype.Clone = function() {
      return new Vector(this.x, this.y);
    };

    Vector.prototype.Set = function(x, y) {
      this.x = x;
      this.y = y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.AddScalar = function(n) {
      this.x += n;
      this.y += n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.MultiplyScalar = function(n) {
      this.x *= n;
      this.y *= n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.DivideScalar = function(n) {
      this.x /= n;
      this.y /= n;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.SubtractVector = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.AddVector = function(v) {
      this.x += v.x;
      this.y += v.y;
      return this.ResolveVectorProperties();
    };

    Vector.prototype.Normalize = function() {
      return this.DivideScalar(this.magnitude);
    };

    Vector.prototype.DotProduct = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Vector.prototype.Reverse = function() {
      return this.MultiplyScalar(-1);
    };

    Vector.prototype.IsPerpendicular = function(v) {
      return this.DotProduct(v) === 0;
    };

    Vector.prototype.IsSameDirection = function(v) {
      return this.DotProduct(v) > 0;
    };

    return Vector;

  })());

  TorchModule(Point = (function() {
    function Point(x1, y1, z) {
      this.x = x1;
      this.y = y1;
      this.z = z != null ? z : 0;
    }

    Point.prototype.Apply = function(point) {
      this.x += point.x;
      return this.y += point.y;
    };

    Point.prototype.Subtract = function(p) {
      return new Point(p.x - this.x, p.y - this.y);
    };

    Point.prototype.Clone = function() {
      return new Point(this.x, this.y);
    };

    Point.GetCenterPoint = function(points) {
      var k, len, maxX, maxY, minX, minY, point;
      maxX = 0;
      maxY = 0;
      minY = 2e308;
      minX = 2e308;
      for (k = 0, len = points.length; k < len; k++) {
        point = points[k];
        if (point.x > maxX) {
          maxX = point.x;
        }
        if (point.y > maxY) {
          maxY = point.y;
        }
        if (point.x < minX) {
          minX = point.x;
        }
        if (point.y < minY) {
          minY = point.y;
        }
      }
      return new Point((maxX - minX) * 0.5, (maxY - minY) * 0.5);
    };

    return Point;

  })());

  exports = this;


  /*
      A few notes to keep in mind:
  
      - CoffeeScript wraps each file into it's own scope when it is compiled into
        javascript. When Torch is built, it puts all the coffeescript into one file
        (torch-latest.coffee) thus throwing all of Torch into the same scope. The only
        piece that is exposed is an instance of Torch called 'Torch'
  
      - There are a few custom objects that are defined in the torch scope a little odly:
         - Util - An instance of Utilities, used internally by Torch, exported as Torch.Util
   */

  Event = (function() {
    function Event(game1, data1) {
      var key, ref, value;
      this.game = game1;
      this.data = data1;
      if (this.game !== null) {
        this.time = this.game.time;
      }
      ref = this.data;
      for (key in ref) {
        value = ref[key];
        this[key] = value;
      }
    }

    return Event;

  })();

  Torch = (function() {
    Torch.prototype.CANVAS = 1;

    Torch.prototype.WEBGL = 2;

    Torch.prototype.PIXEL = 3;

    Torch.prototype.DUMP_ERRORS = false;

    Torch.GamePads = Util.Enum("Pad1", "Pad2", "Pad3", "Pad4");

    Torch.AjaxData = Util.Enum("DOMString", "ArrayBuffer", "Blob", "Document", "Json", "Text");

    Torch.Types = Util.Enum("String", "Number", "Object", "Array", "Function", "Sprite", "Game", "Null");

    Torch.Easing = Util.Enum("Linear", "Square", "Cube", "InverseSquare", "InverseCube", "Smooth", "SmoothSquare", "SmoothCube", "Sine", "InverseSine");

    Torch.AjaxLoader = AjaxLoader;

    Torch.Event = Event;

    Torch.Util = new Utilities();

    function Torch() {
      var k, len, mod;
      this.GamePads = Torch.GamePads;
      this.AjaxData = Torch.AjaxData;
      this.Types = Torch.Types;
      this.Easing = Torch.Easing;
      this.Util = Util;
      for (k = 0, len = TorchModules.length; k < len; k++) {
        mod = TorchModules[k];
        this[mod.name] = mod.mod;
      }
    }

    Torch.FatalError = function(error) {
      var errorHtml, stack;
      if (this.fatal) {
        return;
      }
      this.fatal = true;
      if (Util.Type(error) === "string") {
        error = new Error(error);
      } else if (error.stack == null) {
        error = error.nativeError;
      }
      document.body.backgroundColor = "black";
      if (this.DUMP_ERRORS) {
        if (require !== void 0) {
          require("fs").writeFileSync("torch-error.log", error.stack);
        }
      }
      stack = error.stack.replace(/\n/g, "<br><br>");
      errorHtml = "<code style='color:#C9302C;margin-left:15%;font-size:24px'>" + error + "</code>\n<br>\n<code style='color:#C9302C;font-size:20px;font-weight:bold'>Stack Trace:</code><br>\n<code style='color:#C9302C;font-size:20px'>" + stack + "</code><br>";
      return document.body.innerHTML = errorHtml;
    };

    Torch.prototype.StrictErrors = function() {
      return this.STRICT_ERRORS = true;
    };

    Torch.prototype.DumpErrors = function() {
      return this.DUMP_ERRORS = true;
    };

    return Torch;

  })();

  exports.Torch = new Torch();

  Torch.prototype.version = '0.9.186';

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9yY2gtbGF0ZXN0LmpzIiwic291cmNlUm9vdCI6Ii4uIiwic291cmNlcyI6WyJCdWlsZHNcXHRvcmNoLWxhdGVzdC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQUEsTUFBQSx1L0JBQUE7SUFBQTs7OztFQUFBLEVBQUEsR0FBSzs7RUFFQyxFQUFFLENBQUM7aUJBQ0wsT0FBQSxHQUFTOztpQkFDVCxXQUFBLEdBQWE7O0lBQ0EsWUFBQyxLQUFEO01BQ1QsSUFBWSxLQUFaO1FBQUEsSUFBQyxDQUFBLEtBQUQsQ0FBQSxFQUFBOztNQUNBLElBQUMsQ0FBQSxXQUFELEdBQW1CLElBQUEsS0FBQSxDQUFNLElBQUMsQ0FBQSxPQUFQO0lBRlY7O2lCQUliLEtBQUEsR0FBTyxTQUFBO2FBQ0gsS0FBSyxDQUFDLFVBQU4sQ0FBaUIsSUFBQyxDQUFBLE9BQWxCO0lBREc7O2lCQUdQLFFBQUEsR0FBVSxTQUFBO0FBQ04sYUFBTyxJQUFDLENBQUE7SUFERjs7Ozs7O0VBR1IsRUFBRSxDQUFDOzs7NEJBQ0wsT0FBQSxHQUFTOztJQUNJLHVCQUFDLFFBQUQsRUFBWSxhQUFaLEVBQTRCLGFBQTVCLEVBQTRDLEtBQTVDO0FBQ1QsVUFBQTtNQURVLElBQUMsQ0FBQSxXQUFEO01BQVcsSUFBQyxDQUFBLGdCQUFEO01BQWdCLElBQUMsQ0FBQSxnQkFBRDs7UUFBZ0IsUUFBUTs7TUFDN0QsSUFBQyxDQUFBLE9BQUQsR0FBVyx3QkFBQSxHQUF5QixJQUFDLENBQUEsYUFBMUIsR0FBd0MsR0FBeEMsR0FBMEMsQ0FBQyxJQUFJLENBQUMsSUFBTCxDQUFVLElBQUMsQ0FBQSxhQUFYLENBQUQsQ0FBMUMsR0FBcUUsaUNBQXJFLEdBQXNHLElBQUMsQ0FBQTtNQUVsSCxJQUFHLDBCQUFIO1FBQ0ksSUFBQyxDQUFBLE9BQUQsSUFBWTtBQUNaO0FBQUEsYUFBQSxxREFBQTs7VUFDSSxJQUFtQixLQUFBLEtBQVcsQ0FBOUI7WUFBQSxJQUFDLENBQUEsT0FBRCxJQUFZLElB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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LEdBQ3VELGlKQUR2RCxHQUlpQyxLQUpqQyxHQUl1QzthQUVuRCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQWQsR0FBMEI7SUF2QmpCOztvQkF5QmIsWUFBQSxHQUFjLFNBQUE7YUFDVixJQUFDLENBQUEsYUFBRCxHQUFpQjtJQURQOztvQkFHZCxVQUFBLEdBQVksU0FBQTthQUNSLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFEUDs7Ozs7O0VBR2hCLE9BQU8sQ0FBQyxLQUFSLEdBQW9CLElBQUEsS0FBQSxDQUFBOztFQUdwQixLQUFLLENBQUEsU0FBRSxDQUFBLE9BQVAsR0FBaUI7QUFuck1qQiIsInNvdXJjZXNDb250ZW50IjpbIiMgZXJyb3JzXHJcbkVSID0ge31cclxuXHJcbmNsYXNzIEVSLkVSXHJcbiAgICBtZXNzYWdlOiBudWxsXHJcbiAgICBuYXRpdmVFcnJvcjogbnVsbFxyXG4gICAgY29uc3RydWN0b3I6IChmYXRhbCkgLT5cclxuICAgICAgICBARmF0YWwoKSBpZiBmYXRhbFxyXG4gICAgICAgIEBuYXRpdmVFcnJvciA9IG5ldyBFcnJvcihAbWVzc2FnZSlcclxuXHJcbiAgICBGYXRhbDogLT5cclxuICAgICAgICBUb3JjaC5GYXRhbEVycm9yKEBtZXNzYWdlKVxyXG5cclxuICAgIHRvU3RyaW5nOiAtPlxyXG4gICAgICAgIHJldHVybiBAbWVzc2FnZVxyXG5cclxuY2xhc3MgRVIuQXJndW1lbnRFcnJvciBleHRlbmRzIEVSLkVSXHJcbiAgICBtZXNzYWdlOiBudWxsXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBhcmd1bWVudCwgQHZhbHVlUHJvdmlkZWQsIEBhcmd1bWVudFR5cGVzLCBmYXRhbCA9IGZhbHNlKSAtPlxyXG4gICAgICAgIEBtZXNzYWdlID0gXCJBcmd1bWVudEVycm9yOiB2YWx1ZSAnI3tAdmFsdWVQcm92aWRlZH0oI3tVdGlsLlR5cGUoQHZhbHVlUHJvdmlkZWQpfSknIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IGZvciAje0Bhcmd1bWVudH1cIlxyXG5cclxuICAgICAgICBpZiBAYXJndW1lbnRUeXBlcz9cclxuICAgICAgICAgICAgQG1lc3NhZ2UgKz0gXCIoXCJcclxuICAgICAgICAgICAgZm9yIHQsaW5kZXggaW4gQGFyZ3VtZW50VHlwZXNcclxuICAgICAgICAgICAgICAgIEBtZXNzYWdlICs9IFwiLFwiIGlmIGluZGV4IGlzbnQgMFxyXG4gICAgICAgICAgICAgICAgQG1lc3NhZ2UgKz0gdFxyXG4gICAgICAgICAgICBAbWVzc2FnZSArPSBcIilcIlxyXG5cclxuICAgICAgICBzdXBlcihmYXRhbClcclxuXG5jbGFzcyBBcnJheVV0aWxpdHlcclxuICAgIGNvbnN0cnVjdG9yOiAoQGFycmF5KSAtPlxyXG5cclxuICAgIEFycmF5OiAtPlxyXG4gICAgICAgIHJldHVybiBAYXJyYXlcclxuXHJcbiAgICBBbGw6IChhcHBsaWVyKSAtPlxyXG4gICAgICAgIGZvciBpdGVtIGluIEBhcnJheVxyXG4gICAgICAgICAgICBhcHBsaWVyKGl0ZW0pXHJcblxyXG4gICAgRmluZDogKHNlbGVjdG9yKSAtPlxyXG4gICAgICAgIGZvciBpdGVtIGluIEBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlbSBpZiBzZWxlY3RvcihpdGVtKVxyXG5cclxuICAgIEZpbHRlcjogKHNlbGVjdG9yKSAtPlxyXG4gICAgICAgIHNlbGVjdGVkSXRlbXMgPSBbXVxyXG4gICAgICAgIGZvciBpdGVtIGluIEBhcnJheVxyXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSkgaWYgc2VsZWN0b3IoaXRlbSlcclxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJdGVtc1xyXG5cclxuICAgIFJlamVjdDogKHNlbGVjdG9yKSAtPlxyXG4gICAgICAgIHNlbGVjdGVkSXRlbXMgPSBbXVxyXG4gICAgICAgIGZvciBpdGVtIGluIEBhcnJheVxyXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSkgaWYgbm90IHNlbGVjdG9yKGl0ZW0pXHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkSXRlbXNcclxuXHJcbiAgICBXaGVyZTogKHByb3BlcnRpZXMpIC0+XHJcbiAgICAgICAgaXRlbXMgPSBARmlsdGVyIChpdGVtKSAtPlxyXG4gICAgICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIGlmIGl0ZW1ba2V5XSBpc250IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtc1xyXG5cclxuICAgIEV2ZXJ5OiAoc2VsZWN0b3IpIC0+XHJcbiAgICAgICAgZm9yIGl0ZW0gaW4gQGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBub3Qgc2VsZWN0b3IoaXRlbSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuXHJcbiAgICBTb21lOiAoc2VsZWN0b3IpIC0+XHJcbiAgICAgICAgZm9yIGl0ZW0gaW4gQGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIHNlbGVjdG9yKGl0ZW0pXHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG5cclxuICAgIENvbnRhaW5zOiAoaXRlbSwgc3RhcnRJbmRleCA9IDApIC0+XHJcbiAgICAgICAgaW5kZXggPSBAYXJyYXkuaW5kZXhPZihpdGVtKVxyXG4gICAgICAgIHJldHVybiAoIGluZGV4IGlzbnQgLTEgYW5kIGluZGV4ID49IHN0YXJ0SW5kZXggKVxyXG5cclxuICAgIFBsdWNrOiAocHJvcGVydHlOYW1lKSAtPlxyXG4gICAgICAgIHByb3BlcnRpZXMgPSBbXVxyXG5cclxuICAgICAgICBmb3IgaXRlbSBpbiBAYXJyYXlcclxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKCBpdGVtW3Byb3BlcnR5TmFtZV0gKVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllc1xyXG5cclxuICAgIE1heDogKHNlbGVjdG9yKSAtPlxyXG4gICAgICAgIGN1cnJlbnRNYXggPSAwXHJcbiAgICAgICAgaWYgbm90IHNlbGVjdG9yP1xyXG4gICAgICAgICAgICBzZWxlY3RvciA9IChpdGVtKSAtPiByZXR1cm4gaXRlbVxyXG5cclxuICAgICAgICBmb3IgaXRlbSBpbiBAYXJyYXlcclxuICAgICAgICAgICAgY29tcGFyZVZhbHVlID0gc2VsZWN0b3IoaXRlbSlcclxuICAgICAgICAgICAgaWYgY29tcGFyZVZhbHVlID4gY3VycmVudE1heFxyXG4gICAgICAgICAgICAgICAgY3VycmVudE1heCA9IGl0ZW1cclxuXHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRNYXhcclxuXHJcbiAgICBNaW46IChzZWxlY3RvcikgLT5cclxuICAgICAgICBjdXJyZW50TWluID0gMFxyXG4gICAgICAgIGlmIG5vdCBzZWxlY3Rvcj9cclxuICAgICAgICAgICAgc2VsZWN0b3IgPSAoaXRlbSkgLT4gcmV0dXJuIGl0ZW1cclxuXHJcbiAgICAgICAgZm9yIGl0ZW0gaW4gQGFycmF5XHJcbiAgICAgICAgICAgIGNvbXBhcmVWYWx1ZSA9IHNlbGVjdG9yKGl0ZW0pXHJcbiAgICAgICAgICAgIGlmIGNvbXBhcmVWYWx1ZSA8IGN1cnJlbnRNaW5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNaW4gPSBjb21wYXJlVmFsdWVcclxuXHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRNaW5cclxuXHJcbiAgICBTb3J0Qnk6IChzb3J0ZXIpIC0+XHJcblxyXG4gICAgR3JvdXBCeTogKGdyb3VwZXIpIC0+XHJcbiAgICAgICAgaWYgbm90IGdyb3VwZXI/XHJcbiAgICAgICAgICAgIGdyb3VwZXIgPSAoaXRlbSkgLT4gcmV0dXJuIGl0ZW0udG9TdHJpbmcoKS5sZW5ndGhcclxuXHJcbiAgICAgICAgZ3JvdXBzID0ge31cclxuXHJcbiAgICAgICAgZm9yIGl0ZW0gaW4gQGFycmF5XHJcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBlcihpdGVtKVxyXG5cclxuICAgICAgICAgICAgaWYgbm90IGdyb3Vwc1tncm91cF0/XHJcbiAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gWyBpdGVtIF1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKGl0ZW0pXHJcblxyXG4gICAgICAgIHJldHVybiBncm91cHNcclxuXHJcbiAgICBDb3VudEJ5OiAoZ3JvdXBlcikgLT5cclxuICAgICAgICBncm91cHMgPSBAR3JvdXBCeShncm91cGVyKVxyXG5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIGdyb3Vwc1xyXG4gICAgICAgICAgICBncm91cHNba2V5XSA9IHZhbHVlLmxlbmd0aFxyXG5cclxuICAgICAgICByZXR1cm4gZ3JvdXBzXHJcblxyXG4gICAgU2h1ZmZsZTogLT5cclxuICAgICAgICBjdXJyZW50SW5kZXggPSBAYXJyYXkubGVuZ3RoXHJcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSBjdXJyZW50SW5kZXhcclxuICAgICAgICByYW5kb21JbmRleCA9IGN1cnJlbnRJbmRleFxyXG5cclxuICAgICAgICAjV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cclxuICAgICAgICB3aGlsZSAwIGlzbnQgY3VycmVudEluZGV4XHJcblxyXG4gICAgICAgICAgICAjUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXHJcbiAgICAgICAgICAgIHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KVxyXG4gICAgICAgICAgICBjdXJyZW50SW5kZXggLT0gMVxyXG5cclxuICAgICAgICAgICAgI0FuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSBAYXJyYXlbY3VycmVudEluZGV4XVxyXG4gICAgICAgICAgICBAYXJyYXlbY3VycmVudEluZGV4XSA9IEBhcnJheVtyYW5kb21JbmRleF1cclxuICAgICAgICAgICAgQGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlXHJcblxyXG4gICAgICAgIHJldHVybiBAYXJyYXlcclxuXHJcbiAgICBTYW1wbGU6IChuID0gMSkgLT5cclxuICAgICAgICBzYW1wbGUgPSBbXVxyXG4gICAgICAgIHdoaWxlIG4gPiAwXHJcbiAgICAgICAgICAgIG4tLVxyXG4gICAgICAgICAgICAjIG5lZWRzIHdvcmtcclxuXHJcbiAgICBQYXJ0aXRpb246IChjaGVja2VyKSAtPlxyXG4gICAgICAgIHJldHVybiBbIEBGaWx0ZXIoY2hlY2tlciksIEBSZWplY3QoY2hlY2tlcikgXVxyXG5cclxuICAgIEZpcnN0OiAobiA9IDEpIC0+XHJcbiAgICAgICAgcmV0dXJuIEBhcnJheVswXSBpZiBuIGlzIDFcclxuXHJcbiAgICAgICAgaXRlbXMgPSBbXVxyXG4gICAgICAgIHdoaWxlIG4gPD0gQGFycmF5Lmxlbmd0aFxyXG4gICAgICAgICAgICBpdGVtcy5wdXNoKCBAYXJyYXlbIG4gLSAxIF0gKVxyXG4gICAgICAgICAgICBuKytcclxuXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zXHJcblxyXG4gICAgTGFzdDogKG4gPSAxKSAtPlxyXG4gICAgICAgIHJldHVybiBAYXJyYXlbIEBhcnJheS5sZW5ndGggLSAxIF0gaWYgbiBpcyAxXHJcblxyXG4gICAgICAgIGl0ZW1zID0gW11cclxuICAgICAgICB3aGlsZSBuIDw9IEBhcnJheS5sZW5ndGhcclxuICAgICAgICAgICAgaXRlbXMucHVzaCggQGFycmF5WyBAYXJyYXkubGVuZ3RoIC0gKG4gLSAxKSBdIClcclxuICAgICAgICAgICAgbisrXHJcblxyXG4gICAgICAgIHJldHVybiBpdGVtc1xyXG5cclxuICAgIEZsYXR0ZW46IC0+XHJcbiAgICAgICAgIyByZWR1Y2UgJ2xpc3Qgb2YgbGlzdHMnIGRvd24gdG8gb25lIGxpc3RcclxuXHJcbiAgICBXaXRob3V0OiAodmFsdWVzLi4uKSAtPlxyXG4gICAgICAgIGZpbHRlcmVkSXRlbXMgPSBbXVxyXG5cclxuICAgICAgICBmb3IgaXRlbSBpbiBAYXJyYXlcclxuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKCBpdGVtICkgaWYgdmFsdWVzLmluZGV4T2YoaXRlbSkgaXMgLTFcclxuXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkSXRlbXNcclxuXHJcbiAgICBVbmlvbjogKGFycmF5cy4uLikgLT5cclxuICAgICAgICBhcnMgPSBbQGFycmF5LCBhcnJheXMuLi5dXHJcbiAgICAgICAgY29tYmluZWRBcnJheSA9IFtdXHJcblxyXG4gICAgICAgIGZvciBhciBpbiBhcnNcclxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gYXJcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkQXJyYXkucHVzaChpdGVtKSBpZiBjb21iaW5lZEFycmF5LmluZGV4T2YoaXRlbSkgaXMgLTFcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkQXJyYXlcclxuXHJcbiAgICBJbnRlcnNlY3Rpb246IChhcnJheXMuLi4pIC0+XHJcbiAgICAgICAgYXJzID0gW0BhcnJheSwgYXJyYXlzLi4uXVxyXG4gICAgICAgIGNvbWJpbmVkQXJyYXkgPSBbXVxyXG4gICAgICAgIGluZGV4ID0ge31cclxuXHJcbiAgICAgICAgZm9yIGFyIGluIGFyc1xyXG4gICAgICAgICAgICBmb3IgaXRlbSBpbiBhclxyXG4gICAgICAgICAgICAgICAgaWYgbm90IGluZGV4W2l0ZW1dP1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4W2l0ZW1dID0gMVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4W2l0ZW1dICs9IDFcclxuXHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBpbmRleFxyXG4gICAgICAgICAgICBpZiB2YWx1ZSA+PSBhcnJheXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZEFycmF5LnB1c2goa2V5KVxyXG5cclxuICAgICAgICByZXR1cm4gY29tYmluZWRBcnJheVxyXG5cclxuICAgIFVuaXE6IC0+XHJcbiAgICAgICAgIyByZWR1Y2UgYXJyYXkgdG8gdW5pcXVlIHZhbHVlc1xyXG5cclxuICAgIFppcDogKGFycmF5cy4uLikgLT5cclxuICAgICAgICBjb21iaW5lZEFycmF5ID0gW11cclxuXHJcbiAgICAgICAgZm9yIGl0ZW0saW5kZXggaW4gQGFycmF5XHJcbiAgICAgICAgICAgIHBpZWNlID0gWyBpdGVtIF1cclxuXHJcbiAgICAgICAgICAgIGZvciBhciBpbiBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBpZWNlLnB1c2goIGFyW2luZGV4XSApXHJcblxyXG4gICAgICAgICAgICBjb21iaW5lZEFycmF5LnB1c2gocGllY2UpXHJcblxyXG4gICAgICAgIHJldHVybiBjb21iaW5lZEFycmF5XHJcblxyXG4gICAgVW5aaXA6IChhcnJheXMuLi4pIC0+XHJcbiAgICAgICAgIyBvcHBvc2l0ZSBvZiBaaXAuLi5cclxuXG5jbGFzcyBTdHJpbmdVdGlsaXR5XHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzdHIpIC0+XHJcblxyXG4gICAgU3RyaW5nOiAtPlxyXG4gICAgICAgIHJldHVybiBAc3RyXHJcblxyXG4gICAgQ2h1bms6IChjaHVua0xlbmd0aCkgLT5cclxuICAgICAgICBAc3RyID0gQHN0ci5tYXRjaChuZXcgUmVnRXhwKCcuezEsJyArIGNodW5rTGVuZ3RoICsgJ30nLCAnZycpKTtcclxuICAgICAgICByZXR1cm4gQHN0clxyXG5cclxuICAgIENhcGl0YWxpemU6IC0+XHJcbiAgICAgICAgQHN0clswXSA9IEBzdHJbMF0udG9VcHBlckNhc2UoKVxyXG4gICAgICAgIHJldHVybiBAc3RyXHJcblxuY2xhc3MgRnVuY3Rpb25VdGlsaXR5XHJcbiAgICBjb25zdHJ1Y3RvcjogKEBmdW5jKSAtPlxyXG5cclxuICAgIERlZmVyOiAoYXJncy4uLikgLT5cclxuICAgICAgICBmID0gPT5cclxuICAgICAgICAgICAgQGZ1bmMoYXJncy4uLilcclxuICAgICAgICBzZXRUaW1lb3V0KGYgLCAwKVxyXG5cclxuICAgIE9uY2U6IC0+XHJcbiAgICAgICAgb2xkRnVuYyA9IEBmdW5jXHJcbiAgICAgICAgbmV3RnVuYyA9IChhcmdzLi4uKSAtPlxyXG4gICAgICAgICAgICByZXR1cm4gaWYgdGhpcy5jYWxsZWRcclxuXHJcbiAgICAgICAgICAgIG9sZEZ1bmMoYXJncy4uLilcclxuICAgICAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlXHJcblxyXG4gICAgICAgIHJldHVybiBuZXdGdW5jXHJcblxyXG4gICAgQWZ0ZXI6ICh0aW1lc0JlZm9yZUV4ZWN1dGVkKSAtPlxyXG4gICAgICAgIG9sZEZ1bmMgPSBAZnVuY1xyXG4gICAgICAgIG5ld0Z1bmMgPSAoYXJncy4uLikgLT5cclxuICAgICAgICAgICAgdGhpcy50aW1lc0JlZm9yZUV4ZWN1dGVkICs9IDFcclxuICAgICAgICAgICAgcmV0dXJuIGlmIHRoaXMuY2FsbGVkQ291bnQgPCB0aW1lc0JlZm9yZUV4ZWN1dGVkXHJcblxyXG4gICAgICAgICAgICBvbGRGdW5jKGFyZ3MuLi4pXHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGVkID0gdHJ1ZVxyXG5cclxuICAgICAgICBuZXdGdW5jLnRpbWVzQmVmb3JlRXhlY3V0ZWQgPSAwXHJcblxyXG4gICAgICAgIHJldHVybiBuZXdGdW5jXHJcblxyXG4gICAgQmVmb3JlOiAodGltZXNFeGVjdXRlZCkgLT5cclxuICAgICAgICBvbGRGdW5jID0gQGZ1bmNcclxuICAgICAgICBuZXdGdW5jID0gKGFyZ3MuLi4pIC0+XHJcbiAgICAgICAgICAgIHRoaXMudGltZXNFeGVjdXRlZCArPSAxXHJcbiAgICAgICAgICAgIHJldHVybiBpZiB0aGlzLmNhbGxlZENvdW50ID4gdGltZXNFeGVjdXRlZFxyXG5cclxuICAgICAgICAgICAgb2xkRnVuYyhhcmdzLi4uKVxyXG4gICAgICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWVcclxuXHJcbiAgICAgICAgbmV3RnVuYy50aW1lc0V4ZWN1dGVkID0gMFxyXG5cclxuICAgICAgICByZXR1cm4gbmV3RnVuY1xyXG5cclxuICAgIENvbXBvc2U6IChmdW5jcy4uLikgLT5cclxuICAgICAgICBhbGxGdW5jcyA9IFtAZnVuYywgZnVuY3MuLi5dXHJcblxyXG4gICAgICAgIGkgPSAwXHJcblxyXG4gICAgICAgIG5ld0Z1bmMgPSAtPlxyXG4gICAgICAgICAgICBsYXN0UmV0dXJuID0gdW5kZWZpbmVkXHJcblxyXG4gICAgICAgICAgICB3aGlsZSBpIDwgYWxsRnVuY3MubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBsYXN0UmV0dXJuID0gYWxsRnVuY3NbaV0obGFzdFJldHVybilcclxuICAgICAgICAgICAgICAgIGkrK1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3RnVuY1xyXG5cbmNsYXNzIE9iamVjdFV0aWxpdHlcclxuICAgIGNvbnN0cnVjdG9yOiAoQG9iaikgLT5cclxuXHJcbiAgICBLZXlzOiAtPlxyXG4gICAgICAgIGtleXMgPSBbXVxyXG5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBvYmpcclxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGtleXNcclxuXHJcbiAgICBWYWx1ZXM6IC0+XHJcbiAgICAgICAgdmFsdWVzID0gW11cclxuXHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAb2JqXHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWVzXHJcblxyXG4gICAgQWxsOiAoYXBwbGllcikgLT5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBvYmpcclxuICAgICAgICAgICAgQG9ialtrZXldID0gYXBwbGllcihrZXksdmFsdWUpXHJcblxyXG4gICAgICAgIHJldHVybiBAb2JqXHJcblxyXG4gICAgSW52ZXJ0OiAtPlxyXG4gICAgICAgIG5ld09iaiA9IHt9XHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAb2JqXHJcbiAgICAgICAgICAgIG5ld09ialt2YWx1ZV0gPSBrZXlcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld09ialxyXG5cclxuICAgIEZ1bmN0aW9uczogLT5cclxuICAgICAgICBmdW5jdGlvbkxpc3QgPSBbXVxyXG5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBvYmpcclxuICAgICAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2goIHZhbHVlLm5hbWUgKSBpZiB0eXBlb2YodmFsdWUpIGlzIFwiZnVuY3Rpb25cIlxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb25MaXN0XHJcblxyXG4gICAgRXh0ZW5kOiAob2JqZWN0cy4uLiktPlxyXG4gICAgICAgIGZvciBvYmogaW4gb2JqZWN0c1xyXG5cclxuICAgICAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBvYmpcclxuICAgICAgICAgICAgICAgIEBvYmpba2V5XSA9IHZhbHVlXHJcblxyXG4gICAgICAgIHJldHVybiBAb2JqXHJcblxyXG4gICAgUGljazogKHBpY2tLZXlzLi4uKSAtPlxyXG4gICAgICAgIG5ld09iaiA9IHt9XHJcblxyXG4gICAgICAgIGlmIHR5cGVvZihwaWNrS2V5cykgaXMgXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgIGZvciBrZXksdmFsdWUgb2YgQG9ialxyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZSBpZiBwaWNrS2V5cyhrZXksIHZhbHVlLCBAb2JqKVxyXG5cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciBrZXkgaW4gcGlja0tleXNcclxuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gQG9ialtrZXldXHJcblxyXG4gICAgICAgIHJldHVybiBuZXdPYmpcclxuXHJcbiAgICBPbWl0OiAob21pdEtleXMuLi4pIC0+XHJcbiAgICAgICAgbmV3T2JqID0ge31cclxuXHJcbiAgICAgICAgaWYgdHlwZW9mKG9taXRLZXlzKSBpcyBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAb2JqXHJcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IHZhbHVlIGlmIG5vdCBvbWl0S2V5cyhrZXksIHZhbHVlLCBAb2JqKVxyXG5cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciBrZXksdmFsdWUgb2YgQG9ialxyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBAb2JqW2tleV0gaWYgb21pdEtleXMuaW5kZXhPZihrZXkpIGlzIC0xXHJcblxyXG4gICAgICAgIHJldHVybiBuZXdPYmpcclxuXHJcbiAgICBDbG9uZTogLT5cclxuICAgICAgICAjLi4uIGEgZ29vZCBjbG9uZVxyXG5cclxuICAgIEhhczogKGtleSkgLT5cclxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgbm90IEBvYmpba2V5XT9cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG5cclxuICAgIE1hdGNoZXM6IChvdGhlck9iaikgLT5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIG90aGVyT2JqXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBAb2JqW2tleV0gaXNudCB2YWx1ZVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG5cclxuICAgIEVtcHR5OiAtPlxyXG4gICAgICAgIHJldHVybiBAS2V5cygpLmxlbmd0aCBpcyAwXHJcblxuY2xhc3MgTWF0aFV0aWxpdHlcclxuICAgIGNvbnN0cnVjdG9yOiAtPlxyXG4gICAgICAgIEBSYW5kb21Qb29sID0gUmFuZG9tUG9vbFxyXG5cclxuICAgIFJhbmRvbUluUmFuZ2U6IChtaW4sIG1heCkgLT5cclxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pblxyXG5cclxuICAgIFNpZ246IChuKSAtPlxyXG4gICAgICAgIGlmIG4gPiAwXHJcbiAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgZWxzZSBpZiBuIDwgMFxyXG4gICAgICAgICAgICByZXR1cm4gLTFcclxuXHJcbiAgICAgICAgcmV0dXJuIDBcclxuXHJcbmNsYXNzIFJhbmRvbVBvb2xcclxuICAgIGNob2ljZXM6IG51bGxcclxuICAgIGNvbnN0cnVjdG9yOiAtPlxyXG4gICAgICAgIEBjaG9pY2VzID0gW11cclxuXHJcbiAgICBBZGRDaG9pY2U6IChpdGVtLCBwcm9iYWJpbGl0eSkgLT5cclxuICAgICAgICBpID0gcHJvYmFiaWxpdHlcclxuICAgICAgICB3aGlsZSBpID4gMFxyXG4gICAgICAgICAgICBpLS1cclxuICAgICAgICAgICAgQGNob2ljZXMucHVzaChpdGVtKVxyXG5cclxuICAgIFBpY2s6IC0+XHJcbiAgICAgICAgQGNob2ljZXMgPSBVdGlsLkFycmF5KCBAY2hvaWNlcyApLlNodWZmbGUoKVxyXG4gICAgICAgIHJldHVybiBAY2hvaWNlc1swXVxyXG5cbiMgU3R1ZmYgdXNlZCB0aHJvdWdob3V0IFRvcmNoXHJcblxyXG4jIHRoaXMgaXMgdGhlIGZpcnN0IGZpbGUsIHNvIGFueSBzcGVjaWFsIGNvbnRhaW5lcnMgc2hvdWxkIGJlIGRlY2xhcmVkIGhlcmVcclxuVG9yY2hNb2R1bGVzID0gW10gIyBwdWJsaWMgcGllY2VzIG9mIHRvcmNoLCBpLmUgVG9yY2guU3ByaXRlLCBUb3JjaC5HYW1lXHJcblRvcmNoTW9kdWxlID0gKG1vZCwgb3B0aW9uYWxOYW1lKSAtPlxyXG4gICAgbmFtZSA9IG1vZC5uYW1lXHJcbiAgICBpZiBvcHRpb25hbE5hbWU/XHJcbiAgICAgICAgbmFtZSA9IG9wdGlvbmFsTmFtZVxyXG5cclxuICAgIFRvcmNoTW9kdWxlcy5wdXNoKHtuYW1lOiBuYW1lLCBtb2Q6IG1vZH0pXHJcblxyXG5jbGFzcyBVdGlsaXRpZXNcclxuICAgIGNvbnN0cnVjdG9yOiAtPlxyXG4gICAgICAgIEBNYXRoID0gbmV3IE1hdGhVdGlsaXR5KClcclxuXHJcbiAgICBTdHJpbmc6IChzdHIpIC0+XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdVdGlsaXR5KHN0cilcclxuXHJcbiAgICBBcnJheTogKGFycmF5KSAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlVdGlsaXR5KGFycmF5KVxyXG5cclxuICAgIEZ1bmN0aW9uOiAoZnVuYykgLT5cclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uVXRpbGl0eShmdW5jKVxyXG5cclxuICAgIE9iamVjdDogKG9iaikgLT5cclxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFV0aWxpdHkob2JqKVxyXG5cclxuICAgIFR5cGU6IChvYmopIC0+XHJcbiAgICAgICAgaWYgb2JqP1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvcmNoX3R5cGUgaWYgb2JqLnRvcmNoX3R5cGU/XHJcbiAgICAgICAgICAgIGNsYXNzVG9UeXBlID0ge31cclxuXHJcbiAgICAgICAgICAgIHR5cGVzID0gW1xyXG4gICAgICAgICAgICAgICAgXCJCb29sZWFuXCJcclxuICAgICAgICAgICAgICAgIFwiTnVtYmVyXCJcclxuICAgICAgICAgICAgICAgIFwiU3RyaW5nXCJcclxuICAgICAgICAgICAgICAgIFwiRnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgXCJBcnJheVwiXHJcbiAgICAgICAgICAgICAgICBcIkRhdGVcIlxyXG4gICAgICAgICAgICAgICAgXCJSZWdFeHBcIlxyXG4gICAgICAgICAgICAgICAgXCJVbmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgXCJOdWxsXCJcclxuICAgICAgICAgICAgXVxyXG5cclxuICAgICAgICAgICAgZm9yIG5hbWUgaW4gdHlwZXNcclxuICAgICAgICAgICAgICAgIGNsYXNzVG9UeXBlWyBcIltvYmplY3QgI3tuYW1lfV1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpXHJcblxyXG4gICAgICAgICAgICBzdHJUeXBlID0gT2JqZWN0Ojp0b1N0cmluZy5jYWxsKG9iailcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzVG9UeXBlW3N0clR5cGVdIG9yIFwib2JqZWN0XCJcclxuXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxyXG5cclxuXHJcbiAgICBFbnVtOiAocGFydHMuLi4pIC0+XHJcbiAgICAgICAgb2JqID0ge1xyXG4gICAgICAgICAgICBuYW1lTWFwOiB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBvYmouR2V0U3RyaW5nVmFsdWUgPSAoZW4pIC0+XHJcbiAgICAgICAgICAgIHJldHVybiBAbmFtZU1hcFtlbl1cclxuXHJcbiAgICAgICAgZm9yIHBhcnQsaSBpbiBwYXJ0c1xyXG4gICAgICAgICAgICBvYmpbcGFydF0gPSBpKzFcclxuICAgICAgICAgICAgb2JqLm5hbWVNYXBbaSsxXSA9IHBhcnRcclxuXHJcbiAgICAgICAgcmV0dXJuIG9ialxyXG5cclxuXHJcbiMgZGVmaW5lIGEgbG9jYWwgKHRvIFRvcmNoKSBpbnN0YW5jZSBmb3IgdXNlIGJ5IHRoZSByZXN0XHJcbiMgb2YgdGhlIGxpYnJhcnlcclxuVXRpbCA9IG5ldyBVdGlsaXRpZXMoKVxyXG5cbiMgVE9ET1xyXG4jIHVzZSBFdmVudERpc3BhdGNoZXIgaW5zdGVhZCBvZiBoYXJkLWNvZGVkIGV2ZW50IGxpc3RlbmVyc1xyXG5jbGFzcyBBamF4TG9hZGVyXHJcbiAgICBvbkZpbmlzaDogLT5cclxuICAgIG9uRXJyb3I6IC0+XHJcblxyXG4gICAgY29uc3RydWN0b3I6ICh1cmwsIHJlc3BvbnNlVHlwZSA9IHdpbmRvdy5Ub3JjaC5BamF4RGF0YS5UZXh0KSAtPlxyXG4gICAgICAgIEB1cmwgPSB1cmxcclxuICAgICAgICBAcmVzcG9uc2VUeXBlID0gQEdldFJlc3BvbnNlVHlwZVN0cmluZyhyZXNwb25zZVR5cGUpXHJcblxyXG4gICAgR2V0UmVzcG9uc2VUeXBlU3RyaW5nOiAocmVzcG9uc2VUeXBlKSAtPlxyXG4gICAgICAgIHN3aXRjaCByZXNwb25zZVR5cGVcclxuICAgICAgICAgICAgd2hlbiB3aW5kb3cuVG9yY2guQWpheERhdGEuRE9NU3RyaW5nIHRoZW4gICAgICByZXR1cm4gXCJcIlxyXG4gICAgICAgICAgICB3aGVuIHdpbmRvdy5Ub3JjaC5BamF4RGF0YS5BcnJheUJ1ZmZlciB0aGVuICAgIHJldHVybiBcImFycmF5YnVmZmVyXCJcclxuICAgICAgICAgICAgd2hlbiB3aW5kb3cuVG9yY2guQWpheERhdGEuQmxvYiB0aGVuICAgICAgICAgICByZXR1cm4gXCJibG9iXCJcclxuICAgICAgICAgICAgd2hlbiB3aW5kb3cuVG9yY2guQWpheERhdGEuRG9jdW1lbnQgdGhlbiAgICAgICByZXR1cm4gXCJkb2N1bWVudFwiXHJcbiAgICAgICAgICAgIHdoZW4gd2luZG93LlRvcmNoLkFqYXhEYXRhLkpzb24gdGhlbiAgICAgICAgICAgcmV0dXJuIFwianNvblwiXHJcbiAgICAgICAgICAgIHdoZW4gd2luZG93LlRvcmNoLkFqYXhEYXRhLlRleHQgdGhlbiAgICAgICAgICAgcmV0dXJuIFwidGV4dFwiXHJcblxyXG4gICAgRXJyb3I6IChmdW5jKSAtPiBAb25FcnJvciA9IGZ1bmNcclxuXHJcbiAgICBGaW5pc2g6IChmdW5jKSAtPiBAb25GaW5pc2ggPSBmdW5jXHJcblxyXG4gICAgTG9hZDogLT5cclxuICAgICAgICByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcclxuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIEB1cmwsIHRydWUpXHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBAcmVzcG9uc2VUeXBlXHJcblxyXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gPT5cclxuICAgICAgICAgICAgQG9uRmluaXNoKHJlcXVlc3QucmVzcG9uc2UsIEApXHJcblxyXG4gICAgICAgIHJlcXVlc3Quc2VuZCgpXHJcblxuIyBDYXRjaCBhbGwgZXJyb3JzXHJcbndpbmRvdz8ub25lcnJvciA9IChhcmdzLi4uKSAtPlxyXG4gICAgcmV0dXJuIGlmIG5vdCB3aW5kb3cuVG9yY2guU1RSSUNUX0VSUk9SU1xyXG5cclxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJibGFja1wiXHJcblxyXG4gICAgZXJyb3JPYmogPSBhcmdzWzRdXHJcblxyXG4gICAgaWYgZXJyb3JPYmogaXNudCB1bmRlZmluZWRcclxuICAgICAgICBUb3JjaC5GYXRhbEVycm9yKGVycm9yT2JqKVxyXG4gICAgZWxzZVxyXG4gICAgICAgIFRvcmNoLkZhdGFsRXJyb3IoXCJBbiBlcnJvciBoYXMgb2NjdXJlZFwiKVxyXG5cbiMgTW9kaWZ5IHNvbWUgY29yZSBqcyBwcm90b3R5cGVzXHJcbkZ1bmN0aW9uOjpNaXhJbiA9IEZ1bmN0aW9uOjppcyA9IChvdGhlckZ1bmN0aW9uKSAtPlxyXG4gICAgcHJvdG8gPSB0aGlzLnByb3RvdHlwZVxyXG4gICAgaXRlbXMgPSBPYmplY3QuY3JlYXRlKG90aGVyRnVuY3Rpb24ucHJvdG90eXBlKVxyXG5cclxuICAgIGZvciBrZXksdmFsdWUgb2YgaXRlbXNcclxuICAgICAgICBwcm90b1trZXldID0gdmFsdWVcclxuXHJcbiAgICByZXR1cm4gdGhpcyAjYWxsb3cgY2hhaW5pbmdcclxuXHJcbiMgRUNNQXNjcmlwdCA1IHByb3BlcnR5IGdldC9zZXRcclxuRnVuY3Rpb246OnByb3BlcnR5ID0gKHByb3AsIGRlc2MpIC0+XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgQHByb3RvdHlwZSwgcHJvcCwgZGVzY1xyXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgQGRpc3BhdGNoZXJzOiBbXVxyXG5cclxuICAgIEluaXRFdmVudERpc3BhdGNoOiAtPlxyXG4gICAgICAgIEBldmVudHMgPSB7fVxyXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5kaXNwYXRjaGVycy5wdXNoKEApXHJcblxyXG4gICAgT246IChldmVudE5hbWUsIGV2ZW50SGFuZGxlKSAtPlxyXG4gICAgICAgIGlmIG5vdCBAZXZlbnRzW2V2ZW50TmFtZV1cclxuICAgICAgICAgICAgZXZlbnROZXN0ID0gW11cclxuICAgICAgICAgICAgZXZlbnROZXN0LnRyaWdnZXJzID0gMFxyXG5cclxuICAgICAgICAgICAgQGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnROZXN0XHJcblxyXG4gICAgICAgIEBldmVudHNbZXZlbnROYW1lXS5wdXNoKGV2ZW50SGFuZGxlKVxyXG5cclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuICAgIEVtaXQ6IChldmVudE5hbWUsIGV2ZW50QXJncykgLT5cclxuICAgICAgICBpZiBAZXZlbnRzW2V2ZW50TmFtZV0gaXNudCB1bmRlZmluZWRcclxuICAgICAgICAgICAgZm9yIGV2IGluIEBldmVudHNbZXZlbnROYW1lXVxyXG4gICAgICAgICAgICAgICAgQGV2ZW50c1tldmVudE5hbWVdLnRyaWdnZXJzKytcclxuICAgICAgICAgICAgICAgIGV2KGV2ZW50QXJncylcclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuICAgIE9mZjogKGV2ZW50TmFtZSA9IFwiXCIpIC0+XHJcbiAgICAgICAgaWYgZXZlbnROYW1lIGlzbnQgXCJcIlxyXG4gICAgICAgICAgICBAZXZlbnRzW2V2ZW50TmFtZV0gPSB1bmRlZmluZWRcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGZvciBrZXksdmFsIG9mIEBldmVudHNcclxuICAgICAgICAgICAgICAgIEBldmVudHNba2V5XSA9IHVuZGVmaW5lZFxyXG4gICAgICAgIHJldHVybiBAXHJcblxuY2xhc3MgVHJhc2hhYmxlXHJcbiAgICB0cmFzaDogZmFsc2VcclxuICAgIHRyYXNoZWQ6IGZhbHNlXHJcbiAgICBUcmFzaDogLT5cclxuICAgICAgICBAdHJhc2ggPSB0cnVlXHJcblxuIyB0aGlzIGlzIHRoZSBiYXNlIG9mIGFueXRoaW5nIGluIHRoZSBnYW1lXHJcblxyXG5Ub3JjaE1vZHVsZSBjbGFzcyBHYW1lVGhpbmdcclxuICAgIEBNaXhJbiBUcmFzaGFibGVcclxuXHJcbiAgICB0b3JjaF9nYW1lX3RoaW5nOiB0cnVlXHJcbiAgICB0b3JjaF91aWQ6IG51bGxcclxuICAgIHRvcmNoX2FkZF9vcmRlcjogbnVsbFxyXG4gICAgZ2FtZTogbnVsbFxyXG4gICAgZHJhd0luZGV4OiAwXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG5cclxuICAgIERyYXc6IC0+XHJcblxyXG4gICAgSWQ6IChpZCkgLT5cclxuICAgICAgICBAZ2FtZS50aGluZ01hcFsgaWQgXSA9IEBcclxuXG5Ub3JjaE1vZHVsZSBjbGFzcyBEZWJ1Z0NvbnNvbGVcclxuICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICBjb25zb2xlOiBudWxsXHJcbiAgICBjb25zb2xlSW5wdXQ6IG51bGxcclxuICAgIGNvbnNvbGVPdXRwdXQ6IG51bGxcclxuICAgIGNvbW1hbmRzOiBudWxsXHJcbiAgICB2YXJpYWJsZXM6IG51bGxcclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUpIC0+XHJcbiAgICAgICAgaHRtbCA9IFwiXCJcIlxyXG4gICAgICAgICAgICAgICAgPGRpdiBpZCA9IFwidG9yY2gtY29uc29sZVwiIHN0eWxlID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7ei1pbmRleDogMTAwO3RvcDowO2JvcmRlcjogMXB4IHNvbGlkIG9yYW5nZTtiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAgc3R5bGUgPSBcImNvbG9yOndoaXRlO21hcmdpbi1sZWZ0OjElO2ZvbnQtZmFtaWx5Om1vbm9zcGFjZVwiPlRvcmNoIERldiBDb25zb2xlLiBUeXBlIC9IRUxQIGZvciB1c2FnZTwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZCA9IFwidG9yY2gtY29uc29sZS1pbnB1dFwiIHBsYWNlaG9sZGVyPVwiVG9yY2ggRGV2IENvbnNvbGUsIHR5cGUgL0hFTFAgZm9yIHVzYWdlXCIvIHN0eWxlID0gXCJvdXRsaW5lOiBub25lO2JvcmRlcjogbm9uZTtmb250LWZhbWlseTogbW9ub3NwYWNlO2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztmb250LXNpemU6IDE2cHg7cGFkZGluZzogMyU7d2lkdGg6IDEwMCU7XCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkID0gXCJ0b3JjaC1jb25zb2xlLW91dHB1dFwiIHN0eWxlID0gXCJvdmVyZmxvdzphdXRvO291dGxpbmU6IG5vbmU7Ym9yZGVyOiBub25lO2ZvbnQtZmFtaWx5OiBtb25vc3BhY2U7Y29sb3I6IHdoaXRlO2JhY2tncm91bmQtY29sb3I6IGJsYWNrO2ZvbnQtc2l6ZTogMTRweDtwYWRkaW5nOiAxJTt3aWR0aDogOTglO2hlaWdodDoyNTBweFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgXCJcIlwiXHJcbiAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG5cclxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gaHRtbFxyXG4gICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpXHJcblxyXG4gICAgICAgIEBjb25zb2xlID0gZGl2XHJcbiAgICAgICAgQGNvbnNvbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG9yY2gtY29uc29sZS1pbnB1dFwiKVxyXG4gICAgICAgIEBjb25zb2xlT3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0b3JjaC1jb25zb2xlLW91dHB1dFwiKVxyXG4gICAgICAgIEBjb21tYW5kcyA9IHt9XHJcbiAgICAgICAgQHZhcmlhYmxlcyA9IHt9XHJcblxyXG4gICAgICAgIEBMb2FkRGVmYXVsdENvbW1hbmRzKClcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciBcImtleXByZXNzXCIsIChlKSA9PlxyXG4gICAgICAgICAgICBpZiBlLmtleUNvZGUgaXMgNDdcclxuICAgICAgICAgICAgICAgIEBUb2dnbGUodHJ1ZSlcclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYgZS5rZXlDb2RlIGlzIDEzXHJcbiAgICAgICAgICAgICAgICBAUGFyc2VDb21tYW5kKClcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciBcImtleWRvd25cIiwgKGUpID0+XHJcbiAgICAgICAgICAgIGlmIGUua2V5Q29kZSBpcyAyN1xyXG4gICAgICAgICAgICAgICAgQFRvZ2dsZShmYWxzZSlcclxuXHJcbiAgICBUb2dnbGU6ICh0b2cgPSB0cnVlKSAtPlxyXG5cclxuICAgICAgICBpZiB0b2dcclxuICAgICAgICAgICAgQGNvbnNvbGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxyXG4gICAgICAgICAgICBAY29uc29sZUlucHV0LmZvY3VzKClcclxuICAgICAgICAgICAgQGVuYWJsZWQgPSB0cnVlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBAY29uc29sZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcclxuICAgICAgICAgICAgQGNvbnNvbGVJbnB1dC52YWx1ZSA9IFwiXCJcclxuICAgICAgICAgICAgQGVuYWJsZWQgPSBmYWxzZVxyXG5cclxuICAgIE91dHB1dDogKGNvbnRlbnQsIGNvbG9yID0gXCJ3aGl0ZVwiKSAtPlxyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIilcclxuICAgICAgICBAY29uc29sZU91dHB1dC5pbm5lckhUTUwgKz0gXCI8cCBzdHlsZT0nY29sb3I6b3JhbmdlJz5Ub3JjaERldiQ8L3A+PHAgc3R5bGU9J2NvbG9yOiN7Y29sb3J9Jz4je2NvbnRlbnR9PC9wPlwiXHJcblxyXG4gICAgUGFyc2VDb21tYW5kOiAtPlxyXG4gICAgICAgIHJldHVybiBpZiBub3QgQGVuYWJsZWRcclxuXHJcbiAgICAgICAgY29tbWFuZFRleHQgPSBAY29uc29sZUlucHV0LnZhbHVlXHJcblxyXG4gICAgICAgICMgcHV0IGluIGVudmlyb25tZW50IHZhcnNcclxuICAgICAgICBjb21tYW5kVGV4dCA9IGNvbW1hbmRUZXh0LnJlcGxhY2UgL1xcJCguKj8pXFwkL2csICh0ZXh0KSA9PlxyXG4gICAgICAgICAgICAgY2xpcHBlZFRleHQgPSB0ZXh0LnN1YnN0cmluZygxLHRleHQubGVuZ3RoLTEpXHJcbiAgICAgICAgICAgICByZXR1cm4gQHZhcmlhYmxlc1tjbGlwcGVkVGV4dF1cclxuXHJcbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRUZXh0LnNwbGl0KFwiIFwiKVswXS5zcGxpdChcIi9cIilbMV1cclxuICAgICAgICBhcmdzID0gW11cclxuXHJcbiAgICAgICAgZm9yIG9wdGlvbixpbmRleCBpbiBjb21tYW5kVGV4dC5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgYXJncy5wdXNoKG9wdGlvbikgaWYgaW5kZXggaXNudCAwXHJcblxyXG4gICAgICAgIEBFeGVjdXRlQ29tbWFuZChjb21tYW5kLCBhcmdzKVxyXG5cclxuICAgIEV4ZWN1dGVDb21tYW5kOiAoY29tbWFuZCwgYXJncykgLT5cclxuICAgICAgICBpZiBub3QgQGNvbW1hbmRzW2NvbW1hbmRdXHJcbiAgICAgICAgICAgIEBPdXRwdXQoXCJDb21tYW5kICcje2NvbW1hbmR9JyBkb2VzIG5vdCBleGlzdC5cIiwgXCJyZWRcIilcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBAY29tbWFuZHNbY29tbWFuZF0oIEAsIGFyZ3MuLi4gKVxyXG5cclxuICAgIEFkZENvbW1hbmQ6IChuYW1lLCBjYWxsYmFjaykgLT5cclxuICAgICAgICBAY29tbWFuZHNbbmFtZV0gPSBjYWxsYmFja1xyXG5cclxuICAgIExvYWREZWZhdWx0Q29tbWFuZHM6IC0+XHJcbiAgICAgICAgQEFkZENvbW1hbmQgXCJIRUxQXCIsICh0Q29uc29sZSkgPT5cclxuICAgICAgICAgICAgdENvbnNvbGUuT3V0cHV0IFwiXCJcIlxyXG4gICAgICAgICAgICB0eXBlICcvSEVMUCcgZm9yIGhlbHBcclxuICAgICAgICAgICAgdHlwZSAnL0ZQUycgZm9yIGZyYW1lIHJhdGVcclxuICAgICAgICAgICAgdHlwZSAnL1RJTUUnIGZvciBnYW1lIHRpbWVcclxuICAgICAgICAgICAgdHlwZSAnL0UgW3N0YXRlbWVudF0nIHRvIGV4ZWN1dGUgYSBKYXZhU2NyaXB0IHN0YXRlbWVudFxyXG4gICAgICAgICAgICB0eXBlICcvUlVOIFtwYXRoXSB0byBsb2FkIGFuZCBleGVjdXRlIGEgSmF2YVNjcmlwdCBmaWxlJ1xyXG4gICAgICAgICAgICBcIlwiXCJcclxuICAgICAgICBAQWRkQ29tbWFuZCBcIkNMRUFSXCIsICh0Q29uc29sZSkgPT5cclxuICAgICAgICAgICAgQGNvbnNvbGVPdXRwdXQuaW5uZXJIVE1MID0gXCJcIlxyXG4gICAgICAgIEBBZGRDb21tYW5kIFwiRlBTXCIsICh0Q29uc29sZSkgPT5cclxuICAgICAgICAgICAgdENvbnNvbGUuT3V0cHV0IFwiXCJcIlxyXG4gICAgICAgICAgICBDdXJyZW50IEZQUzogI3tAZ2FtZS5mcHN9XHJcbiAgICAgICAgICAgIEF2ZXJhZ2UgRlBTOiAjezB9XHJcbiAgICAgICAgICAgIFwiXCJcIlxyXG4gICAgICAgIEBBZGRDb21tYW5kIFwiVElNRVwiLCAodENvbnNvbGUpID0+XHJcbiAgICAgICAgICAgIHRDb25zb2xlLk91dHB1dCBcIlwiXCJcclxuICAgICAgICAgICAgVG90YWwgR2FtZSBUaW1lOiAje0BnYW1lLnRpbWV9XHJcbiAgICAgICAgICAgIERlbHRhIFRpbWU6ICN7QGdhbWUuZGVsdGFUaW1lfVxyXG4gICAgICAgICAgICBcIlwiXCJcclxuICAgICAgICBAQWRkQ29tbWFuZCBcIlJVTlwiLCAodENvbnNvbGUsIGZpbGVQYXRoKSA9PlxyXG4gICAgICAgICAgICBsb2FkZXIgPSBuZXcgVG9yY2guQWpheExvYWRlcihmaWxlUGF0aCwgVG9yY2guQWpheERhdGEuVGV4dClcclxuICAgICAgICAgICAgbG9hZGVyLkZpbmlzaCAoZGF0YSkgPT5cclxuICAgICAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICB0Q29uc29sZS5PdXRwdXQoXCJGaWxlIEV4ZWN1dGVkXCIsIFwiZ3JlZW5cIilcclxuICAgICAgICAgICAgICAgIGNhdGNoIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnNvbGUuT3V0cHV0KFwiRmlsZTogJyN7c3RhdGVtZW50fScgY2F1c2VkIGFuIGVycm9yLiAje2Vycm9yfVwiLCBcInJlZFwiKVxyXG5cclxuICAgICAgICAgICAgbG9hZGVyLkxvYWQoKVxyXG5cclxuICAgICAgICBAQWRkQ29tbWFuZCBcIlNFVFwiLCAodENvbnNvbGUsIG5hbWUsIHZhbHVlKSA9PlxyXG4gICAgICAgICAgICBpZiBpc05hTih2YWx1ZSlcclxuICAgICAgICAgICAgICAgIEB2YXJpYWJsZXNbbmFtZV0gPSB2YWx1ZVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBAdmFyaWFibGVzW25hbWVdID0gcGFyc2VGbG9hdCh2YWx1ZSlcclxuXHJcbiAgICAgICAgICAgIEBPdXRwdXQoXCJTZXQgI3tuYW1lfSB0byAje3ZhbHVlfVwiLCBcImdyZWVuXCIpXHJcblxyXG4gICAgICAgIEBBZGRDb21tYW5kIFwiRVwiLCAodENvbnNvbGUsIHN0YXRlbWVudCkgPT5cclxuICAgICAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgICAgICBldmFsKHN0YXRlbWVudClcclxuICAgICAgICAgICAgICAgIHRDb25zb2xlLk91dHB1dChcIlN0YXRtZW50IEV4ZWN1dGVkXCIsIFwiZ3JlZW5cIilcclxuICAgICAgICAgICAgY2F0Y2ggZXJyb3JcclxuICAgICAgICAgICAgICAgIHRDb25zb2xlLk91dHB1dChcIlN0YXRlbWVudDogJyN7c3RhdGVtZW50fScgY2F1c2VkIGFuIGVycm9yLiAje2Vycm9yfVwiLCBcInJlZFwiKVxyXG5cclxuICAgICAgICBAQWRkQ29tbWFuZCBcIkVYUC1TXCIsICh0Q29uc29sZSwgdHlwZSkgPT5cclxuICAgICAgICAgICAganNvbiA9IHtzcHJpdGVzOiBbXX1cclxuICAgICAgICAgICAgZm9yIHRoaW5nIGluIEBnYW1lLnRoaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgdGhpbmcudG9yY2hfdHlwZSBpcyBcIlNwcml0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgaWYgdGhpbmcuZXhwb3J0VmFsdWVzIGlzIGZhbHNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkU3ByaXRlID0ge31cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgdHlwZSBpcyBcImNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNwcml0ZS5jb25zdHJ1Y3RvciA9IHRoaW5nLmNvbnN0cnVjdG9yLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRTcHJpdGUueCA9IHRoaW5nLnBvc2l0aW9uLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRTcHJpdGUueSA9IHRoaW5nLnBvc2l0aW9uLnlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciB2YWwgaW4gdGhpbmcuZXhwb3J0VmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNwcml0ZVsgdmFsIF0gPSB0aGluZ1sgdmFsIF1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAganNvbi5zcHJpdGVzLnB1c2goIGV4cG9ydGVkU3ByaXRlIClcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nIEpTT04uc3RyaW5naWZ5KCBqc29uLCBudWxsLCA0IClcclxuXG50ZW1wID0gbnVsbFxyXG5pZiB0aGlzWyBcIlBGXCIgXSB0aGVuIHRlbXAgPSB0aGlzWyBcIlBGXCIgXVxyXG5gXHJcbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLlBGPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL2hlYXAnKTtcclxuXHJcbn0se1wiLi9saWIvaGVhcFwiOjJ9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XHJcblxyXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XHJcblxyXG5cclxuICAvKlxyXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXHJcbiAgICovXHJcblxyXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBpZiAoeCA8IHkpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKHggPiB5KSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cclxuXHJcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxyXG5cclxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXHJcbiAgb2YgYSB0byBiZSBzZWFyY2hlZC5cclxuICAgKi9cclxuXHJcbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcclxuICAgIHZhciBtaWQ7XHJcbiAgICBpZiAobG8gPT0gbnVsbCkge1xyXG4gICAgICBsbyA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIGlmIChsbyA8IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGhpID09IG51bGwpIHtcclxuICAgICAgaGkgPSBhLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHdoaWxlIChsbyA8IGhpKSB7XHJcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xyXG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XHJcbiAgICAgICAgaGkgPSBtaWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cclxuICAgKi9cclxuXHJcbiAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIGFycmF5LnB1c2goaXRlbSk7XHJcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cclxuICAgKi9cclxuXHJcbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcclxuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xyXG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XHJcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XHJcbiAgICB9XHJcbiAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcclxuICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xyXG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXHJcblxyXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxyXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxyXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcclxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxyXG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cclxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXHJcbiAgICovXHJcblxyXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xyXG4gICAgdmFyIHJldHVybml0ZW07XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcclxuICAgIGFycmF5WzBdID0gaXRlbTtcclxuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XHJcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXHJcbiAgICovXHJcblxyXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xyXG4gICAgdmFyIF9yZWY7XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcclxuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XHJcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxyXG4gICAqL1xyXG5cclxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xyXG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBfcmVzdWx0czEgPSBbXTtcclxuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cclxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcclxuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcclxuICAgIF9yZXN1bHRzID0gW107XHJcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgIGkgPSBfcmVmMVtfaV07XHJcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3Jlc3VsdHM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cclxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cclxuICAgKi9cclxuXHJcbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcclxuICAgIHZhciBwb3M7XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XHJcbiAgICBpZiAocG9zID09PSAtMSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcclxuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cclxuICAgKi9cclxuXHJcbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XHJcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcclxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xyXG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XHJcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xyXG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xyXG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XHJcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcclxuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxyXG4gICAqL1xyXG5cclxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XHJcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xyXG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XHJcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XHJcbiAgICB9XHJcbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XHJcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xyXG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcclxuICAgICAgICBlbGVtID0gX3JlZltfaV07XHJcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xyXG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcclxuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcclxuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xyXG4gICAgX3Jlc3VsdHMgPSBbXTtcclxuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XHJcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3Jlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xyXG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xyXG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XHJcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XHJcbiAgICB9XHJcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcclxuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xyXG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcclxuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcclxuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xyXG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XHJcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xyXG4gIH07XHJcblxyXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcclxuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XHJcbiAgICBpZiAoY21wID09IG51bGwpIHtcclxuICAgICAgY21wID0gZGVmYXVsdENtcDtcclxuICAgIH1cclxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcclxuICAgIHN0YXJ0cG9zID0gcG9zO1xyXG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XHJcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xyXG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XHJcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xyXG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcclxuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xyXG4gICAgICB9XHJcbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XHJcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xyXG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xyXG4gICAgfVxyXG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XHJcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xyXG4gIH07XHJcblxyXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcclxuXHJcbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XHJcblxyXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XHJcblxyXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XHJcblxyXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcclxuXHJcbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xyXG5cclxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcclxuXHJcbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcclxuXHJcbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xyXG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcclxuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGhlYXA7XHJcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xyXG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcclxuICAgICAgcmV0dXJuIGhlYXA7XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcclxuXHJcbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XHJcblxyXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xyXG5cclxuICAgIHJldHVybiBIZWFwO1xyXG5cclxuICB9KSgpO1xyXG5cclxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwgPyBtb2R1bGUuZXhwb3J0cyA6IHZvaWQgMCkge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIZWFwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3aW5kb3cuSGVhcCA9IEhlYXA7XHJcbiAgfVxyXG5cclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHtcclxuICAgIEFsd2F5czogMSxcclxuICAgIE5ldmVyOiAyLFxyXG4gICAgSWZBdE1vc3RPbmVPYnN0YWNsZTogMyxcclxuICAgIE9ubHlXaGVuTm9PYnN0YWNsZXM6IDRcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlhZ29uYWxNb3ZlbWVudDtcclxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBOb2RlID0gX2RlcmVxXygnLi9Ob2RlJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gX2RlcmVxXygnLi9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogVGhlIEdyaWQgY2xhc3MsIHdoaWNoIHNlcnZlcyBhcyB0aGUgZW5jYXBzdWxhdGlvbiBvZiB0aGUgbGF5b3V0IG9mIHRoZSBub2Rlcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5PEFycmF5PChudW1iZXJ8Ym9vbGVhbik+Pn0gd2lkdGhfb3JfbWF0cml4IE51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkLCBvciBtYXRyaXhcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBOdW1iZXIgb2Ygcm93cyBvZiB0aGUgZ3JpZC5cclxuICogQHBhcmFtIHtBcnJheTxBcnJheTwobnVtYmVyfGJvb2xlYW4pPj59IFttYXRyaXhdIC0gQSAwLTEgbWF0cml4XHJcbiAqICAgICByZXByZXNlbnRpbmcgdGhlIHdhbGthYmxlIHN0YXR1cyBvZiB0aGUgbm9kZXMoMCBvciBmYWxzZSBmb3Igd2Fsa2FibGUpLlxyXG4gKiAgICAgSWYgdGhlIG1hdHJpeCBpcyBub3Qgc3VwcGxpZWQsIGFsbCB0aGUgbm9kZXMgd2lsbCBiZSB3YWxrYWJsZS4gICovXHJcbmZ1bmN0aW9uIEdyaWQod2lkdGhfb3JfbWF0cml4LCBoZWlnaHQsIG1hdHJpeCkge1xyXG4gICAgdmFyIHdpZHRoO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2lkdGhfb3JfbWF0cml4ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHdpZHRoID0gd2lkdGhfb3JfbWF0cml4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBoZWlnaHQgPSB3aWR0aF9vcl9tYXRyaXgubGVuZ3RoO1xyXG4gICAgICAgIHdpZHRoID0gd2lkdGhfb3JfbWF0cml4WzBdLmxlbmd0aDtcclxuICAgICAgICBtYXRyaXggPSB3aWR0aF9vcl9tYXRyaXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGdyaWQuXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHJvd3Mgb2YgdGhlIGdyaWQuXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIDJEIGFycmF5IG9mIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm5vZGVzID0gdGhpcy5fYnVpbGROb2Rlcyh3aWR0aCwgaGVpZ2h0LCBtYXRyaXgpO1xyXG59XHJcblxyXG4vKipcclxuICogQnVpbGQgYW5kIHJldHVybiB0aGUgbm9kZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyfGJvb2xlYW4+Pn0gW21hdHJpeF0gLSBBIDAtMSBtYXRyaXggcmVwcmVzZW50aW5nXHJcbiAqICAgICB0aGUgd2Fsa2FibGUgc3RhdHVzIG9mIHRoZSBub2Rlcy5cclxuICogQHNlZSBHcmlkXHJcbiAqL1xyXG5HcmlkLnByb3RvdHlwZS5fYnVpbGROb2RlcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCkge1xyXG4gICAgdmFyIGksIGosXHJcbiAgICAgICAgbm9kZXMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcclxuICAgICAgICBub2Rlc1tpXSA9IG5ldyBBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyArK2opIHtcclxuICAgICAgICAgICAgbm9kZXNbaV1bal0gPSBuZXcgTm9kZShqLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChtYXRyaXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWF0cml4Lmxlbmd0aCAhPT0gaGVpZ2h0IHx8IG1hdHJpeFswXS5sZW5ndGggIT09IHdpZHRoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggc2l6ZSBkb2VzIG5vdCBmaXQnKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xyXG4gICAgICAgICAgICBpZiAobWF0cml4W2ldW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAwLCBmYWxzZSwgbnVsbCB3aWxsIGJlIHdhbGthYmxlXHJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBvdGhlcnMgd2lsbCBiZSB1bi13YWxrYWJsZVxyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV1bal0ud2Fsa2FibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9kZXM7XHJcbn07XHJcblxyXG5cclxuR3JpZC5wcm90b3R5cGUuZ2V0Tm9kZUF0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZXNbeV1beF07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyB3YWxrYWJsZS5cclxuICogKEFsc28gcmV0dXJucyBmYWxzZSBpZiB0aGUgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgZ3JpZC4pXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSB3YWxrYWJpbGl0eSBvZiB0aGUgbm9kZS5cclxuICovXHJcbkdyaWQucHJvdG90eXBlLmlzV2Fsa2FibGVBdCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmlzSW5zaWRlKHgsIHkpICYmIHRoaXMubm9kZXNbeV1beF0ud2Fsa2FibGU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhlIGdyaWQuXHJcbiAqIFhYWDogZ3JpZC5pc0luc2lkZSh4LCB5KSBpcyB3aWVyZCB0byByZWFkLlxyXG4gKiBJdCBzaG91bGQgYmUgKHgsIHkpIGlzIGluc2lkZSBncmlkLCBidXQgSSBmYWlsZWQgdG8gZmluZCBhIGJldHRlclxyXG4gKiBuYW1lIGZvciB0aGlzIG1ldGhvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbkdyaWQucHJvdG90eXBlLmlzSW5zaWRlID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuICh4ID49IDAgJiYgeCA8IHRoaXMud2lkdGgpICYmICh5ID49IDAgJiYgeSA8IHRoaXMuaGVpZ2h0KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0IHdoZXRoZXIgdGhlIG5vZGUgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHdhbGthYmxlLlxyXG4gKiBOT1RFOiB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZSBjb29yZGluYXRlIGlzIG5vdCBpbnNpZGUgdGhlIGdyaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHdhbGthYmxlIC0gV2hldGhlciB0aGUgcG9zaXRpb24gaXMgd2Fsa2FibGUuXHJcbiAqL1xyXG5HcmlkLnByb3RvdHlwZS5zZXRXYWxrYWJsZUF0ID0gZnVuY3Rpb24oeCwgeSwgd2Fsa2FibGUpIHtcclxuICAgIHRoaXMubm9kZXNbeV1beF0ud2Fsa2FibGUgPSB3YWxrYWJsZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IHRoZSBuZWlnaGJvcnMgb2YgdGhlIGdpdmVuIG5vZGUuXHJcbiAqXHJcbiAqICAgICBvZmZzZXRzICAgICAgZGlhZ29uYWxPZmZzZXRzOlxyXG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXHJcbiAqICB8ICAgfCAwIHwgICB8ICAgIHwgMCB8ICAgfCAxIHxcclxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgfCAzIHwgICB8IDEgfCAgICB8ICAgfCAgIHwgICB8XHJcbiAqICArLS0tKy0tLSstLS0rICAgICstLS0rLS0tKy0tLStcclxuICogIHwgICB8IDIgfCAgIHwgICAgfCAzIHwgICB8IDIgfFxyXG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXHJcbiAqXHJcbiAqICBXaGVuIGFsbG93RGlhZ29uYWwgaXMgdHJ1ZSwgaWYgb2Zmc2V0c1tpXSBpcyB2YWxpZCwgdGhlblxyXG4gKiAgZGlhZ29uYWxPZmZzZXRzW2ldIGFuZFxyXG4gKiAgZGlhZ29uYWxPZmZzZXRzWyhpICsgMSkgJSA0XSBpcyB2YWxpZC5cclxuICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gZGlhZ29uYWxNb3ZlbWVudFxyXG4gKi9cclxuR3JpZC5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSwgZGlhZ29uYWxNb3ZlbWVudCkge1xyXG4gICAgdmFyIHggPSBub2RlLngsXHJcbiAgICAgICAgeSA9IG5vZGUueSxcclxuICAgICAgICBuZWlnaGJvcnMgPSBbXSxcclxuICAgICAgICBzMCA9IGZhbHNlLCBkMCA9IGZhbHNlLFxyXG4gICAgICAgIHMxID0gZmFsc2UsIGQxID0gZmFsc2UsXHJcbiAgICAgICAgczIgPSBmYWxzZSwgZDIgPSBmYWxzZSxcclxuICAgICAgICBzMyA9IGZhbHNlLCBkMyA9IGZhbHNlLFxyXG4gICAgICAgIG5vZGVzID0gdGhpcy5ub2RlcztcclxuXHJcbiAgICAvLyDihpFcclxuICAgIGlmICh0aGlzLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpIHtcclxuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5IC0gMV1beF0pO1xyXG4gICAgICAgIHMwID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIOKGklxyXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3ldW3ggKyAxXSk7XHJcbiAgICAgICAgczEgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8g4oaTXHJcbiAgICBpZiAodGhpcy5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSArIDFdW3hdKTtcclxuICAgICAgICBzMiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyDihpBcclxuICAgIGlmICh0aGlzLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpIHtcclxuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5XVt4IC0gMV0pO1xyXG4gICAgICAgIHMzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xyXG4gICAgICAgIHJldHVybiBuZWlnaGJvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcykge1xyXG4gICAgICAgIGQwID0gczMgJiYgczA7XHJcbiAgICAgICAgZDEgPSBzMCAmJiBzMTtcclxuICAgICAgICBkMiA9IHMxICYmIHMyO1xyXG4gICAgICAgIGQzID0gczIgJiYgczM7XHJcbiAgICB9IGVsc2UgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZSkge1xyXG4gICAgICAgIGQwID0gczMgfHwgczA7XHJcbiAgICAgICAgZDEgPSBzMCB8fCBzMTtcclxuICAgICAgICBkMiA9IHMxIHx8IHMyO1xyXG4gICAgICAgIGQzID0gczIgfHwgczM7XHJcbiAgICB9IGVsc2UgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKSB7XHJcbiAgICAgICAgZDAgPSB0cnVlO1xyXG4gICAgICAgIGQxID0gdHJ1ZTtcclxuICAgICAgICBkMiA9IHRydWU7XHJcbiAgICAgICAgZDMgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCB2YWx1ZSBvZiBkaWFnb25hbE1vdmVtZW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g4oaWXHJcbiAgICBpZiAoZDAgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCAtIDEsIHkgLSAxKSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgLSAxXVt4IC0gMV0pO1xyXG4gICAgfVxyXG4gICAgLy8g4oaXXHJcbiAgICBpZiAoZDEgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCArIDEsIHkgLSAxKSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgLSAxXVt4ICsgMV0pO1xyXG4gICAgfVxyXG4gICAgLy8g4oaYXHJcbiAgICBpZiAoZDIgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCArIDEsIHkgKyAxKSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgKyAxXVt4ICsgMV0pO1xyXG4gICAgfVxyXG4gICAgLy8g4oaZXHJcbiAgICBpZiAoZDMgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyAxKSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgKyAxXVt4IC0gMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZWlnaGJvcnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGNsb25lIG9mIHRoaXMgZ3JpZC5cclxuICogQHJldHVybiB7R3JpZH0gQ2xvbmVkIGdyaWQuXHJcbiAqL1xyXG5HcmlkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGksIGosXHJcblxyXG4gICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCxcclxuICAgICAgICB0aGlzTm9kZXMgPSB0aGlzLm5vZGVzLFxyXG5cclxuICAgICAgICBuZXdHcmlkID0gbmV3IEdyaWQod2lkdGgsIGhlaWdodCksXHJcbiAgICAgICAgbmV3Tm9kZXMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcclxuICAgICAgICBuZXdOb2Rlc1tpXSA9IG5ldyBBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyArK2opIHtcclxuICAgICAgICAgICAgbmV3Tm9kZXNbaV1bal0gPSBuZXcgTm9kZShqLCBpLCB0aGlzTm9kZXNbaV1bal0ud2Fsa2FibGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZXdHcmlkLm5vZGVzID0gbmV3Tm9kZXM7XHJcblxyXG4gICAgcmV0dXJuIG5ld0dyaWQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XHJcblxyXG59LHtcIi4vRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuL05vZGVcIjo2fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFBGLkhldXJpc3RpY1xyXG4gKiBAZGVzY3JpcHRpb24gQSBjb2xsZWN0aW9uIG9mIGhldXJpc3RpYyBmdW5jdGlvbnMuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFuaGF0dGFuIGRpc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBkeCArIGR5XHJcbiAgICovXHJcbiAgbWFuaGF0dGFuOiBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgcmV0dXJuIGR4ICsgZHk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRXVjbGlkZWFuIGRpc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxyXG4gICAqL1xyXG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIE9jdGlsZSBkaXN0YW5jZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBEaWZmZXJlbmNlIGluIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gRGlmZmVyZW5jZSBpbiB5LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgZm9yIGdyaWRzXHJcbiAgICovXHJcbiAgb2N0aWxlOiBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgdmFyIEYgPSBNYXRoLlNRUlQyIC0gMTtcclxuICAgICAgcmV0dXJuIChkeCA8IGR5KSA/IEYgKiBkeCArIGR5IDogRiAqIGR5ICsgZHg7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlYnlzaGV2IGRpc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBtYXgoZHgsIGR5KVxyXG4gICAqL1xyXG4gIGNoZWJ5c2hldjogZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heChkeCwgZHkpO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG59LHt9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIEEgbm9kZSBpbiBncmlkLlxyXG4gKiBUaGlzIGNsYXNzIGhvbGRzIHNvbWUgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBub2RlIGFuZCBjdXN0b21cclxuICogYXR0cmlidXRlcyBtYXkgYmUgYWRkZWQsIGRlcGVuZGluZyBvbiB0aGUgYWxnb3JpdGhtcycgbmVlZHMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgb24gdGhlIGdyaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cclxuICogQHBhcmFtIHtib29sZWFufSBbd2Fsa2FibGVdIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgd2Fsa2FibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBOb2RlKHgsIHksIHdhbGthYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgb24gdGhlIGdyaWQuXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgbm9kZSBjYW4gYmUgd2Fsa2VkIHRocm91Z2guXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2Fsa2FibGUgPSAod2Fsa2FibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB3YWxrYWJsZSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcclxuXHJcbn0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogQmFja3RyYWNlIGFjY29yZGluZyB0byB0aGUgcGFyZW50IHJlY29yZHMgYW5kIHJldHVybiB0aGUgcGF0aC5cclxuICogKGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZCBlbmQgbm9kZXMpXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBFbmQgbm9kZVxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gdGhlIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGJhY2t0cmFjZShub2RlKSB7XHJcbiAgICB2YXIgcGF0aCA9IFtbbm9kZS54LCBub2RlLnldXTtcclxuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgICBwYXRoLnB1c2goW25vZGUueCwgbm9kZS55XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XHJcbn1cclxuZXhwb3J0cy5iYWNrdHJhY2UgPSBiYWNrdHJhY2U7XHJcblxyXG4vKipcclxuICogQmFja3RyYWNlIGZyb20gc3RhcnQgYW5kIGVuZCBub2RlLCBhbmQgcmV0dXJuIHRoZSBwYXRoLlxyXG4gKiAoaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBub2RlcylcclxuICogQHBhcmFtIHtOb2RlfVxyXG4gKiBAcGFyYW0ge05vZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBiaUJhY2t0cmFjZShub2RlQSwgbm9kZUIpIHtcclxuICAgIHZhciBwYXRoQSA9IGJhY2t0cmFjZShub2RlQSksXHJcbiAgICAgICAgcGF0aEIgPSBiYWNrdHJhY2Uobm9kZUIpO1xyXG4gICAgcmV0dXJuIHBhdGhBLmNvbmNhdChwYXRoQi5yZXZlcnNlKCkpO1xyXG59XHJcbmV4cG9ydHMuYmlCYWNrdHJhY2UgPSBiaUJhY2t0cmFjZTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHBhdGguXHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoTGVuZ3RoKHBhdGgpIHtcclxuICAgIHZhciBpLCBzdW0gPSAwLCBhLCBiLCBkeCwgZHk7XHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGEgPSBwYXRoW2kgLSAxXTtcclxuICAgICAgICBiID0gcGF0aFtpXTtcclxuICAgICAgICBkeCA9IGFbMF0gLSBiWzBdO1xyXG4gICAgICAgIGR5ID0gYVsxXSAtIGJbMV07XHJcbiAgICAgICAgc3VtICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VtO1xyXG59XHJcbmV4cG9ydHMucGF0aExlbmd0aCA9IHBhdGhMZW5ndGg7XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLCByZXR1cm4gYWxsIHRoZSBjb29yZGluYXRlcyBseWluZ1xyXG4gKiBvbiB0aGUgbGluZSBmb3JtZWQgYnkgdGhlc2UgY29vcmRpbmF0ZXMsIGJhc2VkIG9uIEJyZXNlbmhhbSdzIGFsZ29yaXRobS5cclxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVzZW5oYW0nc19saW5lX2FsZ29yaXRobSNTaW1wbGlmaWNhdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0geDAgU3RhcnQgeCBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCBTdGFydCB5IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHgxIEVuZCB4IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHkxIEVuZCB5IGNvb3JkaW5hdGVcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBjb29yZGluYXRlcyBvbiB0aGUgbGluZVxyXG4gKi9cclxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeDAsIHkwLCB4MSwgeTEpIHtcclxuICAgIHZhciBhYnMgPSBNYXRoLmFicyxcclxuICAgICAgICBsaW5lID0gW10sXHJcbiAgICAgICAgc3gsIHN5LCBkeCwgZHksIGVyciwgZTI7XHJcblxyXG4gICAgZHggPSBhYnMoeDEgLSB4MCk7XHJcbiAgICBkeSA9IGFicyh5MSAtIHkwKTtcclxuXHJcbiAgICBzeCA9ICh4MCA8IHgxKSA/IDEgOiAtMTtcclxuICAgIHN5ID0gKHkwIDwgeTEpID8gMSA6IC0xO1xyXG5cclxuICAgIGVyciA9IGR4IC0gZHk7XHJcblxyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBsaW5lLnB1c2goW3gwLCB5MF0pO1xyXG5cclxuICAgICAgICBpZiAoeDAgPT09IHgxICYmIHkwID09PSB5MSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUyID0gMiAqIGVycjtcclxuICAgICAgICBpZiAoZTIgPiAtZHkpIHtcclxuICAgICAgICAgICAgZXJyID0gZXJyIC0gZHk7XHJcbiAgICAgICAgICAgIHgwID0geDAgKyBzeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUyIDwgZHgpIHtcclxuICAgICAgICAgICAgZXJyID0gZXJyICsgZHg7XHJcbiAgICAgICAgICAgIHkwID0geTAgKyBzeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxpbmU7XHJcbn1cclxuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIGNvbXByZXNzZWQgcGF0aCwgcmV0dXJuIGEgbmV3IHBhdGggdGhhdCBoYXMgYWxsIHRoZSBzZWdtZW50c1xyXG4gKiBpbiBpdCBpbnRlcnBvbGF0ZWQuXHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGV4cGFuZGVkIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGV4cGFuZFBhdGgocGF0aCkge1xyXG4gICAgdmFyIGV4cGFuZGVkID0gW10sXHJcbiAgICAgICAgbGVuID0gcGF0aC5sZW5ndGgsXHJcbiAgICAgICAgY29vcmQwLCBjb29yZDEsXHJcbiAgICAgICAgaW50ZXJwb2xhdGVkLFxyXG4gICAgICAgIGludGVycG9sYXRlZExlbixcclxuICAgICAgICBpLCBqO1xyXG5cclxuICAgIGlmIChsZW4gPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcclxuICAgICAgICBjb29yZDAgPSBwYXRoW2ldO1xyXG4gICAgICAgIGNvb3JkMSA9IHBhdGhbaSArIDFdO1xyXG5cclxuICAgICAgICBpbnRlcnBvbGF0ZWQgPSBpbnRlcnBvbGF0ZShjb29yZDBbMF0sIGNvb3JkMFsxXSwgY29vcmQxWzBdLCBjb29yZDFbMV0pO1xyXG4gICAgICAgIGludGVycG9sYXRlZExlbiA9IGludGVycG9sYXRlZC5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGludGVycG9sYXRlZExlbiAtIDE7ICsraikge1xyXG4gICAgICAgICAgICBleHBhbmRlZC5wdXNoKGludGVycG9sYXRlZFtqXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhwYW5kZWQucHVzaChwYXRoW2xlbiAtIDFdKTtcclxuXHJcbiAgICByZXR1cm4gZXhwYW5kZWQ7XHJcbn1cclxuZXhwb3J0cy5leHBhbmRQYXRoID0gZXhwYW5kUGF0aDtcclxuXHJcblxyXG4vKipcclxuICogU21vb3RoZW4gdGhlIGdpdmUgcGF0aC5cclxuICogVGhlIG9yaWdpbmFsIHBhdGggd2lsbCBub3QgYmUgbW9kaWZpZWQ7IGEgbmV3IHBhdGggd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHBhcmFtIHtQRi5HcmlkfSBncmlkXHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHNtb290aGVuUGF0aChncmlkLCBwYXRoKSB7XHJcbiAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGgsXHJcbiAgICAgICAgeDAgPSBwYXRoWzBdWzBdLCAgICAgICAgLy8gcGF0aCBzdGFydCB4XHJcbiAgICAgICAgeTAgPSBwYXRoWzBdWzFdLCAgICAgICAgLy8gcGF0aCBzdGFydCB5XHJcbiAgICAgICAgeDEgPSBwYXRoW2xlbiAtIDFdWzBdLCAgLy8gcGF0aCBlbmQgeFxyXG4gICAgICAgIHkxID0gcGF0aFtsZW4gLSAxXVsxXSwgIC8vIHBhdGggZW5kIHlcclxuICAgICAgICBzeCwgc3ksICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHN0YXJ0IGNvb3JkaW5hdGVcclxuICAgICAgICBleCwgZXksICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGVuZCBjb29yZGluYXRlXHJcbiAgICAgICAgbmV3UGF0aCxcclxuICAgICAgICBpLCBqLCBjb29yZCwgbGluZSwgdGVzdENvb3JkLCBibG9ja2VkO1xyXG5cclxuICAgIHN4ID0geDA7XHJcbiAgICBzeSA9IHkwO1xyXG4gICAgbmV3UGF0aCA9IFtbc3gsIHN5XV07XHJcblxyXG4gICAgZm9yIChpID0gMjsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgY29vcmQgPSBwYXRoW2ldO1xyXG4gICAgICAgIGV4ID0gY29vcmRbMF07XHJcbiAgICAgICAgZXkgPSBjb29yZFsxXTtcclxuICAgICAgICBsaW5lID0gaW50ZXJwb2xhdGUoc3gsIHN5LCBleCwgZXkpO1xyXG5cclxuICAgICAgICBibG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGxpbmUubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgdGVzdENvb3JkID0gbGluZVtqXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQodGVzdENvb3JkWzBdLCB0ZXN0Q29vcmRbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChibG9ja2VkKSB7XHJcbiAgICAgICAgICAgIGxhc3RWYWxpZENvb3JkID0gcGF0aFtpIC0gMV07XHJcbiAgICAgICAgICAgIG5ld1BhdGgucHVzaChsYXN0VmFsaWRDb29yZCk7XHJcbiAgICAgICAgICAgIHN4ID0gbGFzdFZhbGlkQ29vcmRbMF07XHJcbiAgICAgICAgICAgIHN5ID0gbGFzdFZhbGlkQ29vcmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV3UGF0aC5wdXNoKFt4MSwgeTFdKTtcclxuXHJcbiAgICByZXR1cm4gbmV3UGF0aDtcclxufVxyXG5leHBvcnRzLnNtb290aGVuUGF0aCA9IHNtb290aGVuUGF0aDtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHJlc3MgYSBwYXRoLCByZW1vdmUgcmVkdW5kYW50IG5vZGVzIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHNoYXBlXHJcbiAqIFRoZSBvcmlnaW5hbCBwYXRoIGlzIG5vdCBtb2RpZmllZFxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgY29tcHJlc3NlZCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wcmVzc1BhdGgocGF0aCkge1xyXG5cclxuICAgIC8vIG5vdGhpbmcgdG8gY29tcHJlc3NcclxuICAgIGlmKHBhdGgubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21wcmVzc2VkID0gW10sXHJcbiAgICAgICAgc3ggPSBwYXRoWzBdWzBdLCAvLyBzdGFydCB4XHJcbiAgICAgICAgc3kgPSBwYXRoWzBdWzFdLCAvLyBzdGFydCB5XHJcbiAgICAgICAgcHggPSBwYXRoWzFdWzBdLCAvLyBzZWNvbmQgcG9pbnQgeFxyXG4gICAgICAgIHB5ID0gcGF0aFsxXVsxXSwgLy8gc2Vjb25kIHBvaW50IHlcclxuICAgICAgICBkeCA9IHB4IC0gc3gsIC8vIGRpcmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXHJcbiAgICAgICAgZHkgPSBweSAtIHN5LCAvLyBkaXJlY3Rpb24gYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xyXG4gICAgICAgIGx4LCBseSxcclxuICAgICAgICBsZHgsIGxkeSxcclxuICAgICAgICBzcSwgaTtcclxuXHJcbiAgICAvLyBub3JtYWxpemUgdGhlIGRpcmVjdGlvblxyXG4gICAgc3EgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XHJcbiAgICBkeCAvPSBzcTtcclxuICAgIGR5IC89IHNxO1xyXG5cclxuICAgIC8vIHN0YXJ0IHRoZSBuZXcgcGF0aFxyXG4gICAgY29tcHJlc3NlZC5wdXNoKFtzeCxzeV0pO1xyXG5cclxuICAgIGZvcihpID0gMjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIGxhc3QgcG9pbnRcclxuICAgICAgICBseCA9IHB4O1xyXG4gICAgICAgIGx5ID0gcHk7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IGRpcmVjdGlvblxyXG4gICAgICAgIGxkeCA9IGR4O1xyXG4gICAgICAgIGxkeSA9IGR5O1xyXG5cclxuICAgICAgICAvLyBuZXh0IHBvaW50XHJcbiAgICAgICAgcHggPSBwYXRoW2ldWzBdO1xyXG4gICAgICAgIHB5ID0gcGF0aFtpXVsxXTtcclxuXHJcbiAgICAgICAgLy8gbmV4dCBkaXJlY3Rpb25cclxuICAgICAgICBkeCA9IHB4IC0gbHg7XHJcbiAgICAgICAgZHkgPSBweSAtIGx5O1xyXG5cclxuICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICBzcSA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcclxuICAgICAgICBkeCAvPSBzcTtcclxuICAgICAgICBkeSAvPSBzcTtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGRpcmVjdGlvbiBoYXMgY2hhbmdlZCwgc3RvcmUgdGhlIHBvaW50XHJcbiAgICAgICAgaWYgKCBkeCAhPT0gbGR4IHx8IGR5ICE9PSBsZHkgKSB7XHJcbiAgICAgICAgICAgIGNvbXByZXNzZWQucHVzaChbbHgsbHldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgcG9pbnRcclxuICAgIGNvbXByZXNzZWQucHVzaChbcHgscHldKTtcclxuXHJcbiAgICByZXR1cm4gY29tcHJlc3NlZDtcclxufVxyXG5leHBvcnRzLmNvbXByZXNzUGF0aCA9IGNvbXByZXNzUGF0aDtcclxuXHJcbn0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICdIZWFwJyAgICAgICAgICAgICAgICAgICAgICA6IF9kZXJlcV8oJ2hlYXAnKSxcclxuICAgICdOb2RlJyAgICAgICAgICAgICAgICAgICAgICA6IF9kZXJlcV8oJy4vY29yZS9Ob2RlJyksXHJcbiAgICAnR3JpZCcgICAgICAgICAgICAgICAgICAgICAgOiBfZGVyZXFfKCcuL2NvcmUvR3JpZCcpLFxyXG4gICAgJ1V0aWwnICAgICAgICAgICAgICAgICAgICAgIDogX2RlcmVxXygnLi9jb3JlL1V0aWwnKSxcclxuICAgICdEaWFnb25hbE1vdmVtZW50JyAgICAgICAgICA6IF9kZXJlcV8oJy4vY29yZS9EaWFnb25hbE1vdmVtZW50JyksXHJcbiAgICAnSGV1cmlzdGljJyAgICAgICAgICAgICAgICAgOiBfZGVyZXFfKCcuL2NvcmUvSGV1cmlzdGljJyksXHJcbiAgICAnQVN0YXJGaW5kZXInICAgICAgICAgICAgICAgOiBfZGVyZXFfKCcuL2ZpbmRlcnMvQVN0YXJGaW5kZXInKSxcclxuICAgICdCZXN0Rmlyc3RGaW5kZXInICAgICAgICAgICA6IF9kZXJlcV8oJy4vZmluZGVycy9CZXN0Rmlyc3RGaW5kZXInKSxcclxuICAgICdCcmVhZHRoRmlyc3RGaW5kZXInICAgICAgICA6IF9kZXJlcV8oJy4vZmluZGVycy9CcmVhZHRoRmlyc3RGaW5kZXInKSxcclxuICAgICdEaWprc3RyYUZpbmRlcicgICAgICAgICAgICA6IF9kZXJlcV8oJy4vZmluZGVycy9EaWprc3RyYUZpbmRlcicpLFxyXG4gICAgJ0JpQVN0YXJGaW5kZXInICAgICAgICAgICAgIDogX2RlcmVxXygnLi9maW5kZXJzL0JpQVN0YXJGaW5kZXInKSxcclxuICAgICdCaUJlc3RGaXJzdEZpbmRlcicgICAgICAgICA6IF9kZXJlcV8oJy4vZmluZGVycy9CaUJlc3RGaXJzdEZpbmRlcicpLFxyXG4gICAgJ0JpQnJlYWR0aEZpcnN0RmluZGVyJyAgICAgIDogX2RlcmVxXygnLi9maW5kZXJzL0JpQnJlYWR0aEZpcnN0RmluZGVyJyksXHJcbiAgICAnQmlEaWprc3RyYUZpbmRlcicgICAgICAgICAgOiBfZGVyZXFfKCcuL2ZpbmRlcnMvQmlEaWprc3RyYUZpbmRlcicpLFxyXG4gICAgJ0lEQVN0YXJGaW5kZXInICAgICAgICAgICAgIDogX2RlcmVxXygnLi9maW5kZXJzL0lEQVN0YXJGaW5kZXInKSxcclxuICAgICdKdW1wUG9pbnRGaW5kZXInICAgICAgICAgICA6IF9kZXJlcV8oJy4vZmluZGVycy9KdW1wUG9pbnRGaW5kZXInKSxcclxufTtcclxuXHJcbn0se1wiLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnRcIjozLFwiLi9jb3JlL0dyaWRcIjo0LFwiLi9jb3JlL0hldXJpc3RpY1wiOjUsXCIuL2NvcmUvTm9kZVwiOjYsXCIuL2NvcmUvVXRpbFwiOjcsXCIuL2ZpbmRlcnMvQVN0YXJGaW5kZXJcIjo5LFwiLi9maW5kZXJzL0Jlc3RGaXJzdEZpbmRlclwiOjEwLFwiLi9maW5kZXJzL0JpQVN0YXJGaW5kZXJcIjoxMSxcIi4vZmluZGVycy9CaUJlc3RGaXJzdEZpbmRlclwiOjEyLFwiLi9maW5kZXJzL0JpQnJlYWR0aEZpcnN0RmluZGVyXCI6MTMsXCIuL2ZpbmRlcnMvQmlEaWprc3RyYUZpbmRlclwiOjE0LFwiLi9maW5kZXJzL0JyZWFkdGhGaXJzdEZpbmRlclwiOjE1LFwiLi9maW5kZXJzL0RpamtzdHJhRmluZGVyXCI6MTYsXCIuL2ZpbmRlcnMvSURBU3RhckZpbmRlclwiOjE3LFwiLi9maW5kZXJzL0p1bXBQb2ludEZpbmRlclwiOjIyLFwiaGVhcFwiOjF9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEhlYXAgICAgICAgPSBfZGVyZXFfKCdoZWFwJyk7XHJcbnZhciBVdGlsICAgICAgID0gX2RlcmVxXygnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBIZXVyaXN0aWMgID0gX2RlcmVxXygnLi4vY29yZS9IZXVyaXN0aWMnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBBKiBwYXRoLWZpbmRlci4gQmFzZWQgdXBvbiBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxyXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvclxyXG4gKiAgICAgc3Vib3B0aW1hbCBwYXRocywgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cclxuICovXHJcbmZ1bmN0aW9uIEFTdGFyRmluZGVyKG9wdCkge1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XHJcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcclxuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xyXG4gICAgdGhpcy53ZWlnaHQgPSBvcHQud2VpZ2h0IHx8IDE7XHJcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcclxuXHJcbiAgICBpZiAoIXRoaXMuZGlhZ29uYWxNb3ZlbWVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RpYWdvbmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZG9udENyb3NzQ29ybmVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdoZW4gZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZCB0aGUgbWFuaGF0dGFuIGhldXJpc3RpYyBpcyBub3RcclxuICAgIC8vYWRtaXNzaWJsZS4gSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcclxuICogICAgIGVuZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5BU3RhckZpbmRlci5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xyXG4gICAgdmFyIG9wZW5MaXN0ID0gbmV3IEhlYXAoZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcclxuICAgICAgICB9KSxcclxuICAgICAgICBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxyXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxyXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXHJcbiAgICAgICAgd2VpZ2h0ID0gdGhpcy53ZWlnaHQsXHJcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIFNRUlQyID0gTWF0aC5TUVJUMixcclxuICAgICAgICBub2RlLCBuZWlnaGJvcnMsIG5laWdoYm9yLCBpLCBsLCB4LCB5LCBuZztcclxuXHJcbiAgICAvLyBzZXQgdGhlIGcgYW5kIGYgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxyXG4gICAgc3RhcnROb2RlLmcgPSAwO1xyXG4gICAgc3RhcnROb2RlLmYgPSAwO1xyXG5cclxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IG5vZGUgaW50byB0aGUgb3BlbiBsaXN0XHJcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgb3BlbiBsaXN0IGlzIG5vdCBlbXB0eVxyXG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bSBmIHZhbHVlLlxyXG4gICAgICAgIG5vZGUgPSBvcGVuTGlzdC5wb3AoKTtcclxuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGlmIHJlYWNoZWQgdGhlIGVuZCBwb3NpdGlvbiwgY29uc3RydWN0IHRoZSBwYXRoIGFuZCByZXR1cm4gaXRcclxuICAgICAgICBpZiAobm9kZSA9PT0gZW5kTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgbmVpZ2JvdXJzIG9mIHRoZSBjdXJyZW50IG5vZGVcclxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcclxuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXHJcbiAgICAgICAgICAgIG5nID0gbm9kZS5nICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZWlnaGJvciBoYXMgbm90IGJlZW4gaW5zcGVjdGVkIHlldCwgb3JcclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZyA9IG5nO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgd2VpZ2h0ICogaGV1cmlzdGljKGFicyh4IC0gZW5kWCksIGFicyh5IC0gZW5kWSkpO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWlnaGJvciBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdHMgZiB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLCB3ZSBoYXZlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgb3BlbiBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbkxpc3QudXBkYXRlSXRlbShuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBuZWlnaGJvclxyXG4gICAgfSAvLyBlbmQgd2hpbGUgbm90IG9wZW4gbGlzdCBlbXB0eVxyXG5cclxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBU3RhckZpbmRlcjtcclxuXHJcbn0se1wiLi4vY29yZS9EaWFnb25hbE1vdmVtZW50XCI6MyxcIi4uL2NvcmUvSGV1cmlzdGljXCI6NSxcIi4uL2NvcmUvVXRpbFwiOjcsXCJoZWFwXCI6MX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEFTdGFyRmluZGVyID0gX2RlcmVxXygnLi9BU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEJlc3QtRmlyc3QtU2VhcmNoIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQVN0YXJGaW5kZXJcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC5cclxuICogICAgIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmdcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICovXHJcbmZ1bmN0aW9uIEJlc3RGaXJzdEZpbmRlcihvcHQpIHtcclxuICAgIEFTdGFyRmluZGVyLmNhbGwodGhpcywgb3B0KTtcclxuXHJcbiAgICB2YXIgb3JpZyA9IHRoaXMuaGV1cmlzdGljO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gb3JpZyhkeCwgZHkpICogMTAwMDAwMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUgPSBuZXcgQVN0YXJGaW5kZXIoKTtcclxuQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJlc3RGaXJzdEZpbmRlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmVzdEZpcnN0RmluZGVyO1xyXG5cclxufSx7XCIuL0FTdGFyRmluZGVyXCI6OX1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIEhlYXAgICAgICAgPSBfZGVyZXFfKCdoZWFwJyk7XHJcbnZhciBVdGlsICAgICAgID0gX2RlcmVxXygnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBIZXVyaXN0aWMgID0gX2RlcmVxXygnLi4vY29yZS9IZXVyaXN0aWMnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBBKiBwYXRoLWZpbmRlci5cclxuICogYmFzZWQgdXBvbiBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxyXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvclxyXG4gKiAgICAgc3Vib3B0aW1hbCBwYXRocywgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cclxuICovXHJcbmZ1bmN0aW9uIEJpQVN0YXJGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcclxuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xyXG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XHJcbiAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcclxuICAgIHRoaXMud2VpZ2h0ID0gb3B0LndlaWdodCB8fCAxO1xyXG5cclxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9XaGVuIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQgdGhlIG1hbmhhdHRhbiBoZXVyaXN0aWMgaXMgbm90IGFkbWlzc2libGVcclxuICAgIC8vSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcclxuICogICAgIGVuZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5CaUFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgY21wID0gZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXJ0T3Blbkxpc3QgPSBuZXcgSGVhcChjbXApLFxyXG4gICAgICAgIGVuZE9wZW5MaXN0ID0gbmV3IEhlYXAoY21wKSxcclxuICAgICAgICBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxyXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxyXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXHJcbiAgICAgICAgd2VpZ2h0ID0gdGhpcy53ZWlnaHQsXHJcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIFNRUlQyID0gTWF0aC5TUVJUMixcclxuICAgICAgICBub2RlLCBuZWlnaGJvcnMsIG5laWdoYm9yLCBpLCBsLCB4LCB5LCBuZyxcclxuICAgICAgICBCWV9TVEFSVCA9IDEsIEJZX0VORCA9IDI7XHJcblxyXG4gICAgLy8gc2V0IHRoZSAgYW5kICB2YWx1ZSBvZiB0aGUgc3RhcnQgbm9kZSB0byBiZSAwXHJcbiAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIHRoZSBzdGFydCBvcGVuIGxpc3RcclxuICAgIHN0YXJ0Tm9kZS5nID0gMDtcclxuICAgIHN0YXJ0Tm9kZS5mID0gMDtcclxuICAgIHN0YXJ0T3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xyXG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IEJZX1NUQVJUO1xyXG5cclxuICAgIC8vIHNldCB0aGVhbmQgdmFsdWUgb2YgdGhlIGVuZCBub2RlIHRvIGJlIDBcclxuICAgIC8vIGFuZCBwdXNoIGl0IGludG8gdGhlIG9wZW4gb3BlbiBsaXN0XHJcbiAgICBlbmROb2RlLmcgPSAwO1xyXG4gICAgZW5kTm9kZS5mID0gMDtcclxuICAgIGVuZE9wZW5MaXN0LnB1c2goZW5kTm9kZSk7XHJcbiAgICBlbmROb2RlLm9wZW5lZCA9IEJZX0VORDtcclxuXHJcbiAgICAvLyB3aGlsZSBib3RoIHRoZSBvcGVuIGxpc3RzIGFyZSBub3QgZW1wdHlcclxuICAgIHdoaWxlICghc3RhcnRPcGVuTGlzdC5lbXB0eSgpICYmICFlbmRPcGVuTGlzdC5lbXB0eSgpKSB7XHJcblxyXG5cclxuICAgICAgICBub2RlID0gc3RhcnRPcGVuTGlzdC5wb3AoKTtcclxuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGdldCBuZWlnYm91cnMgb2YgdGhlIGN1cnJlbnQgbm9kZVxyXG4gICAgICAgIG5laWdoYm9ycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIGRpYWdvbmFsTW92ZW1lbnQpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLm9wZW5lZCA9PT0gQllfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5iaUJhY2t0cmFjZShub2RlLCBuZWlnaGJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHggPSBuZWlnaGJvci54O1xyXG4gICAgICAgICAgICB5ID0gbmVpZ2hib3IueTtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG5vZGUgYW5kIHRoZSBuZWlnaGJvclxyXG4gICAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHRoZSBuZXh0IGcgc2NvcmVcclxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyAoKHggLSBub2RlLnggPT09IDAgfHwgeSAtIG5vZGUueSA9PT0gMCkgPyAxIDogU1FSVDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5laWdoYm9yIGhhcyBub3QgYmVlbiBpbnNwZWN0ZWQgeWV0LCBvclxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcclxuICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQgfHwgbmcgPCBuZWlnaGJvci5nKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gbmc7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodCAqIGhldXJpc3RpYyhhYnMoeCAtIGVuZFgpLCBhYnMoeSAtIGVuZFkpKTtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IEJZX1NUQVJUO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVpZ2hib3IgY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgaXRzIGYgdmFsdWUgaGFzIGJlZW4gdXBkYXRlZCwgd2UgaGF2ZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpdHMgcG9zaXRpb24gaW4gdGhlIG9wZW4gbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T3Blbkxpc3QudXBkYXRlSXRlbShuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBuZWlnaGJvclxyXG5cclxuXHJcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBlbmQgbm9kZSB3aGljaCBoYXMgdGhlXHJcbiAgICAgICAgbm9kZSA9IGVuZE9wZW5MaXN0LnBvcCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IG5laWdib3VycyBvZiB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkID09PSBCWV9TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2UobmVpZ2hib3IsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcclxuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXHJcbiAgICAgICAgICAgIG5nID0gbm9kZS5nICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZWlnaGJvciBoYXMgbm90IGJlZW4gaW5zcGVjdGVkIHlldCwgb3JcclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZyA9IG5nO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHxcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBzdGFydFgpLCBhYnMoeSAtIHN0YXJ0WSkpO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IEJZX0VORDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaXRzIHBvc2l0aW9uIGluIHRoZSBvcGVuIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBlbmRPcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXHJcbiAgICB9IC8vIGVuZCB3aGlsZSBub3Qgb3BlbiBsaXN0IGVtcHR5XHJcblxyXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpQVN0YXJGaW5kZXI7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuLi9jb3JlL0hldXJpc3RpY1wiOjUsXCIuLi9jb3JlL1V0aWxcIjo3LFwiaGVhcFwiOjF9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBCaUFTdGFyRmluZGVyID0gX2RlcmVxXygnLi9CaUFTdGFyRmluZGVyJyk7XHJcblxyXG4vKipcclxuICogQmktZGlyZWNpdGlvbmFsIEJlc3QtRmlyc3QtU2VhcmNoIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQmlBU3RhckZpbmRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcclxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxyXG4gKi9cclxuZnVuY3Rpb24gQmlCZXN0Rmlyc3RGaW5kZXIob3B0KSB7XHJcbiAgICBCaUFTdGFyRmluZGVyLmNhbGwodGhpcywgb3B0KTtcclxuXHJcbiAgICB2YXIgb3JpZyA9IHRoaXMuaGV1cmlzdGljO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gb3JpZyhkeCwgZHkpICogMTAwMDAwMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkJpQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZSA9IG5ldyBCaUFTdGFyRmluZGVyKCk7XHJcbkJpQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpQmVzdEZpcnN0RmluZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaUJlc3RGaXJzdEZpbmRlcjtcclxuXHJcbn0se1wiLi9CaUFTdGFyRmluZGVyXCI6MTF9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBVdGlsID0gX2RlcmVxXygnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gX2RlcmVxXygnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogQmktZGlyZWN0aW9uYWwgQnJlYWR0aC1GaXJzdC1TZWFyY2ggcGF0aCBmaW5kZXIuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gQmlCcmVhZHRoRmlyc3RGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcclxuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xyXG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxyXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cclxuICovXHJcbkJpQnJlYWR0aEZpcnN0RmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgc3RhcnROb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpLFxyXG4gICAgICAgIGVuZE5vZGUgPSBncmlkLmdldE5vZGVBdChlbmRYLCBlbmRZKSxcclxuICAgICAgICBzdGFydE9wZW5MaXN0ID0gW10sIGVuZE9wZW5MaXN0ID0gW10sXHJcbiAgICAgICAgbmVpZ2hib3JzLCBuZWlnaGJvciwgbm9kZSxcclxuICAgICAgICBkaWFnb25hbE1vdmVtZW50ID0gdGhpcy5kaWFnb25hbE1vdmVtZW50LFxyXG4gICAgICAgIEJZX1NUQVJUID0gMCwgQllfRU5EID0gMSxcclxuICAgICAgICBpLCBsO1xyXG5cclxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMgaW50byB0aGUgcXVldWVzXHJcbiAgICBzdGFydE9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcclxuICAgIHN0YXJ0Tm9kZS5vcGVuZWQgPSB0cnVlO1xyXG4gICAgc3RhcnROb2RlLmJ5ID0gQllfU1RBUlQ7XHJcblxyXG4gICAgZW5kT3Blbkxpc3QucHVzaChlbmROb2RlKTtcclxuICAgIGVuZE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuICAgIGVuZE5vZGUuYnkgPSBCWV9FTkQ7XHJcblxyXG4gICAgLy8gd2hpbGUgYm90aCB0aGUgcXVldWVzIGFyZSBub3QgZW1wdHlcclxuICAgIHdoaWxlIChzdGFydE9wZW5MaXN0Lmxlbmd0aCAmJiBlbmRPcGVuTGlzdC5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgLy8gZXhwYW5kIHN0YXJ0IG9wZW4gbGlzdFxyXG5cclxuICAgICAgICBub2RlID0gc3RhcnRPcGVuTGlzdC5zaGlmdCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG5vZGUgaGFzIGJlZW4gaW5zcGVjdGVkIGJ5IHRoZSByZXZlcnNlZCBzZWFyY2gsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGEgcGF0aCBpcyBmb3VuZC5cclxuICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5ieSA9PT0gQllfRU5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2Uobm9kZSwgbmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhcnRPcGVuTGlzdC5wdXNoKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmVpZ2hib3IuYnkgPSBCWV9TVEFSVDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGV4cGFuZCBlbmQgb3BlbiBsaXN0XHJcblxyXG4gICAgICAgIG5vZGUgPSBlbmRPcGVuTGlzdC5zaGlmdCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuYnkgPT09IEJZX1NUQVJUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2UobmVpZ2hib3IsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5kT3Blbkxpc3QucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLmJ5ID0gQllfRU5EO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBmYWlsIHRvIGZpbmQgdGhlIHBhdGhcclxuICAgIHJldHVybiBbXTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmlCcmVhZHRoRmlyc3RGaW5kZXI7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuLi9jb3JlL1V0aWxcIjo3fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgQmlBU3RhckZpbmRlciA9IF9kZXJlcV8oJy4vQmlBU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEJpLWRpcmVjdGlvbmFsIERpamtzdHJhIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQmlBU3RhckZpbmRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gQmlEaWprc3RyYUZpbmRlcihvcHQpIHtcclxuICAgIEJpQVN0YXJGaW5kZXIuY2FsbCh0aGlzLCBvcHQpO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkJpRGlqa3N0cmFGaW5kZXIucHJvdG90eXBlID0gbmV3IEJpQVN0YXJGaW5kZXIoKTtcclxuQmlEaWprc3RyYUZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaURpamtzdHJhRmluZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaURpamtzdHJhRmluZGVyO1xyXG5cclxufSx7XCIuL0JpQVN0YXJGaW5kZXJcIjoxMX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxudmFyIFV0aWwgPSBfZGVyZXFfKCcuLi9jb3JlL1V0aWwnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBCcmVhZHRoLUZpcnN0LVNlYXJjaCBwYXRoIGZpbmRlci5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcclxuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xyXG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgdGhlIHBhdGguXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXHJcbiAqICAgICBlbmQgcG9zaXRpb25zLlxyXG4gKi9cclxuQnJlYWR0aEZpcnN0RmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgb3Blbkxpc3QgPSBbXSxcclxuICAgICAgICBkaWFnb25hbE1vdmVtZW50ID0gdGhpcy5kaWFnb25hbE1vdmVtZW50LFxyXG4gICAgICAgIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcclxuICAgICAgICBlbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksXHJcbiAgICAgICAgbmVpZ2hib3JzLCBuZWlnaGJvciwgbm9kZSwgaSwgbDtcclxuXHJcbiAgICAvLyBwdXNoIHRoZSBzdGFydCBwb3MgaW50byB0aGUgcXVldWVcclxuICAgIG9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcclxuICAgIHN0YXJ0Tm9kZS5vcGVuZWQgPSB0cnVlO1xyXG5cclxuICAgIC8vIHdoaWxlIHRoZSBxdWV1ZSBpcyBub3QgZW1wdHlcclxuICAgIHdoaWxlIChvcGVuTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAvLyB0YWtlIHRoZSBmcm9udCBub2RlIGZyb20gdGhlIHF1ZXVlXHJcbiAgICAgICAgbm9kZSA9IG9wZW5MaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyByZWFjaGVkIHRoZSBlbmQgcG9zaXRpb25cclxuICAgICAgICBpZiAobm9kZSA9PT0gZW5kTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNraXAgdGhpcyBuZWlnaGJvciBpZiBpdCBoYXMgYmVlbiBpbnNwZWN0ZWQgYmVmb3JlXHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQgfHwgbmVpZ2hib3Iub3BlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3Blbkxpc3QucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCcmVhZHRoRmlyc3RGaW5kZXI7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuLi9jb3JlL1V0aWxcIjo3fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG52YXIgQVN0YXJGaW5kZXIgPSBfZGVyZXFfKCcuL0FTdGFyRmluZGVyJyk7XHJcblxyXG4vKipcclxuICogRGlqa3N0cmEgcGF0aC1maW5kZXIuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAZXh0ZW5kcyBBU3RhckZpbmRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gRGlqa3N0cmFGaW5kZXIob3B0KSB7XHJcbiAgICBBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XHJcbiAgICB0aGlzLmhldXJpc3RpYyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxufVxyXG5cclxuRGlqa3N0cmFGaW5kZXIucHJvdG90eXBlID0gbmV3IEFTdGFyRmluZGVyKCk7XHJcbkRpamtzdHJhRmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpamtzdHJhRmluZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEaWprc3RyYUZpbmRlcjtcclxuXHJcbn0se1wiLi9BU3RhckZpbmRlclwiOjl9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbnZhciBVdGlsICAgICAgID0gX2RlcmVxXygnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBIZXVyaXN0aWMgID0gX2RlcmVxXygnLi4vY29yZS9IZXVyaXN0aWMnKTtcclxudmFyIE5vZGUgICAgICAgPSBfZGVyZXFfKCcuLi9jb3JlL05vZGUnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBJdGVyYXRpdmUgRGVlcGluZyBBIFN0YXIgKElEQSopIHBhdGgtZmluZGVyLlxyXG4gKlxyXG4gKiBSZWN1cnNpb24gYmFzZWQgb246XHJcbiAqICAgaHR0cDovL3d3dy5hcGwuamh1LmVkdS9+aGFsbC9BSS1Qcm9ncmFtbWluZy9JREEtU3Rhci5odG1sXHJcbiAqXHJcbiAqIFBhdGggcmV0cmFjaW5nIGJhc2VkIG9uOlxyXG4gKiAgVi4gTmFnZXNod2FyYSBSYW8sIFZpcGluIEt1bWFyIGFuZCBLLiBSYW1lc2hcclxuICogIFwiQSBQYXJhbGxlbCBJbXBsZW1lbnRhdGlvbiBvZiBJdGVyYXRpdmUtRGVlcGluZy1BKlwiLCBKYW51YXJ5IDE5ODcuXHJcbiAqICBmdHA6Ly9mdHAuY3MudXRleGFzLmVkdS8uc25hcHNob3QvaG91cmx5LjEvcHViL0FJLUxhYi90ZWNoLXJlcG9ydHMvVVQtQUktVFItODctNDYucGRmXHJcbiAqXHJcbiAqIEBhdXRob3IgR2VyYXJkIE1laWVyICh3d3cuZ2VyYXJkbWVpZXIuY29tKVxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC5cclxuICogICAgIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmdcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC53ZWlnaHQgV2VpZ2h0IHRvIGFwcGx5IHRvIHRoZSBoZXVyaXN0aWMgdG8gYWxsb3cgZm9yXHJcbiAqICAgICBzdWJvcHRpbWFsIHBhdGhzLCBpbiBvcmRlciB0byBzcGVlZCB1cCB0aGUgc2VhcmNoLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC50cmFja1JlY3Vyc2lvbiBXaGV0aGVyIHRvIHRyYWNrIHJlY3Vyc2lvbiBmb3JcclxuICogICAgIHN0YXRpc3RpY2FsIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0LnRpbWVMaW1pdCBNYXhpbXVtIGV4ZWN1dGlvbiB0aW1lLiBVc2UgPD0gMCBmb3IgaW5maW5pdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBJREFTdGFyRmluZGVyKG9wdCkge1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XHJcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcclxuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB0aGlzLndlaWdodCA9IG9wdC53ZWlnaHQgfHwgMTtcclxuICAgIHRoaXMudHJhY2tSZWN1cnNpb24gPSBvcHQudHJhY2tSZWN1cnNpb24gfHwgZmFsc2U7XHJcbiAgICB0aGlzLnRpbWVMaW1pdCA9IG9wdC50aW1lTGltaXQgfHwgSW5maW5pdHk7IC8vIERlZmF1bHQ6IG5vIHRpbWUgbGltaXQuXHJcblxyXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBXaGVuIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQgdGhlIG1hbmhhdHRhbiBoZXVyaXN0aWMgaXMgbm90XHJcbiAgICAvLyBhZG1pc3NpYmxlLCBpdCBzaG91bGQgYmUgb2N0aWxlIGluc3RlYWRcclxuICAgIGlmICh0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpIHtcclxuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5vY3RpbGU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLiBXaGVuIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLCBlaXRoZXJcclxuICogbm8gcGF0aCBpcyBwb3NzaWJsZSwgb3IgdGhlIG1heGltdW0gZXhlY3V0aW9uIHRpbWUgaXMgcmVhY2hlZC5cclxuICpcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcclxuICogICAgIGVuZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5JREFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICAvLyBVc2VkIGZvciBzdGF0aXN0aWNzOlxyXG4gICAgdmFyIG5vZGVzVmlzaXRlZCA9IDA7XHJcblxyXG4gICAgLy8gRXhlY3V0aW9uIHRpbWUgbGltaXRhdGlvbjpcclxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICAvLyBIZXVyaXN0aWMgaGVscGVyOlxyXG4gICAgdmFyIGggPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV1cmlzdGljKE1hdGguYWJzKGIueCAtIGEueCksIE1hdGguYWJzKGIueSAtIGEueSkpO1xyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIFN0ZXAgY29zdCBmcm9tIGEgdG8gYjpcclxuICAgIHZhciBjb3N0ID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHJldHVybiAoYS54ID09PSBiLnggfHwgYS55ID09PSBiLnkpID8gMSA6IE1hdGguU1FSVDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSURBKiBzZWFyY2ggaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBUaGUgbm9kZSBjdXJyZW50bHkgZXhwYW5kaW5nIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gQ29zdCB0byByZWFjaCB0aGUgZ2l2ZW4gbm9kZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBNYXhpbXVtIHNlYXJjaCBkZXB0aCAoY3V0LW9mZiB2YWx1ZSkuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgZm91bmQgcm91dGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gUmVjdXJzaW9uIGRlcHRoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZWl0aGVyIGEgbnVtYmVyIHdpdGggdGhlIG5ldyBvcHRpbWFsIGN1dC1vZmYgZGVwdGgsXHJcbiAgICAgKiBvciBhIHZhbGlkIG5vZGUgaW5zdGFuY2UsIGluIHdoaWNoIGNhc2UgYSBwYXRoIHdhcyBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgdmFyIHNlYXJjaCA9IGZ1bmN0aW9uKG5vZGUsIGcsIGN1dG9mZiwgcm91dGUsIGRlcHRoKSB7XHJcbiAgICAgICAgbm9kZXNWaXNpdGVkKys7XHJcblxyXG4gICAgICAgIC8vIEVuZm9yY2UgdGltZWxpbWl0OlxyXG4gICAgICAgIGlmICh0aGlzLnRpbWVMaW1pdCA+IDAgJiZcclxuICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPiB0aGlzLnRpbWVMaW1pdCAqIDEwMDApIHtcclxuICAgICAgICAgICAgLy8gRW5mb3JjZWQgYXMgXCJwYXRoLW5vdC1mb3VuZFwiLlxyXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZiA9IGcgKyBoKG5vZGUsIGVuZCkgKiB0aGlzLndlaWdodDtcclxuXHJcbiAgICAgICAgLy8gV2UndmUgc2VhcmNoZWQgdG9vIGRlZXAgZm9yIHRoaXMgaXRlcmF0aW9uLlxyXG4gICAgICAgIGlmIChmID4gY3V0b2ZmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUgPT0gZW5kKSB7XHJcbiAgICAgICAgICAgIHJvdXRlW2RlcHRoXSA9IFtub2RlLngsIG5vZGUueV07XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG1pbiwgdCwgaywgbmVpZ2hib3VyO1xyXG5cclxuICAgICAgICB2YXIgbmVpZ2hib3VycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCk7XHJcblxyXG4gICAgICAgIC8vIFNvcnQgdGhlIG5laWdoYm91cnMsIGdpdmVzIG5pY2VyIHBhdGhzLiBCdXQsIHRoaXMgZGV2aWF0ZXNcclxuICAgICAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gLSBzbyBJIGxlZnQgaXQgb3V0LlxyXG4gICAgICAgIC8vbmVpZ2hib3Vycy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIC8vICAgIHJldHVybiBoKGEsIGVuZCkgLSBoKGIsIGVuZCk7XHJcbiAgICAgICAgLy99KTtcclxuXHJcblxyXG4gICAgICAgIC8qanNoaW50IC1XMDg0ICovLy9EaXNhYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxyXG4gICAgICAgIGZvciAoayA9IDAsIG1pbiA9IEluZmluaXR5OyBuZWlnaGJvdXIgPSBuZWlnaGJvdXJzW2tdOyArK2spIHtcclxuICAgICAgICAvKmpzaGludCArVzA4NCAqLy8vRW5hYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFja1JlY3Vyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0YWluIGEgY29weSBmb3IgdmlzdWFsaXNhdGlvbi4gRHVlIHRvIHJlY3Vyc2lvbiwgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcGFydCBvZiBvdGhlciBwYXRocyB0b28uXHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvdXIucmV0YWluQ291bnQgPSBuZWlnaGJvdXIucmV0YWluQ291bnQgKyAxIHx8IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobmVpZ2hib3VyLnRlc3RlZCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ID0gc2VhcmNoKG5laWdoYm91ciwgZyArIGNvc3Qobm9kZSwgbmVpZ2hib3VyKSwgY3V0b2ZmLCByb3V0ZSwgZGVwdGggKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcm91dGVbZGVwdGhdID0gW25vZGUueCwgbm9kZS55XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgYSB0eXBpY2FsIEEqIGxpbmtlZCBsaXN0LCB0aGlzIHdvdWxkIHdvcms6XHJcbiAgICAgICAgICAgICAgICAvLyBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgY291bnQsIHRoZW4gZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyBhY3R1YWxseSBjbG9zZWQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmVjdXJzaW9uICYmICgtLW5laWdoYm91ci5yZXRhaW5Db3VudCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHQgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtaW47XHJcblxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIE5vZGUgaW5zdGFuY2UgbG9va3VwczpcclxuICAgIHZhciBzdGFydCA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKTtcclxuICAgIHZhciBlbmQgICA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpO1xyXG5cclxuICAgIC8vIEluaXRpYWwgc2VhcmNoIGRlcHRoLCBnaXZlbiB0aGUgdHlwaWNhbCBoZXVyaXN0aWMgY29udHJhaW50cyxcclxuICAgIC8vIHRoZXJlIHNob3VsZCBiZSBubyBjaGVhcGVyIHJvdXRlIHBvc3NpYmxlLlxyXG4gICAgdmFyIGN1dE9mZiA9IGgoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgdmFyIGosIHJvdXRlLCB0O1xyXG5cclxuICAgIC8vIFdpdGggYW4gb3ZlcmZsb3cgcHJvdGVjdGlvbi5cclxuICAgIGZvciAoaiA9IDA7IHRydWU7ICsraikge1xyXG5cclxuICAgICAgICByb3V0ZSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBTZWFyY2ggdGlsbCBjdXQtb2ZmIGRlcHRoOlxyXG4gICAgICAgIHQgPSBzZWFyY2goc3RhcnQsIDAsIGN1dE9mZiwgcm91dGUsIDApO1xyXG5cclxuICAgICAgICAvLyBSb3V0ZSBub3QgcG9zc2libGUsIG9yIG5vdCBmb3VuZCBpbiB0aW1lIGxpbWl0LlxyXG4gICAgICAgIGlmICh0ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0IGlzIGEgbm9kZSwgaXQncyBhbHNvIHRoZSBlbmQgbm9kZS4gUm91dGUgaXMgbm93XHJcbiAgICAgICAgLy8gcG9wdWxhdGVkIHdpdGggYSB2YWxpZCBwYXRoIHRvIHRoZSBlbmQgbm9kZS5cclxuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJ5IGFnYWluLCB0aGlzIHRpbWUgd2l0aCBhIGRlZXBlciBjdXQtb2ZmLiBUaGUgdCBzY29yZVxyXG4gICAgICAgIC8vIGlzIHRoZSBjbG9zZXN0IHdlIGdvdCB0byB0aGUgZW5kIG5vZGUuXHJcbiAgICAgICAgY3V0T2ZmID0gdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIF9zaG91bGRfIG5ldmVyIHRvIGJlIHJlYWNoZWQuXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElEQVN0YXJGaW5kZXI7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuLi9jb3JlL0hldXJpc3RpY1wiOjUsXCIuLi9jb3JlL05vZGVcIjo2LFwiLi4vY29yZS9VdGlsXCI6N31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IF9kZXJlcV8oJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IF9kZXJlcV8oJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggYWx3YXlzIG1vdmVzXHJcbiAqIGRpYWdvbmFsbHkgaXJyZXNwZWN0aXZlIG9mIHRoZSBudW1iZXIgb2Ygb2JzdGFjbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkob3B0KSB7XHJcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcclxufVxyXG5cclxuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcclxuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlBGQWx3YXlzTW92ZURpYWdvbmFsbHk7XHJcblxyXG4vKipcclxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXHJcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcclxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XHJcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XHJcblxyXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcclxuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxyXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XHJcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcclxuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiggZHggIT09IDAgKSB7IC8vIG1vdmluZyBhbG9uZyB4XHJcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB8fFxyXG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB8fFxyXG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcclxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcclxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cclxuICovXHJcbkpQRkFsd2F5c01vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5fZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcclxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxyXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQsXHJcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcclxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xyXG5cclxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcHggPSBwYXJlbnQueDtcclxuICAgICAgICBweSA9IHBhcmVudC55O1xyXG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXHJcbiAgICAgICAgZHggPSAoeCAtIHB4KSAvIE1hdGgubWF4KE1hdGguYWJzKHggLSBweCksIDEpO1xyXG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcclxuXHJcbiAgICAgICAgLy8gc2VhcmNoIGRpYWdvbmFsbHlcclxuICAgICAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSBkeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZWFyY2ggaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYoZHggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYWxsIG5laWdoYm9yc1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseTtcclxuXHJcbn0se1wiLi4vY29yZS9EaWFnb25hbE1vdmVtZW50XCI6MyxcIi4vSnVtcFBvaW50RmluZGVyQmFzZVwiOjIzfV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKipcclxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcclxuICovXHJcbnZhciBKdW1wUG9pbnRGaW5kZXJCYXNlID0gX2RlcmVxXygnLi9KdW1wUG9pbnRGaW5kZXJCYXNlJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gX2RlcmVxXygnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSB3aGljaCBtb3Zlc1xyXG4gKiBkaWFnb25hbGx5IG9ubHkgd2hlbiB0aGVyZSBpcyBhdCBtb3N0IG9uZSBvYnN0YWNsZS5cclxuICovXHJcbmZ1bmN0aW9uIEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZShvcHQpIHtcclxuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xyXG59XHJcblxyXG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcclxuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZTtcclxuXHJcbi8qKlxyXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcclxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxyXG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XHJcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XHJcblxyXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcclxuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxyXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XHJcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcclxuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiggZHggIT09IDAgKSB7IC8vIG1vdmluZyBhbG9uZyB4XHJcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB8fFxyXG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB8fFxyXG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgbWFrZSBzdXJlIG9uZSBvZiB0aGUgdmVydGljYWwvaG9yaXpvbnRhbFxyXG4gICAgLy8gbmVpZ2hib3JzIGlzIG9wZW4gdG8gYWxsb3cgdGhlIHBhdGhcclxuICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpIHx8IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fanVtcCh4ICsgZHgsIHkgKyBkeSwgeCwgeSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcclxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcclxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cclxuICovXHJcbkpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5wcm90b3R5cGUuX2ZpbmROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQsXHJcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcclxuICAgICAgICBncmlkID0gdGhpcy5ncmlkLFxyXG4gICAgICAgIHB4LCBweSwgbngsIG55LCBkeCwgZHksXHJcbiAgICAgICAgbmVpZ2hib3JzID0gW10sIG5laWdoYm9yTm9kZXMsIG5laWdoYm9yTm9kZSwgaSwgbDtcclxuXHJcbiAgICAvLyBkaXJlY3RlZCBwcnVuaW5nOiBjYW4gaWdub3JlIG1vc3QgbmVpZ2hib3JzLCB1bmxlc3MgZm9yY2VkLlxyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHB4ID0gcGFyZW50Lng7XHJcbiAgICAgICAgcHkgPSBwYXJlbnQueTtcclxuICAgICAgICAvLyBnZXQgdGhlIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRyYXZlbFxyXG4gICAgICAgIGR4ID0gKHggLSBweCkgLyBNYXRoLm1heChNYXRoLmFicyh4IC0gcHgpLCAxKTtcclxuICAgICAgICBkeSA9ICh5IC0gcHkpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHB5KSwgMSk7XHJcblxyXG4gICAgICAgIC8vIHNlYXJjaCBkaWFnb25hbGx5XHJcbiAgICAgICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSB8fCBncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSBkeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZihkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5ICsgZHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5ICsgZHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGU7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuL0p1bXBQb2ludEZpbmRlckJhc2VcIjoyM31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IF9kZXJlcV8oJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IF9kZXJlcV8oJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggbW92ZXNcclxuICogZGlhZ29uYWxseSBvbmx5IHdoZW4gdGhlcmUgYXJlIG5vIG9ic3RhY2xlcy5cclxuICovXHJcbmZ1bmN0aW9uIEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcyhvcHQpIHtcclxuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xyXG59XHJcblxyXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcclxuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcztcclxuXHJcbi8qKlxyXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcclxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxyXG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XHJcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XHJcblxyXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcclxuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxyXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgLy8gaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XHJcbiAgICAgICAgICAgIC8vIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcclxuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSAtIDEpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSAtIGR5KSkgfHxcclxuICAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5IC0gZHkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXaGVuIG1vdmluZyB2ZXJ0aWNhbGx5LCBtdXN0IGNoZWNrIGZvciBob3Jpem9udGFsIGp1bXAgcG9pbnRzXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9qdW1wKHggKyAxLCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHggLSAxLCB5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBtYWtlIHN1cmUgb25lIG9mIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsXHJcbiAgICAvLyBuZWlnaGJvcnMgaXMgb3BlbiB0byBhbGxvdyB0aGUgcGF0aFxyXG4gICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9qdW1wKHggKyBkeCwgeSArIGR5LCB4LCB5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIG5vZGUgaGFzIGEgcGFyZW50LFxyXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxyXG4gKi9cclxuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZS5fZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcclxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxyXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQsXHJcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcclxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xyXG5cclxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcHggPSBwYXJlbnQueDtcclxuICAgICAgICBweSA9IHBhcmVudC55O1xyXG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXHJcbiAgICAgICAgZHggPSAoeCAtIHB4KSAvIE1hdGgubWF4KE1hdGguYWJzKHggLSBweCksIDEpO1xyXG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcclxuXHJcbiAgICAgICAgLy8gc2VhcmNoIGRpYWdvbmFsbHlcclxuICAgICAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXNOZXh0V2Fsa2FibGU7XHJcbiAgICAgICAgICAgIGlmIChkeCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXNOZXh0V2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG9wV2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNCb3R0b21XYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG9wV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm90dG9tV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3BXYWxrYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQm90dG9tV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXNOZXh0V2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzUmlnaHRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xlZnRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHRXYWxrYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5ICsgZHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSaWdodFdhbGthYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXM7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuL0p1bXBQb2ludEZpbmRlckJhc2VcIjoyM31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IF9kZXJlcV8oJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IF9kZXJlcV8oJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gYWxsb3dpbmcgb25seSBob3Jpem9udGFsXHJcbiAqIG9yIHZlcnRpY2FsIG1vdmVtZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIEpQRk5ldmVyTW92ZURpYWdvbmFsbHkob3B0KSB7XHJcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcclxufVxyXG5cclxuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xyXG5KUEZOZXZlck1vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk5ldmVyTW92ZURpYWdvbmFsbHk7XHJcblxyXG4vKipcclxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXHJcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcclxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcclxuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxyXG4gICAgICAgIGR4ID0geCAtIHB4LCBkeSA9IHkgLSBweTtcclxuXHJcbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy50cmFja0p1bXBSZWN1cnNpb24gPT09IHRydWUpIHtcclxuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5IC0gMSkpIHx8XHJcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIDEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5IC0gZHkpKSB8fFxyXG4gICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIGR5KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9XaGVuIG1vdmluZyB2ZXJ0aWNhbGx5LCBtdXN0IGNoZWNrIGZvciBob3Jpem9udGFsIGp1bXAgcG9pbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIDEsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCAtIDEsIHksIHgsIHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBtb3ZlbWVudHMgYXJlIGFsbG93ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcclxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcclxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cclxuICovXHJcbkpQRk5ldmVyTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxyXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXHJcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxyXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XHJcblxyXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBweCA9IHBhcmVudC54O1xyXG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcclxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XHJcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xyXG5cclxuICAgICAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5laWdoYm9yTm9kZXMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZOZXZlck1vdmVEaWFnb25hbGx5O1xyXG5cclxufSx7XCIuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnRcIjozLFwiLi9KdW1wUG9pbnRGaW5kZXJCYXNlXCI6MjN9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFuaWVybyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmllcm9cclxuICovXHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gX2RlcmVxXygnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcbnZhciBKUEZOZXZlck1vdmVEaWFnb25hbGx5ID0gX2RlcmVxXygnLi9KUEZOZXZlck1vdmVEaWFnb25hbGx5Jyk7XHJcbnZhciBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseSA9IF9kZXJlcV8oJy4vSlBGQWx3YXlzTW92ZURpYWdvbmFsbHknKTtcclxudmFyIEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcyA9IF9kZXJlcV8oJy4vSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzJyk7XHJcbnZhciBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUgPSBfZGVyZXFfKCcuL0pQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZScpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcclxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IENvbmRpdGlvbiB1bmRlciB3aGljaCBkaWFnb25hbFxyXG4gKiAgICAgIG1vdmVtZW50IHdpbGwgYmUgYWxsb3dlZC5cclxuICovXHJcbmZ1bmN0aW9uIEp1bXBQb2ludEZpbmRlcihvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgIGlmIChvcHQuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseShvcHQpO1xyXG4gICAgfSBlbHNlIGlmIChvcHQuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5BbHdheXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpQRkFsd2F5c01vdmVEaWFnb25hbGx5KG9wdCk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdC5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcyhvcHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZShvcHQpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEp1bXBQb2ludEZpbmRlcjtcclxuXHJcbn0se1wiLi4vY29yZS9EaWFnb25hbE1vdmVtZW50XCI6MyxcIi4vSlBGQWx3YXlzTW92ZURpYWdvbmFsbHlcIjoxOCxcIi4vSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlXCI6MTksXCIuL0pQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlc1wiOjIwLFwiLi9KUEZOZXZlck1vdmVEaWFnb25hbGx5XCI6MjF9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGltb3IgLyBodHRwczovL2dpdGh1Yi5jb20vaW1vclxyXG4gKi9cclxudmFyIEhlYXAgICAgICAgPSBfZGVyZXFfKCdoZWFwJyk7XHJcbnZhciBVdGlsICAgICAgID0gX2RlcmVxXygnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBIZXVyaXN0aWMgID0gX2RlcmVxXygnLi4vY29yZS9IZXVyaXN0aWMnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSBfZGVyZXFfKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciB0aGUgSnVtcCBQb2ludCBTZWFyY2ggYWxnb3JpdGhtXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICovXHJcbmZ1bmN0aW9uIEp1bXBQb2ludEZpbmRlckJhc2Uob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcclxuICAgIHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID0gb3B0LnRyYWNrSnVtcFJlY3Vyc2lvbiB8fCBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgcGF0aC5cclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcclxuICogICAgIGVuZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5KdW1wUG9pbnRGaW5kZXJCYXNlLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgb3Blbkxpc3QgPSB0aGlzLm9wZW5MaXN0ID0gbmV3IEhlYXAoZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcclxuICAgICAgICB9KSxcclxuICAgICAgICBzdGFydE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcclxuICAgICAgICBlbmROb2RlID0gdGhpcy5lbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksIG5vZGU7XHJcblxyXG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcclxuXHJcblxyXG4gICAgc3RhcnROb2RlLmcgPSAwO1xyXG4gICAgc3RhcnROb2RlLmYgPSAwO1xyXG5cclxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IG5vZGUgaW50byB0aGUgb3BlbiBsaXN0XHJcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgb3BlbiBsaXN0IGlzIG5vdCBlbXB0eVxyXG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bVxyXG4gICAgICAgIG5vZGUgPSBvcGVuTGlzdC5wb3AoKTtcclxuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChub2RlID09PSBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlsLmV4cGFuZFBhdGgoVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5faWRlbnRpZnlTdWNjZXNzb3JzKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIElkZW50aWZ5IHN1Y2Nlc3NvcnMgZm9yIHRoZSBnaXZlbiBub2RlLiBSdW5zIGEganVtcCBwb2ludCBzZWFyY2ggaW4gdGhlXHJcbiAqIGRpcmVjdGlvbiBvZiBlYWNoIGF2YWlsYWJsZSBuZWlnaGJvciwgYWRkaW5nIGFueSBwb2ludHMgZm91bmQgdG8gdGhlIG9wZW5cclxuICogbGlzdC5cclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuSnVtcFBvaW50RmluZGVyQmFzZS5wcm90b3R5cGUuX2lkZW50aWZ5U3VjY2Vzc29ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxyXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxyXG4gICAgICAgIG9wZW5MaXN0ID0gdGhpcy5vcGVuTGlzdCxcclxuICAgICAgICBlbmRYID0gdGhpcy5lbmROb2RlLngsXHJcbiAgICAgICAgZW5kWSA9IHRoaXMuZW5kTm9kZS55LFxyXG4gICAgICAgIG5laWdoYm9ycywgbmVpZ2hib3IsXHJcbiAgICAgICAganVtcFBvaW50LCBpLCBsLFxyXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXHJcbiAgICAgICAgangsIGp5LCBkeCwgZHksIGQsIG5nLCBqdW1wTm9kZSxcclxuICAgICAgICBhYnMgPSBNYXRoLmFicywgbWF4ID0gTWF0aC5tYXg7XHJcblxyXG4gICAgbmVpZ2hib3JzID0gdGhpcy5fZmluZE5laWdoYm9ycyhub2RlKTtcclxuICAgIGZvcihpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuICAgICAgICBqdW1wUG9pbnQgPSB0aGlzLl9qdW1wKG5laWdoYm9yWzBdLCBuZWlnaGJvclsxXSwgeCwgeSk7XHJcbiAgICAgICAgaWYgKGp1bXBQb2ludCkge1xyXG5cclxuICAgICAgICAgICAganggPSBqdW1wUG9pbnRbMF07XHJcbiAgICAgICAgICAgIGp5ID0ganVtcFBvaW50WzFdO1xyXG4gICAgICAgICAgICBqdW1wTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGp4LCBqeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoanVtcE5vZGUuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW5jbHVkZSBkaXN0YW5jZSwgYXMgcGFyZW50IG1heSBub3QgYmUgaW1tZWRpYXRlbHkgYWRqYWNlbnQ6XHJcbiAgICAgICAgICAgIGQgPSBIZXVyaXN0aWMub2N0aWxlKGFicyhqeCAtIHgpLCBhYnMoankgLSB5KSk7XHJcbiAgICAgICAgICAgIG5nID0gbm9kZS5nICsgZDtcclxuXHJcbiAgICAgICAgICAgIGlmICghanVtcE5vZGUub3BlbmVkIHx8IG5nIDwganVtcE5vZGUuZykge1xyXG4gICAgICAgICAgICAgICAganVtcE5vZGUuZyA9IG5nO1xyXG4gICAgICAgICAgICAgICAganVtcE5vZGUuaCA9IGp1bXBOb2RlLmggfHwgaGV1cmlzdGljKGFicyhqeCAtIGVuZFgpLCBhYnMoankgLSBlbmRZKSk7XHJcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5mID0ganVtcE5vZGUuZyArIGp1bXBOb2RlLmg7XHJcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5wYXJlbnQgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghanVtcE5vZGUub3BlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbkxpc3QucHVzaChqdW1wTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAganVtcE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbkxpc3QudXBkYXRlSXRlbShqdW1wTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEp1bXBQb2ludEZpbmRlckJhc2U7XHJcblxyXG59LHtcIi4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudFwiOjMsXCIuLi9jb3JlL0hldXJpc3RpY1wiOjUsXCIuLi9jb3JlL1V0aWxcIjo3LFwiaGVhcFwiOjF9XX0se30sWzhdKVxyXG4oOClcclxufSk7YFxyXG5cclxuIyBpbnRlZ3JhdGUgaW50byB0b3JjaFxyXG5Ub3JjaE1vZHVsZSB0aGlzWyBcIlBGXCIgXSwgXCJQRlwiXHJcblxyXG4jIGRlcmVmZXJlY2UgZ2xvYmFsXHJcbnRoaXNbIFwiUEZcIiBdID0gdGVtcFxyXG5cbmNsYXNzIEJvZHlNYW5hZ2VyXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzcHJpdGUpLT5cclxuICAgICAgICBAZ2FtZSA9IEBzcHJpdGUuZ2FtZVxyXG4gICAgICAgIEB2ZWxvY2l0eSA9IG5ldyBWZWN0b3IoMCwwKVxyXG4gICAgICAgIEBhY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yKDAsMClcclxuICAgICAgICBAb21lZ2EgPSAwXHJcbiAgICAgICAgQGFscGhhID0gMFxyXG4gICAgICAgIEBkaXN0YW5jZSA9IDBcclxuICAgICAgICBAb3JiaXQgPSBudWxsXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGRYID0gQHZlbG9jaXR5LnggKiBAZ2FtZS5Mb29wLnVwZGF0ZURlbHRhXHJcbiAgICAgICAgZFkgPSBAdmVsb2NpdHkueSAqIEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuICAgICAgICBAZGlzdGFuY2UgKz0gTWF0aC5zcXJ0KCAoZFggKiBkWCkgKyAoZFkgKiBkWSkgKVxyXG5cclxuICAgICAgICBAc3ByaXRlLnBvc2l0aW9uLnggKz0gZFhcclxuICAgICAgICBAc3ByaXRlLnBvc2l0aW9uLnkgKz0gZFlcclxuXHJcbiAgICAgICAgQHZlbG9jaXR5LnggKz0gQGFjY2VsZXJhdGlvbi54ICogQGdhbWUuTG9vcC51cGRhdGVEZWx0YVxyXG4gICAgICAgIEB2ZWxvY2l0eS55ICs9IEBhY2NlbGVyYXRpb24ueSAqIEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuXHJcbiAgICAgICAgQHNwcml0ZS5yb3RhdGlvbiArPSBAb21lZ2EgKiBAZ2FtZS5Mb29wLnVwZGF0ZURlbHRhXHJcbiAgICAgICAgQHNwcml0ZS5vbWVnYSArPSBAYWxwaGEgKiBAZ2FtZS5Mb29wLnVwZGF0ZURlbHRhXHJcblxyXG4gICAgICAgIGlmIEBvcmJpdD9cclxuICAgICAgICAgICAgQG9yYml0LlVwZGF0ZSgpXHJcblxyXG5cclxuICAgIE9yYml0OiAoc3ByaXRlVG9PcmJpdCwgc3BlZWQsIGxlbmd0aCkgLT5cclxuICAgICAgICBAb3JiaXQgPSBuZXcgT3JiaXQoIEBzcHJpdGUsIHNwcml0ZVRvT3JiaXQsIHNwZWVkLCBsZW5ndGggKVxyXG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBAb3JiaXQuR2V0U3RhcnRQb3NpdGlvbigpXHJcblxyXG4gICAgICAgIEBzcHJpdGUuZ2FtZS5Ud2VlbnMuVHdlZW4oQHNwcml0ZS5wb3NpdGlvbiwgMjAwMCwgVG9yY2guRWFzaW5nLlNtb290aCkuVG8oe3g6IHN0YXJ0UG9zaXRpb24ueCwgeTogc3RhcnRQb3NpdGlvbi55fSlcclxuICAgICAgICAgICAgLk9uIFwiRmluaXNoXCIsID0+XHJcbiAgICAgICAgICAgICAgICBAb3JiaXQuZW5hYmxlZCA9IHRydWVcclxuXHJcbiAgICBEZWJ1ZzogKGNvbG9yID0gXCJyZWRcIikgLT5cclxuICAgICAgICBAREVCVUcgPSBjb2xvclxyXG5cclxuICAgIEFuZ2xlVG86IChvdGhlclNwcml0ZSkgLT5cclxuICAgICAgICBkaXJlY3Rpb25WZWN0b3IgPSBARGlyZWN0aW9uVG8ob3RoZXJTcHJpdGUpXHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvblZlY3Rvci5hbmdsZVxyXG5cclxuICAgIERpc3RhbmNlVG86IChvdGhlclNwcml0ZSkgLT5cclxuICAgICAgICB0aGlzVmVjID0gbmV3IFZlY3RvcihAc3ByaXRlLnBvc2l0aW9uLngsIEBzcHJpdGUucG9zaXRpb24ueSlcclxuICAgICAgICBvdGhlclZlYyA9IG5ldyBWZWN0b3Iob3RoZXJTcHJpdGUucG9zaXRpb24ueCwgb3RoZXJTcHJpdGUucG9zaXRpb24ueSlcclxuICAgICAgICBvdGhlclZlYy5TdWJ0cmFjdFZlY3Rvcih0aGlzVmVjKVxyXG4gICAgICAgIHJldHVybiBvdGhlclZlYy5tYWduaXR1ZGVcclxuXHJcbiAgICBEaXJlY3Rpb25UbzogKG90aGVyU3ByaXRlKSAtPlxyXG4gICAgICAgIHZlYyA9IG5ldyBWZWN0b3IoIChvdGhlclNwcml0ZS5wb3NpdGlvbi54IC0gQHNwcml0ZS5wb3NpdGlvbi54KSwgKG90aGVyU3ByaXRlLnBvc2l0aW9uLnkgLSBAc3ByaXRlLnBvc2l0aW9uLnkpIClcclxuICAgICAgICB2ZWMuTm9ybWFsaXplKClcclxuICAgICAgICByZXR1cm4gdmVjXHJcblxyXG5jbGFzcyBPcmJpdFxyXG4gICAgc3ByaXRlOiBudWxsXHJcbiAgICBnYW1lOiBudWxsXHJcbiAgICBzcHJpdGVUb09yYml0OiBudWxsXHJcbiAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgb3JiaXRTcGVlZDogMFxyXG4gICAgb3JiaXRBbmdsZTogMFxyXG4gICAgb3JiaXRMZW5ndGg6IDBcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNwcml0ZSwgQHNwcml0ZVRvT3JiaXQsIEBvcmJpdFNwZWVkLCBAb3JiaXRMZW5ndGgpIC0+XHJcbiAgICAgICAgQGdhbWUgPSBAc3ByaXRlLmdhbWVcclxuXHJcbiAgICBVcGRhdGU6IC0+XHJcbiAgICAgICAgcmV0dXJuIGlmIG5vdCBAZW5hYmxlZFxyXG5cclxuICAgICAgICBAb3JiaXRBbmdsZSArPSBAb3JiaXRTcGVlZCAqIEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuXHJcbiAgICAgICAgQHNwcml0ZS5wb3NpdGlvbi54ID0gQG9yYml0TGVuZ3RoICogTWF0aC5jb3MoQG9yYml0QW5nbGUpICsgKCBAc3ByaXRlVG9PcmJpdC5wb3NpdGlvbi54ICsgQHNwcml0ZVRvT3JiaXQucmVjdGFuZ2xlLndpZHRoLzIgKVxyXG4gICAgICAgIEBzcHJpdGUucG9zaXRpb24ueSA9IEBvcmJpdExlbmd0aCAqIE1hdGguc2luKEBvcmJpdEFuZ2xlKSArICggQHNwcml0ZVRvT3JiaXQucG9zaXRpb24ueSArIEBzcHJpdGVUb09yYml0LnJlY3RhbmdsZS5oZWlnaHQvMiApXHJcblxyXG4gICAgR2V0U3RhcnRQb3NpdGlvbjogLT5cclxuICAgICAgICBzdGFydFggPSBAb3JiaXRMZW5ndGggKiBNYXRoLmNvcygwKSArICggQHNwcml0ZVRvT3JiaXQucG9zaXRpb24ueCArIEBzcHJpdGVUb09yYml0LnJlY3RhbmdsZS53aWR0aC8yIClcclxuICAgICAgICBzdGFydFkgPSBAb3JiaXRMZW5ndGggKiBNYXRoLnNpbigwKSArICggQHNwcml0ZVRvT3JiaXQucG9zaXRpb24ueSArIEBzcHJpdGVUb09yYml0LnJlY3RhbmdsZS5oZWlnaHQvMiApXHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKCBzdGFydFgsIHN0YXJ0WSApXHJcblxuY2xhc3MgU2l6ZU1hbmFnZXJcclxuICAgIHdpZHRoOiAwXHJcbiAgICBoZWlnaHQ6IDBcclxuICAgIHNjYWxlOiBudWxsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlKSAtPlxyXG4gICAgICAgIHJlY3QgPSBAc3ByaXRlLnJlY3RhbmdsZVxyXG4gICAgICAgIEB3aWR0aCA9IHJlY3Qud2lkdGhcclxuICAgICAgICBAaGVpZ2h0ID0gcmVjdC5oZWlnaHRcclxuICAgICAgICBAc2NhbGUgPSB7d2lkdGg6IDEsIGhlaWdodDogMX1cclxuXHJcbiAgICBVcGRhdGU6IC0+XHJcbiAgICAgICAgcmVjdCA9IEBzcHJpdGUucmVjdGFuZ2xlXHJcblxyXG4gICAgICAgIGlmIEBzcHJpdGUudG9yY2hfc2hhcGVcclxuICAgICAgICAgICAgcmVjdC53aWR0aCA9IEBzcHJpdGUud2lkdGhcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBAc3ByaXRlLmhlaWdodFxyXG5cclxuICAgIFNldDogKHdpZHRoLCBoZWlnaHQpIC0+XHJcbiAgICAgICAgQHdpZHRoID0gQHNwcml0ZS5yZWN0YW5nbGUud2lkdGggPSB3aWR0aCAqIEBzY2FsZS53aWR0aFxyXG4gICAgICAgIEBoZWlnaHQgPSBAc3ByaXRlLnJlY3RhbmdsZS5oZWlnaHQgPSBoZWlnaHQgKiBAc2NhbGUuaGVpZ2h0XHJcblxyXG4gICAgU2NhbGU6ICh3aWR0aFNjYWxlLCBoZWlnaHRTY2FsZSkgLT5cclxuICAgICAgICByZWN0ID0gQHNwcml0ZS5yZWN0YW5nbGVcclxuXHJcbiAgICAgICAgQHNjYWxlLndpZHRoID0gd2lkdGhTY2FsZVxyXG4gICAgICAgIEBzY2FsZS5oZWlnaHQgPSBoZWlnaHRTY2FsZVxyXG5cclxuICAgICAgICByZWN0LndpZHRoID0gQHdpZHRoICogQHNjYWxlLndpZHRoXHJcbiAgICAgICAgcmVjdC5oZWlnaHQgPSBAaGVpZ2h0ICogQHNjYWxlLmhlaWdodFxyXG5cbmNsYXNzIEV2ZW50TWFuYWdlclxyXG4gICAgbW91c2VPdmVyOiBmYWxzZVxyXG4gICAgY2xpY2tUcmlnZ2VyOiBmYWxzZVxyXG4gICAgY2xpY2tBd2F5VHJpZ2dlcjogZmFsc2VcclxuICAgIGRyYXc6IHRydWVcclxuICAgIHdhc0NsaWNrZWQ6IGZhbHNlXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlKSAtPlxyXG4gICAgICAgIEBnYW1lID0gQHNwcml0ZS5nYW1lXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGlmIG5vdCBAZ2FtZS5Nb3VzZS5HZXRSZWN0YW5nbGUoKS5JbnRlcnNlY3RzKEBzcHJpdGUucmVjdGFuZ2xlKSBhbmQgQG1vdXNlT3ZlclxyXG4gICAgICAgICAgICBAbW91c2VPdmVyID0gZmFsc2VcclxuICAgICAgICAgICAgQHNwcml0ZS5FbWl0KFwiTW91c2VMZWF2ZVwiLCBuZXcgVG9yY2guRXZlbnQoQGdhbWUsIHtzcHJpdGU6IEBzcHJpdGV9KSlcclxuXHJcbiAgICAgICAgaWYgQGdhbWUuTW91c2UuR2V0UmVjdGFuZ2xlKCkuSW50ZXJzZWN0cyhAc3ByaXRlLnJlY3RhbmdsZSlcclxuICAgICAgICAgICAgaWYgbm90IEBtb3VzZU92ZXJcclxuICAgICAgICAgICAgICAgIEBzcHJpdGUuRW1pdChcIk1vdXNlT3ZlclwiLCBuZXcgVG9yY2guRXZlbnQoQGdhbWUsIHtzcHJpdGU6IEBzcHJpdGV9KSlcclxuICAgICAgICAgICAgQG1vdXNlT3ZlciA9IHRydWVcclxuXHJcbiAgICAgICAgZWxzZSBpZiBAc3ByaXRlLmZpeGVkXHJcbiAgICAgICAgICAgIG1vdXNlUmVjID0gQGdhbWUuTW91c2UuR2V0UmVjdGFuZ2xlKClcclxuICAgICAgICAgICAgcmVDb21wdXRlZE1vdXNlUmVjID0gbmV3IFJlY3RhbmdsZShtb3VzZVJlYy54LCBtb3VzZVJlYy55LCBtb3VzZVJlYy53aWR0aCwgbW91c2VSZWMuaGVpZ2h0KVxyXG4gICAgICAgICAgICByZUNvbXB1dGVkTW91c2VSZWMueCArPSBAZ2FtZS5DYW1lcmEucG9zaXRpb24ueFxyXG4gICAgICAgICAgICByZUNvbXB1dGVkTW91c2VSZWMueSArPSBAZ2FtZS5DYW1lcmEucG9zaXRpb24ueVxyXG4gICAgICAgICAgICBpZiByZUNvbXB1dGVkTW91c2VSZWMuSW50ZXJzZWN0cyhAc3ByaXRlLnJlY3RhbmdsZSlcclxuICAgICAgICAgICAgICAgIEBtb3VzZU92ZXIgPSB0cnVlXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIEBtb3VzZU92ZXIgPSBmYWxzZVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgQG1vdXNlT3ZlciA9IGZhbHNlXHJcblxyXG4gICAgICAgIGlmIEBtb3VzZU92ZXIgYW5kIEBnYW1lLk1vdXNlLmRvd24gYW5kIG5vdCBAY2xpY2tUcmlnZ2VyXHJcbiAgICAgICAgICAgIEBjbGlja1RyaWdnZXIgPSB0cnVlXHJcbiAgICAgICAgICAgIEBzcHJpdGUuRW1pdCBcIk1vdXNlRG93blwiLCBuZXcgVG9yY2guRXZlbnQoIEBnYW1lLCBzcHJpdGU6IEBzcHJpdGUgKVxyXG5cclxuICAgICAgICBpZiBAY2xpY2tUcmlnZ2VyIGFuZCBub3QgQGdhbWUuTW91c2UuZG93biBhbmQgQG1vdXNlT3ZlclxyXG4gICAgICAgICAgICBAd2FzQ2xpY2tlZCA9IHRydWVcclxuXHJcbiAgICAgICAgICAgIEBzcHJpdGUuRW1pdCBcIk1vdXNlVXBcIiwgbmV3IFRvcmNoLkV2ZW50KCBAZ2FtZSwge3Nwcml0ZTogQHNwcml0ZX0gKVxyXG4gICAgICAgICAgICBAc3ByaXRlLkVtaXQgXCJDbGlja1wiLCBuZXcgVG9yY2guRXZlbnQoIEBnYW1lLCB7c3ByaXRlOiBAc3ByaXRlfSApXHJcblxyXG4gICAgICAgICAgICBAY2xpY2tUcmlnZ2VyID0gZmFsc2VcclxuXHJcbiAgICAgICAgaWYgQGNsaWNrVHJpZ2dlciBhbmQgbm90IEBnYW1lLk1vdXNlLmRvd24gYW5kIG5vdCBAbW91c2VPdmVyXHJcbiAgICAgICAgICAgIEBjbGlja1RyaWdnZXIgPSBmYWxzZVxyXG5cclxuICAgICAgICBpZiBub3QgQGdhbWUuTW91c2UuZG93biBhbmQgbm90IEBtb3VzZU92ZXIgYW5kIEBjbGlja0F3YXlUcmlnZ2VyXHJcbiAgICAgICAgICAgIEBzcHJpdGUuRW1pdChcIkNsaWNrQXdheVwiLCBuZXcgVG9yY2guRXZlbnQoQGdhbWUsIHtzcHJpdGU6IEBzcHJpdGV9KSlcclxuICAgICAgICAgICAgQHdhc0NsaWNrZWQgPSBmYWxzZVxyXG4gICAgICAgICAgICBAY2xpY2tBd2F5VHJpZ2dlciA9IGZhbHNlXHJcblxyXG4gICAgICAgIGVsc2UgaWYgQGNsaWNrVHJpZ2dlciBhbmQgbm90IEBnYW1lLk1vdXNlLmRvd24gYW5kIEBtb3VzZU92ZXJcclxuICAgICAgICAgICAgQGNsaWNrQXdheVRyaWdnZXIgPSBmYWxzZVxyXG5cclxuICAgICAgICBlbHNlIGlmIEBnYW1lLk1vdXNlLmRvd24gYW5kIG5vdCBAbW91c2VPdmVyXHJcbiAgICAgICAgICAgIEBjbGlja0F3YXlUcmlnZ2VyID0gdHJ1ZVxyXG5cbmNsYXNzIEVmZmVjdE1hbmFnZXJcclxuICAgIHRpbnQ6IG51bGxcclxuICAgIG1hc2s6IG51bGxcclxuICAgIGVmZmVjdHM6IG51bGxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzcHJpdGUpIC0+XHJcbiAgICAgICAgQGVmZmVjdHMgPSBbXVxyXG4gICAgICAgIEB0aW50ID0gbmV3IEVmZmVjdENvbXBvbmVudC5UaW50KClcclxuICAgICAgICBAbWFzayA9IG5ldyBFZmZlY3RDb21wb25lbnQuTWFzaygpXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIEBlZmZlY3RzID0gZm9yIGVmZmVjdCBpbiBAZWZmZWN0c1xyXG4gICAgICAgICAgICBlZmZlY3QuVXBkYXRlKClcclxuXHJcbiAgICAgICAgICAgIGVmZmVjdCBpZiBub3QgZWZmZWN0LnRyYXNoXHJcblxyXG4gICAgQmxpbms6IChpbnRlcnZhbCA9IDMwMCktPlxyXG4gICAgICAgIHQgPSBAc3ByaXRlLmdhbWUuVHdlZW5zLlR3ZWVuKEBzcHJpdGUsIGludGVydmFsLCBUb3JjaC5FYXNpbmcuU21vb3RoKS5Ubyggb3BhY2l0eTogMCApLkN5Y2xlKClcclxuICAgICAgICByZXR1cm4gdFxyXG5cclxuICAgIEZsYXNoOiAoY29sb3IgPSBcInJlZFwiLCB0aW1lID0gMTAwKSAtPlxyXG4gICAgICAgIEB0aW50LmNvbG9yID0gY29sb3JcclxuICAgICAgICB0ID0gQHNwcml0ZS5nYW1lLlR3ZWVucy5Ud2VlbiggQHRpbnQsIHRpbWUsIFRvcmNoLkVhc2luZy5TbW9vdGggKS5Gcm9tKG9wYWNpdHk6IDApLlRvKCBvcGFjaXR5OiAxIClcclxuICAgICAgICB0Lk9uIFwiRmluaXNoXCIsID0+XHJcbiAgICAgICAgICAgIHQyID0gQHNwcml0ZS5nYW1lLlR3ZWVucy5Ud2VlbiggQHRpbnQsIHRpbWUsIFRvcmNoLkVhc2luZy5TbW9vdGggKS5Ubyggb3BhY2l0eTogMCApXHJcbiAgICAgICAgICAgIHQyLk9uIFwiRmluaXNoXCIsID0+XHJcbiAgICAgICAgICAgICAgICBAdGludC5jb2xvciA9IG51bGxcclxuICAgICAgICAgICAgICAgIEB0aW50Lm9wYWNpdHkgPSAwLjVcclxuXHJcbiAgICBDcnVtcGxlOiAocmF0aW8sIHRpbWUpIC0+XHJcblxyXG4gICAgICAgIHRhcmdldEhlaWdodCA9IEBzcHJpdGUucmVjdGFuZ2xlLmhlaWdodCAqIHJhdGlvXHJcblxyXG4gICAgICAgIEBzcHJpdGUuZ2FtZS5Ud2VlbnMuVHdlZW4oIEBzcHJpdGUucmVjdGFuZ2xlLCB0aW1lLCBUb3JjaC5FYXNpbmcuU21vb3RoICkuVG8oIGhlaWdodDogdGFyZ2V0SGVpZ2h0IClcclxuXHJcbiAgICBTdHJldGNoOiAocmF0aW8sIHRpbWUpIC0+XHJcbiAgICAgICAgdGFyZ2V0V2lkdGggPSBAc3ByaXRlLnJlY3RhbmdsZS53aWR0aCAqIHJhdGlvXHJcblxyXG4gICAgICAgIEBzcHJpdGUuZ2FtZS5Ud2VlbnMuVHdlZW4oIEBzcHJpdGUucmVjdGFuZ2xlLCB0aW1lLCBUb3JjaC5FYXNpbmcuU21vb3RoICkuVG8oIHdpZHRoOiB0YXJnZXRXaWR0aCApXHJcblxyXG4gICAgU3F1aXJ0OiAocG9pbnQsIHRpbWUpIC0+XHJcbiAgICAgICAgb3JpZ1dpZHRoID0gQHNwcml0ZS5yZWN0YW5nbGUud2lkdGhcclxuICAgICAgICBvcmlnSGVpZ2h0ID0gQHNwcml0ZS5yZWN0YW5nbGUuaGVpZ2h0XHJcblxyXG4gICAgICAgIHdpZHRoRGlmZiA9IE1hdGguYWJzIChwb2ludC54IC0gQHNwcml0ZS5wb3NpdGlvbi54KVxyXG4gICAgICAgIGhlaWdodERpZmYgPSBNYXRoLmFicyAocG9pbnQueSAtIEBzcHJpdGUucG9zaXRpb24ueSlcclxuXHJcbiAgICAgICAgaWYgd2lkdGhEaWZmID4gMFxyXG4gICAgICAgICAgICBAc3ByaXRlLmdhbWUuVHdlZW5zLlR3ZWVuKCBAc3ByaXRlLnJlY3RhbmdsZSwgdGltZSwgVG9yY2guRWFzaW5nLlNtb290aCApLlRvKCB3aWR0aDogd2lkdGhEaWZmIClcclxuXHJcbiAgICAgICAgaWYgaGVpZ2h0RGlmZiA+IDBcclxuICAgICAgICAgICAgQHNwcml0ZS5nYW1lLlR3ZWVucy5Ud2VlbiggQHNwcml0ZS5yZWN0YW5nbGUsIHRpbWUsIFRvcmNoLkVhc2luZy5TbW9vdGggKS5UbyggaGVpZ2h0OiBoZWlnaHREaWZmIClcclxuXHJcbiAgICAgICAgdHdlZW4gPSBAc3ByaXRlLmdhbWUuVHdlZW5zLlR3ZWVuKCBAc3ByaXRlLnBvc2l0aW9uLCB0aW1lLCBUb3JjaC5FYXNpbmcuU21vb3RoICkuVG8oIHg6IHBvaW50LngsIHk6IHBvaW50LnkgKVxyXG5cclxuICAgICAgICB0d2Vlbi5PbiBcIkZpbmlzaFwiLCA9PlxyXG4gICAgICAgICAgICBAc3ByaXRlLmdhbWUuVHdlZW5zLlR3ZWVuKCBAc3ByaXRlLnJlY3RhbmdsZSwgdGltZSwgVG9yY2guRWFzaW5nLlNtb290aCApLlRvKCB3aWR0aDogb3JpZ1dpZHRoLCBoZWlnaHQ6IG9yaWdIZWlnaHQgKVxyXG5cclxuICAgIFRyYWlsOiAoKSAtPlxyXG4gICAgICAgIEBlZmZlY3RzLnB1c2goIG5ldyBUcmFpbEVmZmVjdChAc3ByaXRlKSApXHJcblxyXG4jIGEgYnVuY2ggb2YgbGl0dGxlIGVmZmVjdHMgY29udGFpbmVyc1xyXG5FZmZlY3RDb21wb25lbnQgPSB7fVxyXG5cclxuY2xhc3MgRWZmZWN0Q29tcG9uZW50LlRpbnRcclxuICAgIF9jb2xvcjogbnVsbFxyXG4gICAgX29wYWNpdHk6IDAuNVxyXG5cclxuICAgIEBwcm9wZXJ0eSAnY29sb3InLFxyXG4gICAgICAgIGdldDogLT4gcmV0dXJuIEBfY29sb3JcclxuICAgICAgICBzZXQ6ICh2YWx1ZSkgLT4gQF9jb2xvciA9IHZhbHVlXHJcblxyXG4gICAgQHByb3BlcnR5ICdvcGFjaXR5JyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX29wYWNpdHlcclxuICAgICAgICBzZXQ6ICh2YWx1ZSkgLT4gQF9vcGFjaXR5ID0gdmFsdWVcclxuXHJcbmNsYXNzIEVmZmVjdENvbXBvbmVudC5NYXNrXHJcbiAgICBfdGV4dHVyZTogbnVsbFxyXG4gICAgX2luOiBmYWxzZVxyXG4gICAgX291dDogZmFsc2VcclxuICAgICMgZGVzdGluYXRpb24taW4sIGRlc3RpbmF0aW9uLW91dFxyXG4gICAgQHByb3BlcnR5ICd0ZXh0dXJlJyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX3RleHR1cmVcclxuICAgICAgICBzZXQ6ICh2YWx1ZSkgLT4gQF90ZXh0dXJlID0gdmFsdWVcclxuXHJcbiAgICBAcHJvcGVydHkgJ2luJyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX2luXHJcbiAgICAgICAgc2V0OiAodmFsdWUpIC0+IEBfaW4gPSB2YWx1ZVxyXG5cclxuICAgIEBwcm9wZXJ0eSAnb3V0JyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX291dFxyXG4gICAgICAgIHNldDogKHZhbHVlKSAtPiBAX291dCA9IHZhbHVlXHJcblxyXG4jIGVmZmVjdHNcclxuY2xhc3MgVHJhaWxFZmZlY3RcclxuICAgIGZhZGVUaW1lOiAyMDBcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNwcml0ZSkgLT5cclxuXHJcbiAgICBVcGRhdGU6IC0+XHJcbiAgICAgICAgdCA9IG5ldyBTcHJpdGUoQHNwcml0ZS5nYW1lLCBAc3ByaXRlLnBvc2l0aW9uLngsIEBzcHJpdGUucG9zaXRpb24ueSlcclxuICAgICAgICB0LkJpbmQuVGV4dHVyZShAc3ByaXRlLnRleHR1cmUuaW1hZ2UpXHJcbiAgICAgICAgdC5TaXplLlNjYWxlKDEsMSlcclxuICAgICAgICB0LmRyYXdJbmRleCA9IEBzcHJpdGUuZHJhd0luZGV4IC0gMVxyXG4gICAgICAgIHQucm90YXRpb24gPSBAc3ByaXRlLnJvdGF0aW9uXHJcblxyXG4gICAgICAgIEBzcHJpdGUuZ2FtZS5Ud2VlbnMuVHdlZW4oIHQsIEBmYWRlVGltZSwgVG9yY2guRWFzaW5nLlNtb290aCApXHJcbiAgICAgICAgLkZyb20oIG9wYWNpdHk6IDAuMiApXHJcbiAgICAgICAgLlRvKCBvcGFjaXR5OiAwICkuT24gXCJGaW5pc2hcIiwgPT5cclxuICAgICAgICAgICAgdC5UcmFzaCgpXHJcblxuY2xhc3MgU3RhdGVNYWNoaW5lTWFuYWdlclxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlKSAtPlxyXG4gICAgICAgIEBzdGF0ZU1hY2hpbmVzID0ge31cclxuXHJcbiAgICBDcmVhdGVTdGF0ZU1hY2hpbmU6IChuYW1lKSAtPlxyXG4gICAgICAgIEBzdGF0ZU1hY2hpbmVzW25hbWVdID0gbmV3IFN0YXRlTWFjaGluZShAc3ByaXRlKVxyXG4gICAgICAgIHJldHVybiBAc3RhdGVNYWNoaW5lc1tuYW1lXVxyXG5cclxuICAgIEdldFN0YXRlTWFjaGluZTogKG5hbWUpIC0+XHJcbiAgICAgICAgcmV0dXJuIEBzdGF0ZU1hY2hpbmVzW25hbWVdXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGZvciBrZXksc20gb2YgQHN0YXRlTWFjaGluZXNcclxuICAgICAgICAgICAgc20uVXBkYXRlKClcclxuXG4jIyNcclxuICAgIEBjbGFzcyBHcmlkTWFuYWdlclxyXG5cclxuICAgIE1hbmFnZXMgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHNwcml0ZXNcclxuIyMjXHJcbmNsYXNzIEdyaWRNYW5hZ2VyXHJcbiAgICBwYXJlbnQ6IG51bGxcclxuICAgIGNoaWxkcmVuOiBudWxsXHJcblxyXG4gICAgY2VudGVyZWQ6IGZhbHNlXHJcbiAgICBjZW50ZXJWZXJ0aWNhbDogZmFsc2VcclxuXHJcbiAgICBhbGlnbkxlZnQ6IGZhbHNlXHJcbiAgICBhbGlnblJpZ2h0OiBmYWxzZVxyXG4gICAgYWxpZ25Ub3A6IGZhbHNlXHJcbiAgICBhbGlnbkJvdHRvbTogZmFsc2VcclxuXHJcbiAgICBtYXJnaW46IG51bGxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzcHJpdGUpIC0+XHJcbiAgICAgICAgQHBvc2l0aW9uID0gbmV3IFBvaW50KDAsMClcclxuICAgICAgICBAY2hpbGRyZW4gPSBbXVxyXG4gICAgICAgIEBtYXJnaW4gPVxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgICAgIHRvcDogMFxyXG5cclxuICAgIEFsaWduOiAocG9zaXRpb25UYWdzLi4uKSAtPlxyXG4gICAgICAgIGZvciB0YWcgaW4gcG9zaXRpb25UYWdzXHJcbiAgICAgICAgICAgIHN3aXRjaCB0YWdcclxuICAgICAgICAgICAgICAgIHdoZW4gXCJsZWZ0XCJcclxuICAgICAgICAgICAgICAgICAgICBAYWxpZ25MZWZ0ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgd2hlbiBcInJpZ2h0XCJcclxuICAgICAgICAgICAgICAgICAgICBAYWxpZ25SaWdodCA9IHRydWVcclxuICAgICAgICAgICAgICAgIHdoZW4gXCJ0b3BcIlxyXG4gICAgICAgICAgICAgICAgICAgIEBhbGlnblRvcCA9IHRydWVcclxuICAgICAgICAgICAgICAgIHdoZW4gXCJib3R0b21cIlxyXG4gICAgICAgICAgICAgICAgICAgIEBhbGlnbkJvdHRvbSA9IHRydWVcclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuICAgIENlbnRlcjogKHR1cm5PbiA9IHRydWUpLT5cclxuICAgICAgICBAY2VudGVyZWQgPSB0dXJuT25cclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuICAgIENlbnRlclZlcnRpY2FsOiAodHVybk9uID0gdHJ1ZSktPlxyXG4gICAgICAgIEBjZW50ZXJWZXJ0aWNhbCA9IHR1cm5PblxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgTWFyZ2luOiAobGVmdCA9IDAsIHRvcCA9IDApIC0+XHJcbiAgICAgICAgQG1hcmdpbi5sZWZ0ID0gbGVmdFxyXG4gICAgICAgIEBtYXJnaW4udG9wID0gdG9wXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbiAgICBBcHBlbmQ6IChzcHJpdGUpIC0+XHJcbiAgICAgICAgc3ByaXRlLkdyaWQucGFyZW50ID0gQHNwcml0ZVxyXG4gICAgICAgIHNwcml0ZS5kcmF3SW5kZXggPSBAc3ByaXRlLmRyYXdJbmRleCArIDFcclxuICAgICAgICBzcHJpdGUuZml4ZWQgPSBAc3ByaXRlLmZpeGVkXHJcblxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgUGFyZW50OiAtPlxyXG4gICAgICAgIHJldHVybiBAcGFyZW50XHJcblxyXG4gICAgQ2hpbGRyZW46IChtYXRjaGVyKSAtPlxyXG4gICAgICAgIHJldHVybiBAY2hpbGRyZW4gaWYgbm90IG1hdGNoZXJcclxuXHJcbiAgICAgICAgY2hpbGRyZW4gPSBbXVxyXG5cclxuICAgICAgICBmb3IgY2hpbGQgaW4gQGNoaWxkcmVuXHJcbiAgICAgICAgICAgIG1hdGNoaW5nID0gdHJ1ZVxyXG4gICAgICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIG1hdGNoZXJcclxuICAgICAgICAgICAgICAgIGlmIG5vdCBjaGlsZFtrZXldIGlzIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcgPSBmYWxzZVxyXG5cclxuICAgICAgICAgICAgY2hpbGRyZW4uYXBwZW5kKGNoaWxkKSBpZiBtYXRjaGluZ1xyXG5cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW5cclxuXHJcbiAgICBBbmNlc3RvcnM6IChtYXRjaGVyKSAtPlxyXG4gICAgICAgIHJldHVybiBudWxsIGlmIG5vdCBAcGFyZW50XHJcbiAgICAgICAgYW5jZXN0b3JzID0gW11cclxuXHJcbiAgICAgICAgYW5jZXN0b3IgPSBAcGFyZW50XHJcblxyXG4gICAgICAgIHdoaWxlIGFuY2VzdG9yLlBhcmVudCgpIGlzbnQgbnVsbFxyXG4gICAgICAgICAgICBpZiBub3QgbWF0Y2hlclxyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIG1hdGNoZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiBhbmNlc3RvcltrZXldIGlzbnQgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnMucHVzaChhbmNlc3RvcikgaWYgbWF0Y2hlZFxyXG5cclxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5QYXJlbnQoKVxyXG5cclxuICAgIEFwcGx5Q2VudGVyaW5nOiAocG9pbnQpIC0+XHJcbiAgICAgICAgaWYgQGNlbnRlcmVkXHJcbiAgICAgICAgICAgIHBvaW50LnggPSAocG9pbnQueCArIEBwYXJlbnQucmVjdGFuZ2xlLndpZHRoIC8gMikgLSAoQHNwcml0ZS5yZWN0YW5nbGUud2lkdGggLyAyKVxyXG5cclxuICAgICAgICBpZiBAY2VudGVyVmVydGljYWxcclxuICAgICAgICAgICAgcG9pbnQueSA9IChwb2ludC55ICsgQHBhcmVudC5yZWN0YW5nbGUuaGVpZ2h0IC8gMikgLSAoQHNwcml0ZS5yZWN0YW5nbGUuaGVpZ2h0IC8gMilcclxuXHJcbiAgICAgICAgcmV0dXJuIHBvaW50XHJcblxyXG4gICAgQXBwbHlBbGlnbm1lbnQ6IChwb2ludCkgLT5cclxuICAgICAgICBpZiBAYWxpZ25MZWZ0XHJcbiAgICAgICAgICAgIHBvaW50LnggPSAwXHJcbiAgICAgICAgaWYgQGFsaWduUmlnaHRcclxuICAgICAgICAgICAgcG9pbnQueCA9IHBvaW50LnggKyAoQHBhcmVudC5yZWN0YW5nbGUud2lkdGggLSBAc3ByaXRlLnJlY3RhbmdsZS53aWR0aClcclxuICAgICAgICBpZiBAYWxpZ25Ub3BcclxuICAgICAgICAgICAgcG9pbnQueSA9IDBcclxuICAgICAgICBpZiBAYWxpZ25Cb3R0b21cclxuICAgICAgICAgICAgcG9pbnQueSA9IHBvaW50LnkgKyAoQHBhcmVudC5yZWN0YW5nbGUuaGVpZ2h0IC0gQHNwcml0ZS5yZWN0YW5nbGUuaGVpZ2h0KVxyXG5cclxuICAgICAgICByZXR1cm4gcG9pbnRcclxuXHJcbiAgICBSZXNvbHZlQWJvc29sdXRlUG9zaXRpb246IC0+XHJcbiAgICAgICAgaWYgQHBhcmVudCBpcyBudWxsXHJcbiAgICAgICAgICAgIHJldHVybiBAc3ByaXRlLnBvc2l0aW9uXHJcblxyXG4gICAgICAgIGJhc2VQb2ludCA9IEBwYXJlbnQucG9zaXRpb24uQ2xvbmUoKVxyXG5cclxuICAgICAgICBiYXNlUG9pbnQgPSBAQXBwbHlDZW50ZXJpbmcoYmFzZVBvaW50KVxyXG4gICAgICAgIGJhc2VQb2ludCA9IEBBcHBseUFsaWdubWVudChiYXNlUG9pbnQpXHJcbiAgICAgICAgYmFzZVBvaW50LnggKz0gQHBvc2l0aW9uLnhcclxuICAgICAgICBiYXNlUG9pbnQueSArPSBAcG9zaXRpb24ueVxyXG5cclxuICAgICAgICBiYXNlUG9pbnQueCArPSBAbWFyZ2luLmxlZnRcclxuICAgICAgICBiYXNlUG9pbnQueSArPSBAbWFyZ2luLnRvcFxyXG5cclxuICAgICAgICByZXR1cm4gYmFzZVBvaW50O1xyXG5cclxuICAgIFVwZGF0ZTogLT5cclxuICAgICAgICBAc3ByaXRlLnBvc2l0aW9uID0gQFJlc29sdmVBYm9zb2x1dGVQb3NpdGlvbigpXHJcbiAgICAgICAgaWYgQHBhcmVudCBpc250IG51bGxcclxuICAgICAgICAgICAgQHNwcml0ZS5kcmF3SW5kZXggPSBAcGFyZW50LmRyYXdJbmRleCArIDFcclxuICAgICAgICAgICAgQHNwcml0ZS5maXhlZCA9IEBwYXJlbnQuZml4ZWRcclxuXG5jbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBUcmFzaGFibGVcclxuICAgIEBNaXhJbiBUcmFzaGFibGVcclxuICAgIEBNaXhJbiBFdmVudERpc3BhdGNoZXJcclxuXHJcbiAgICBsb29wOiBmYWxzZVxyXG4gICAgc3RvcHBlZDogZmFsc2VcclxuICAgIGludGVydmFsVGltZTogMFxyXG4gICAgc3RlcFRpbWU6IDBcclxuICAgIGNvbnN0cnVjdG9yOiAtPlxyXG4gICAgICAgIEBJbml0RXZlbnREaXNwYXRjaCgpXHJcblxyXG4gICAgTG9vcDogLT5cclxuICAgICAgICBAbG9vcCA9IHRydWVcclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuXHJcbmNsYXNzIEFuaW1hdGlvbk1hbmFnZXJcclxuICAgIGFuaW1hdGlvbnM6IG51bGxcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNwcml0ZSkgLT5cclxuICAgICAgICBAYW5pbWF0aW9ucyA9IFtdXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGNsZWFuZWRBbmltcyA9IFtdXHJcbiAgICAgICAgZm9yIGFuaW0gaW4gQGFuaW1hdGlvbnNcclxuICAgICAgICAgICAgYW5pbS5VcGRhdGUoKVxyXG4gICAgICAgICAgICBjbGVhbmVkQW5pbXMucHVzaChhbmltKSBpZiBub3QgYW5pbS50cmFzaFxyXG4gICAgICAgIEBhbmltYXRpb25zID0gY2xlYW5lZEFuaW1zXHJcblxyXG4gICAgU3ByaXRlU2hlZXQ6ICh3aWR0aCwgaGVpZ2h0LCBudW1iZXJPZkZyYW1lcywgY29uZmlnID0ge3N0ZXA6IDIwMH0pIC0+XHJcbiAgICAgICAgYW5pbSA9IG5ldyBTcHJpdGVTaGVldEFuaW1hdGlvbihAc3ByaXRlLCB3aWR0aCwgaGVpZ2h0LCBudW1iZXJPZkZyYW1lcywgY29uZmlnLnN0ZXApXHJcbiAgICAgICAgQGFuaW1hdGlvbnMucHVzaCggYW5pbSApXHJcbiAgICAgICAgcmV0dXJuIGFuaW1cclxuXHJcbiAgICBBdGxhc0ZyYW1lOiAoYXRsYXNJZCwgdGV4dHVyZUlkLCBmcmFtZXMsIGNvbmZpZyA9IHtzdGVwOiAyMDB9KSAtPlxyXG4gICAgICAgIGFuaW0gPSBuZXcgQXRsYXNGcmFtZUFuaW1hdGlvbihAc3ByaXRlLCBhdGxhc0lkLCB0ZXh0dXJlSWQsIGZyYW1lcywgY29uZmlnLnN0ZXApXHJcbiAgICAgICAgQGFuaW1hdGlvbnMucHVzaCggYW5pbSApXHJcbiAgICAgICAgcmV0dXJuIGFuaW1cclxuXHJcbmNsYXNzIFNwcml0ZVNoZWV0QW5pbWF0aW9uIGV4dGVuZHMgQW5pbWF0aW9uXHJcbiAgICBpbmRleDogLTFcclxuICAgIGNsaXBYOiAwXHJcbiAgICBjbGlwWTogMFxyXG4gICAgZ2FtZTogbnVsbFxyXG4gICAgY2xpcFdpZHRoOiBudWxsXHJcbiAgICBjbGlwSGVpZ2h0OiBudWxsXHJcbiAgICBudW1iZXJPZkZyYW1lczogbnVsbFxyXG4gICAgc3RlcFRpbWU6IG51bGxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzcHJpdGUsIEBjbGlwV2lkdGgsIEBjbGlwSGVpZ2h0LCBAbnVtYmVyT2ZGcmFtZXMsIEBzdGVwVGltZSkgLT5cclxuICAgICAgICBzdXBlcigpXHJcbiAgICAgICAgQGxvb3AgPSB0cnVlXHJcbiAgICAgICAgQGdhbWUgPSBAc3ByaXRlLmdhbWVcclxuICAgICAgICBAUmVzZXQoKVxyXG5cclxuICAgIFVwZGF0ZTogLT5cclxuICAgICAgICByZXR1cm4gaWYgQHN0b3BwZWRcclxuICAgICAgICBAaW50ZXJ2YWxUaW1lICs9IEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuXHJcbiAgICAgICAgaWYgQGludGVydmFsVGltZSA+PSBAc3RlcFRpbWVcclxuICAgICAgICAgICAgQEFkdmFuY2VGcmFtZSgpXHJcblxyXG4gICAgQWR2YW5jZUZyYW1lOiAtPlxyXG4gICAgICAgIEBpbnRlcnZhbFRpbWUgPSAwXHJcbiAgICAgICAgQGluZGV4ICs9IDFcclxuXHJcbiAgICAgICAgQHNwcml0ZS50ZXh0dXJlLmRyYXdQYXJhbXMuY2xpcFggPSBAaW5kZXggKiBAY2xpcFdpZHRoXHJcblxyXG4gICAgICAgIGlmIEBpbmRleCA+PSBAbnVtYmVyT2ZGcmFtZXMgLSAxXHJcblxyXG4gICAgICAgICAgICBpZiBAbG9vcFxyXG4gICAgICAgICAgICAgICAgQGluZGV4ID0gLTFcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgQFRyYXNoKClcclxuXHJcbiAgICBTdG9wOiAtPlxyXG4gICAgICAgIEBzdG9wcGVkID0gdHJ1ZVxyXG5cclxuICAgIFN0YXJ0OiAtPlxyXG4gICAgICAgIEBzdG9wcGVkID0gZmFsc2VcclxuXHJcbiAgICBJbmRleDogKGluZGV4KSAtPlxyXG4gICAgICAgIEBpbmRleCA9IGluZGV4IC0gMVxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBYID0gKCBAaW5kZXggKyAxKSAqIEBjbGlwV2lkdGhcclxuXHJcbiAgICBSZXNldDogLT5cclxuICAgICAgICBAaW50ZXJ2YWxUaW1lID0gMFxyXG4gICAgICAgIEBpbmRleCA9IC0xXHJcblxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBYID0gMFxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBZID0gMFxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBXaWR0aCA9IEBjbGlwV2lkdGhcclxuICAgICAgICBAc3ByaXRlLnRleHR1cmUuZHJhd1BhcmFtcy5jbGlwSGVpZ2h0ID0gQGNsaXBIZWlnaHRcclxuICAgICAgICBAc3ByaXRlLlNpemUud2lkdGggPSBAY2xpcFdpZHRoXHJcbiAgICAgICAgQHNwcml0ZS5TaXplLmhlaWdodCA9IEBjbGlwSGVpZ2h0XHJcblxyXG4gICAgU3luY0ZyYW1lOiAtPlxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBYID0gMFxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBZID0gMFxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBXaWR0aCA9IEBjbGlwV2lkdGhcclxuICAgICAgICBAc3ByaXRlLnRleHR1cmUuZHJhd1BhcmFtcy5jbGlwSGVpZ2h0ID0gQGNsaXBIZWlnaHRcclxuICAgICAgICBAc3ByaXRlLlNpemUud2lkdGggPSBAY2xpcFdpZHRoXHJcbiAgICAgICAgQHNwcml0ZS5TaXplLmhlaWdodCA9IEBjbGlwSGVpZ2h0XHJcblxyXG5jbGFzcyBBdGxhc0ZyYW1lQW5pbWF0aW9uIGV4dGVuZHMgQW5pbWF0aW9uXHJcbiAgICBpbmRleDogMFxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlLCBAYXRsYXNJZCwgQHRleHR1cmVJZCwgQGZyYW1lcywgQHN0ZXBUaW1lKSAtPlxyXG4gICAgICAgIHN1cGVyKClcclxuICAgICAgICBAZ2FtZSA9IEBzcHJpdGUuZ2FtZVxyXG4gICAgICAgIEBudW1iZXJPZkZyYW1lcyA9IEBmcmFtZXMubGVuZ3RoXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIHJldHVybiBpZiBAc3RvcHBlZFxyXG4gICAgICAgIEBpbnRlcnZhbFRpbWUgKz0gQGdhbWUuTG9vcC51cGRhdGVEZWx0YVxyXG5cclxuICAgICAgICBpZiBAaW50ZXJ2YWxUaW1lID49IEBzdGVwVGltZVxyXG4gICAgICAgICAgICBAQWR2YW5jZUZyYW1lKClcclxuXHJcbiAgICBBZHZhbmNlRnJhbWU6IC0+XHJcbiAgICAgICAgQGludGVydmFsVGltZSA9IDBcclxuICAgICAgICBAaW5kZXggKz0gMVxyXG5cclxuICAgICAgICBAc3ByaXRlLkJpbmQuQXRsYXMoIEBhdGxhc0lkLCBAdGV4dHVyZUlkLCBAZnJhbWVzW0BpbmRleF0gKVxyXG5cclxuICAgICAgICBpZiBAaW5kZXggPj0gQG51bWJlck9mRnJhbWVzIC0gMVxyXG5cclxuICAgICAgICAgICAgaWYgQGxvb3BcclxuICAgICAgICAgICAgICAgIEBpbmRleCA9IDBcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgQEVtaXQgXCJGaW5pc2hcIiwgbmV3IFRvcmNoLkV2ZW50KEBnYW1lLCB7YW5pbWF0aW9uOiBAfSlcclxuICAgICAgICAgICAgICAgIEBUcmFzaCgpXHJcblxuY2xhc3MgQmluZE1hbmFnZXJcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNwcml0ZSkgLT5cclxuXHJcbiAgICBUZXh0dXJlOiAodGV4dHVyZUlkLCBvcHRpb25hbFBhcmFtZXRlcnMpIC0+XHJcbiAgICAgICAgdGV4ID0gbnVsbFxyXG5cclxuICAgICAgICAjIGNoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZyBvciBvYmplY3RcclxuICAgICAgICB0ZXh0dXJlSWRUeXBlID0gVXRpbC5UeXBlKHRleHR1cmVJZClcclxuXHJcbiAgICAgICAgaWYgdGV4dHVyZUlkVHlwZSBpcyBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICMgZmV0Y2ggYSBwcmUtbG9hZGVkIHRleHR1cmVcclxuICAgICAgICAgICAgcmF3SW1hZ2UgPSBAc3ByaXRlLmdhbWUuQXNzZXRzLkdldFRleHR1cmUodGV4dHVyZUlkKVxyXG4gICAgICAgICAgICB0ZXggPSBuZXcgVGV4dHVyZSggcmF3SW1hZ2UgKVxyXG5cclxuICAgICAgICBlbHNlIGlmIHRleHR1cmVJZFR5cGUgaXMgXCJvYmplY3RcIlxyXG4gICAgICAgICAgICAjIGJpbmQgdGV4dHVyZSBkaXJlY3RseVxyXG4gICAgICAgICAgICB0ZXggPSBuZXcgVGV4dHVyZSggdGV4dHVyZUlkIClcclxuXHJcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRVIuQXJndW1lbnRFcnJvcihcInRleHR1cmVJZFwiLCB0ZXh0dXJlSWQsIFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSlcclxuXHJcbiAgICAgICAgQHNwcml0ZS5TaXplLlNldCh0ZXgud2lkdGgsIHRleC5oZWlnaHQpXHJcbiAgICAgICAgQHNwcml0ZS50ZXh0dXJlID0gdGV4XHJcblxyXG4gICAgVmlkZW86ICh2aWRlb0lkKSAtPlxyXG4gICAgICAgIHZpZGVvID0gbnVsbFxyXG5cclxuICAgICAgICAjIGNoZWNrIGZvciBhIHN0cmluZyBvciBvYmplY3RcclxuICAgICAgICB2aWRlb0lkVHlwZSA9IFV0aWwuVHlwZSh2aWRlb0lkKVxyXG5cclxuICAgICAgICBpZiB2aWRlb0lkVHlwZSBpcyBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICMgZmV0Y2ggYSBwcmUtbG9hZGVkIHZpZGVvXHJcbiAgICAgICAgICAgIHJhd1ZpZGVvID0gQHNwcml0ZS5nYW1lLkFzc2V0cy5HZXRWaWRlbyh2aWRlb0lkKVxyXG4gICAgICAgICAgICB2aWRlbyA9IG5ldyBWaWRlbyggcmF3VmlkZW8gKVxyXG5cclxuICAgICAgICBlbHNlIGlmIHZpZGVvSWRUeXBlIGlzIFwib2JqZWN0XCJcclxuICAgICAgICAgICAgdmlkZW8gPSBuZXcgVmlkZW8oIHJhd1ZpZGVvIClcclxuXHJcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRVIuQXJndW1lbnRFcnJvciggXCJ2aWRlb0lkXCIsIHZpZGVvSWQsIFtcInN0cmluZ1wiLCBcIm9iamVjdFwiXSApXHJcblxyXG4gICAgICAgIEBzcHJpdGUudmlkZW8gPSB2aWRlb1xyXG4gICAgICAgIEBzcHJpdGUuU2l6ZS5TZXQodmlkZW8ud2lkdGgsIHZpZGVvLmhlaWdodClcclxuXHJcbiAgICBBdGxhczogKHRleHR1cmVJZCwgdGV4dHVyZUF0bGFzSWQsIHRleHR1cmVOYW1lKSAtPlxyXG4gICAgICAgICMgc2V0IGl0IHRvIHRoZSB0ZXh0dXJlIHRoZSBhdGxhcyBpcyBtYXBwZWQgYWdhaW5zdFxyXG4gICAgICAgIEBUZXh0dXJlKHRleHR1cmVJZClcclxuXHJcbiAgICAgICAgI2dyYWIgdGhlIGF0bGFzXHJcbiAgICAgICAgdGV4dHVyZUF0bGFzID0gQHNwcml0ZS5nYW1lLkFzc2V0cy5HZXRUZXh0dXJlQXRsYXModGV4dHVyZUF0bGFzSWQpXHJcblxyXG4gICAgICAgIGF0bGFzSXRlbSA9IHRleHR1cmVBdGxhcy50ZXh0dXJlc1t0ZXh0dXJlTmFtZV1cclxuXHJcbiAgICAgICAgIyBzZXQgdGhlIGNsaXAgcHJvcGVydGllc1xyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBYID0gYXRsYXNJdGVtLnhcclxuICAgICAgICBAc3ByaXRlLnRleHR1cmUuZHJhd1BhcmFtcy5jbGlwWSA9IGF0bGFzSXRlbS55XHJcblxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBXaWR0aCA9IGF0bGFzSXRlbS53aWR0aFxyXG4gICAgICAgIEBzcHJpdGUudGV4dHVyZS5kcmF3UGFyYW1zLmNsaXBIZWlnaHQgPSBhdGxhc0l0ZW0uaGVpZ2h0XHJcblxyXG4gICAgICAgICMgc2V0IHRoZSBzcHJpdGUgd2lkdGhcclxuICAgICAgICBAc3ByaXRlLlNpemUuU2V0KGF0bGFzSXRlbS53aWR0aCwgYXRsYXNJdGVtLmhlaWdodClcclxuXG5jbGFzcyBDYW52YXNSZW5kZXJlclxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlKSAtPlxyXG4gICAgICAgIEBnYW1lID0gQHNwcml0ZS5nYW1lXHJcbiAgICAgICAgQHByZXZpb3VzUG9zaXRpb24gPSBuZXcgUG9pbnQoQHNwcml0ZS5wb3NpdGlvbi54LCBAc3ByaXRlLnBvc2l0aW9uLnkpXHJcbiAgICBEcmF3OiAtPlxyXG4gICAgICAgIGRyYXdSZWMgPSBuZXcgUmVjdGFuZ2xlKEBzcHJpdGUucG9zaXRpb24ueCwgQHNwcml0ZS5wb3NpdGlvbi55LCBAc3ByaXRlLnJlY3RhbmdsZS53aWR0aCwgQHNwcml0ZS5yZWN0YW5nbGUuaGVpZ2h0KVxyXG5cclxuICAgICAgICBkcmF3UmVjLnggPSAoIEBzcHJpdGUucG9zaXRpb24ueCAtIEBwcmV2aW91c1Bvc2l0aW9uLnggKSAqIEBnYW1lLkxvb3AubGFnT2Zmc2V0ICsgQHByZXZpb3VzUG9zaXRpb24ueFxyXG4gICAgICAgIGRyYXdSZWMueSA9ICggQHNwcml0ZS5wb3NpdGlvbi55IC0gQHByZXZpb3VzUG9zaXRpb24ueSApICogQGdhbWUuTG9vcC5sYWdPZmZzZXQgKyBAcHJldmlvdXNQb3NpdGlvbi55XHJcbiAgICAgICAgQHByZXZpb3VzUG9zaXRpb24gPSBuZXcgUG9pbnQoQHNwcml0ZS5wb3NpdGlvbi54LCBAc3ByaXRlLnBvc2l0aW9uLnkpXHJcblxyXG4gICAgICAgIGNhbWVyYVRyYW5zZm9ybSA9IG5ldyBQb2ludCgwLDApXHJcblxyXG4gICAgICAgIGlmIG5vdCBAc3ByaXRlLmZpeGVkXHJcbiAgICAgICAgICAgIGRyYXdSZWMueCArPSBAZ2FtZS5DYW1lcmEucG9zaXRpb24ueCArIEBnYW1lLkhvb2tzLnBvc2l0aW9uVHJhbnNmb3JtLnhcclxuICAgICAgICAgICAgZHJhd1JlYy55ICs9IEBnYW1lLkNhbWVyYS5wb3NpdGlvbi55ICsgQGdhbWUuSG9va3MucG9zaXRpb25UcmFuc2Zvcm0ueVxyXG5cclxuICAgICAgICAjIHdlIG5lZWQgdG8gcnVuIHRoZSBhYm92ZSBsb2dpYyBldmVuIGlmIHdlIGFyZW4ndCBcImRyYXdpbmdcIiB0aGUgc3ByaXRlXHJcbiAgICAgICAgcmV0dXJuIGlmIG5vdCBAc3ByaXRlLmRyYXdcclxuICAgICAgICBzd2l0Y2ggQHNwcml0ZS50b3JjaF9yZW5kZXJfdHlwZVxyXG4gICAgICAgICAgICB3aGVuIFwiSW1hZ2VcIlxyXG4gICAgICAgICAgICAgICAgQFJlbmRlckltYWdlU3ByaXRlKGRyYXdSZWMpXHJcbiAgICAgICAgICAgIHdoZW4gXCJMaW5lXCJcclxuICAgICAgICAgICAgICAgIEBSZW5kZXJMaW5lU3ByaXRlKGRyYXdSZWMpXHJcbiAgICAgICAgICAgIHdoZW4gXCJCb3hcIlxyXG4gICAgICAgICAgICAgICAgQFJlbmRlckJveFNwcml0ZShkcmF3UmVjKVxyXG4gICAgICAgICAgICB3aGVuIFwiQ2lyY2xlXCJcclxuICAgICAgICAgICAgICAgIEBSZW5kZXJDaXJjbGVTcHJpdGUoZHJhd1JlYylcclxuICAgICAgICAgICAgd2hlbiBcIlBvbHlnb25cIlxyXG4gICAgICAgICAgICAgICAgQFJlbmRlclBvbHlnb25TcHJpdGUoZHJhd1JlYylcclxuXHJcbiAgICBSZW5kZXJJbWFnZVNwcml0ZTogKGRyYXdSZWMpIC0+XHJcbiAgICAgICAgaWYgQHNwcml0ZS50ZXh0dXJlPyBvciBAc3ByaXRlLnZpZGVvP1xyXG4gICAgICAgICAgICBmcmFtZSA9IEBzcHJpdGUudGV4dHVyZSBvciBAc3ByaXRlLnZpZGVvXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGZyYW1lLmRyYXdQYXJhbXNcclxuXHJcbiAgICAgICAgICAgICMgU2V0IHRoZSBjYW52YXMgc3RhdGVcclxuICAgICAgICAgICAgY2FudmFzID0gQGdhbWUuY2FudmFzXHJcbiAgICAgICAgICAgIGNhbnZhcy5zYXZlKClcclxuICAgICAgICAgICAgQFNldENhbnZhc1N0YXRlcyhjYW52YXMsIGRyYXdSZWMueCArIGRyYXdSZWMud2lkdGggLyAyLCBkcmF3UmVjLnkgKyBkcmF3UmVjLmhlaWdodCAvIDIpXHJcblxyXG4gICAgICAgICAgICBpZiBAc3ByaXRlLkVmZmVjdHMudGludC5jb2xvciBpc250IG51bGxcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5maWxsU3R5bGUgPSBAc3ByaXRlLkVmZmVjdHMudGludC5jb2xvclxyXG4gICAgICAgICAgICAgICAgY2FudmFzLmdsb2JhbEFscGhhID0gQHNwcml0ZS5FZmZlY3RzLnRpbnQub3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgY2FudmFzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiXHJcbiAgICAgICAgICAgICAgICBjYW52YXMuZmlsbFJlY3QoLWRyYXdSZWMud2lkdGgvMiwgLWRyYXdSZWMuaGVpZ2h0LzIsIGRyYXdSZWMud2lkdGgsIGRyYXdSZWMuaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgY2FudmFzLmdsb2JhbEFscGhhID0gQHNwcml0ZS5vcGFjaXR5XHJcblxyXG4gICAgICAgICAgICAjIGRyYXcgdGhlIGltYWdlXHJcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3SW1hZ2UoQHNwcml0ZS52aWRlbz8udmlkZW8gb3IgQHNwcml0ZS50ZXh0dXJlLmltYWdlLCBwYXJhbXMuY2xpcFgsIHBhcmFtcy5jbGlwWSxcclxuICAgICAgICAgICAgcGFyYW1zLmNsaXBXaWR0aCwgcGFyYW1zLmNsaXBIZWlnaHQsLWRyYXdSZWMud2lkdGgvMiArIEBzcHJpdGUucm90YXRpb25PZmZzZXQueCxcclxuICAgICAgICAgICAgLWRyYXdSZWMuaGVpZ2h0LzIgKyBAc3ByaXRlLnJvdGF0aW9uT2Zmc2V0LnksXHJcbiAgICAgICAgICAgIGRyYXdSZWMud2lkdGgsIGRyYXdSZWMuaGVpZ2h0KVxyXG5cclxuICAgICAgICAgICAgaWYgQHNwcml0ZS5Cb2R5LkRFQlVHXHJcbiAgICAgICAgICAgICAgICBjYW52YXMuZmlsbFN0eWxlID0gQHNwcml0ZS5Cb2R5LkRFQlVHXHJcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2xvYmFsQWxwaGEgPSAwLjVcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5maWxsUmVjdCgtZHJhd1JlYy53aWR0aC8yLCAtZHJhd1JlYy5oZWlnaHQvMiwgZHJhd1JlYy53aWR0aCwgZHJhd1JlYy5oZWlnaHQpXHJcblxyXG4gICAgICAgICAgICBjYW52YXMucmVzdG9yZSgpXHJcblxyXG4gICAgUmVuZGVyTGluZVNwcml0ZTogKGRyYXdSZWMpIC0+XHJcbiAgICAgICAgIyBsaW5lcyBhcmUgc3BlY2lhbFxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5zYXZlKClcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLmdsb2JhbEFscGhhID0gQHNwcml0ZS5vcGFjaXR5XHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnN0cm9rZVN0eWxlID0gQHNwcml0ZS5jb2xvclxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5saW5lV2lkdGggPSBAc3ByaXRlLmxpbmVXaWR0aFxyXG5cclxuICAgICAgICBpZiBAc3ByaXRlLkRyYXdUZXh0dXJlPy5pbWFnZT9cclxuICAgICAgICAgICAgQGdhbWUuY2FudmFzLnN0cm9rZVN0eWxlID0gQGdhbWUuY2FudmFzLmNyZWF0ZVBhdHRlcm4oIEBzcHJpdGUuRHJhd1RleHR1cmUuaW1hZ2UsIFwicmVwZWF0XCIgKVxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXMuYmVnaW5QYXRoKClcclxuICAgICAgICBAZ2FtZS5jYW52YXMubW92ZVRvKGRyYXdSZWMueCwgZHJhd1JlYy55KVxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5saW5lVG8oIEBzcHJpdGUuZW5kUG9zaXRpb24ueCArIEBnYW1lLkNhbWVyYS5wb3NpdGlvbi54LCBAc3ByaXRlLmVuZFBvc2l0aW9uLnkgKyBAZ2FtZS5DYW1lcmEucG9zaXRpb24ueSApXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnN0cm9rZSgpXHJcblxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5yZXN0b3JlKClcclxuXHJcbiAgICBSZW5kZXJDaXJjbGVTcHJpdGU6IChkcmF3UmVjKSAtPlxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5zYXZlKClcclxuICAgICAgICBAZ2FtZS5jYW52YXMudHJhbnNsYXRlKGRyYXdSZWMueCArIEBzcHJpdGUucmFkaXVzIC8gMiwgZHJhd1JlYy55ICsgQHNwcml0ZS5yYWRpdXMgLyAyKVxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXMuZ2xvYmFsQWxwaGEgPSBAc3ByaXRlLm9wYWNpdHlcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnN0cm9rZVN0eWxlID0gQHNwcml0ZS5zdHJva2VDb2xvclxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5maWxsU3R5bGUgPSBAc3ByaXRlLmZpbGxDb2xvclxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXMuYmVnaW5QYXRoKClcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLmFyYygwLCAwLCBAc3ByaXRlLnJhZGl1cywgQHNwcml0ZS5zdGFydEFuZ2xlLCBAc3ByaXRlLmVuZEFuZ2xlLCBAc3ByaXRlLmRyYXdEaXJlY3Rpb24gaXMgXCJjb3VudGVyY2xvY2t3aXNlXCIpXHJcblxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5maWxsKClcclxuICAgICAgICBAZ2FtZS5jYW52YXMuc3Ryb2tlKClcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnJlc3RvcmUoKVxyXG5cclxuICAgIFJlbmRlckJveFNwcml0ZTogKGRyYXdSZWMpIC0+XHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnNhdmUoKVxyXG5cclxuICAgICAgICBAU2V0Q2FudmFzU3RhdGVzKEBnYW1lLmNhbnZhcywgZHJhd1JlYy54ICsgQHNwcml0ZS53aWR0aCAvIDIsIGRyYXdSZWMueSArIEBzcHJpdGUuaGVpZ2h0IC8gMilcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLmJlZ2luUGF0aCgpXHJcblxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5yZWN0KC1Ac3ByaXRlLndpZHRoLzIsIC1Ac3ByaXRlLmhlaWdodC8yLCBAc3ByaXRlLndpZHRoLCBAc3ByaXRlLmhlaWdodClcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLmZpbGwoKVxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5zdHJva2UoKVxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXMucmVzdG9yZSgpXHJcblxyXG4gICAgUmVuZGVyUG9seWdvblNwcml0ZTogKGRyYXdSZWMpIC0+XHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnNhdmUoKVxyXG5cclxuICAgICAgICBjZW50ZXJQb2ludCA9IFBvaW50LkdldENlbnRlclBvaW50KEBzcHJpdGUucG9pbnRzKVxyXG5cclxuICAgICAgICBAU2V0Q2FudmFzU3RhdGVzKEBnYW1lLmNhbnZhcywgZHJhd1JlYy54ICsgY2VudGVyUG9pbnQueCAvIDIsIGRyYXdSZWMueSArIGNlbnRlclBvaW50LnkgLyAyKVxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXMuYmVnaW5QYXRoKClcclxuICAgICAgICBAZ2FtZS5jYW52YXMubW92ZVRvKDAsIDApXHJcblxyXG4gICAgICAgIGZvciBwb2ludCBpbiBAc3ByaXRlLnBvaW50c1xyXG4gICAgICAgICAgICBAZ2FtZS5jYW52YXMubGluZVRvKHBvaW50LngsIHBvaW50LnkpXHJcblxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5jbG9zZVBhdGgoKVxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5zdHJva2UoKVxyXG4gICAgICAgIEBnYW1lLmNhbnZhcy5maWxsKClcclxuXHJcbiAgICAgICAgQGdhbWUuY2FudmFzLnJlc3RvcmUoKVxyXG5cclxuICAgIFNldENhbnZhc1N0YXRlczogKGNhbnZhcywgdHJhbnNGb3JtWCwgdHJhbnNGb3JtWSktPlxyXG4gICAgICAgIGNhbnZhcy5nbG9iYWxBbHBoYSA9IEBzcHJpdGUub3BhY2l0eSAgICAgICAgaWYgQHNwcml0ZS5vcGFjaXR5P1xyXG4gICAgICAgIGNhbnZhcy5zdHJva2VTdHlsZSA9IEBzcHJpdGUuc3Ryb2tlQ29sb3IgICAgaWYgQHNwcml0ZS5zdHJva2VDb2xvcj9cclxuICAgICAgICBjYW52YXMuZmlsbFN0eWxlID0gQHNwcml0ZS5maWxsQ29sb3IgICAgICAgIGlmIEBzcHJpdGUuZmlsbENvbG9yP1xyXG5cclxuICAgICAgICBjYW52YXMudHJhbnNsYXRlKHRyYW5zRm9ybVgsIHRyYW5zRm9ybVkpXHJcbiAgICAgICAgY2FudmFzLnJvdGF0ZShAc3ByaXRlLnJvdGF0aW9uKVxyXG5cbmNsYXNzIENsb25lTWFuYWdlclxyXG4gICAgc3ByaXRlOiBudWxsICMgdGhlIHNwcml0ZSB0byBiZSBjbG9uZWRcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBzcHJpdGUpIC0+XHJcblxyXG4gICAgX2RlZmF1bHRDbG9uZTogKGtlZXBHYW1lKSAtPlxyXG4gICAgICAgIGNsb25lID0ge31cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBzcHJpdGVcclxuICAgICAgICAgICAgY29udGludWUgaWYga2V5IGlzIFwiZ2FtZVwiXHJcblxyXG4gICAgICAgICAgICBpZiBVdGlsLlR5cGUoIHZhbHVlICkgaXMgXCJvYmplY3RcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBPYmplY3QuY3JlYXRlKCB2YWx1ZSApXHJcblxyXG4gICAgICAgICAgICBjbG9uZVsga2V5IF0gPSB2YWx1ZVxyXG5cclxuICAgICAgICBAc3ByaXRlLmdhbWUuQWRkKCBjbG9uZSApIGlmIGtlZXBHYW1lXHJcbiAgICAgICAgcmV0dXJuIGNsb25lXHJcblxyXG4gICAgV2l0aENvbnN0cnVjdG9yOiAoYXJncy4uLikgLT5cclxuICAgICAgICBpZiBub3QgQHNwcml0ZS5jb25zdHJ1Y3Rvcj9cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNsb25lIHdpdGggY29uc3RydWN0b3I6IHNwcml0ZSBoYXMgbm8gY29uc3RydWN0b3JcIilcclxuXHJcbiAgICAgICAgU3ByaXRlQ29uc3RydWN0b3IgPSBAc3ByaXRlLmNvbnN0cnVjdG9yXHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlQ29uc3RydWN0b3IoIGFyZ3MuLi4gKVxyXG5cclxuICAgIFdpdGhHYW1lOiAoa2VlcEdhbWUgPSBmYWxzZSkgLT5cclxuICAgICAgICByZXR1cm4gQF9kZWZhdWx0Q2xvbmUoa2VlcEdhbWUpXHJcblxuVG9yY2hNb2R1bGUgY2xhc3MgU3ByaXRlIGV4dGVuZHMgR2FtZVRoaW5nXHJcbiAgICBTcHJpdGUuTWl4SW4oRXZlbnREaXNwYXRjaGVyKVxyXG5cclxuICAgIHRvcmNoX3JlbmRlcl90eXBlOiBcIkltYWdlXCJcclxuICAgIHRvcmNoX3R5cGU6IFwiU3ByaXRlXCJcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKGdhbWUsIHgsIHkpLT5cclxuICAgICAgICBASW5pdFNwcml0ZShnYW1lLCB4LCB5KVxyXG5cclxuICAgIEluaXRTcHJpdGU6IChnYW1lLCB4ID0gMCwgeSA9IDApLT5cclxuXHJcbiAgICAgICAgIyBjaGVjayB0aGUgYXJndW1lbnQgdHlwZXNcclxuICAgICAgICBnYW1lVHlwZSA9IFV0aWwuVHlwZShnYW1lKVxyXG4gICAgICAgIHhUeXBlID0gVXRpbC5UeXBlKHgpXHJcbiAgICAgICAgeVR5cGUgPSBVdGlsLlR5cGUoeSlcclxuXHJcbiAgICAgICAgaWYgbm90IGdhbWU/IG9yIGdhbWVUeXBlIGlzbnQgXCJHYW1lXCJcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVSLkFyZ3VtZW50RXJyb3IoXCJnYW1lXCIsIGdhbWUsIFtcIlRvcmNoLkdhbWVcIl0pXHJcblxyXG4gICAgICAgIGlmIHhUeXBlIGlzbnQgXCJudW1iZXJcIlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRVIuQXJndW1lbnRFcnJvcihcInhcIiwgeCwgW1wibnVtYmVyXCJdKVxyXG5cclxuICAgICAgICBpZiB5VHlwZSBpc250IFwibnVtYmVyXCJcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVSLkFyZ3VtZW50RXJyb3IoXCJ5XCIsIHksIFtcIm51bWJlclwiXSlcclxuXHJcbiAgICAgICAgQEluaXRFdmVudERpc3BhdGNoKClcclxuXHJcbiAgICAgICAgQGdhbWUgPSBnYW1lXHJcblxyXG4gICAgICAgIEByZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKHgsIHksIDAsIDApXHJcbiAgICAgICAgQHBvc2l0aW9uID0gbmV3IFZlY3Rvcih4LHkpXHJcbiAgICAgICAgQHJvdGF0aW9uT2Zmc2V0ID0gbmV3IFZlY3RvciggMCwgMCApXHJcblxyXG4gICAgICAgIEBCaW5kID0gbmV3IEJpbmRNYW5hZ2VyKEApXHJcbiAgICAgICAgQENvbGxpc2lvbnMgPSBuZXcgQ29sbGlzaW9uTWFuYWdlcihAKVxyXG4gICAgICAgIEBCb2R5ID0gbmV3IEJvZHlNYW5hZ2VyKEApXHJcbiAgICAgICAgQFNpemUgPSBuZXcgU2l6ZU1hbmFnZXIoQClcclxuICAgICAgICBARXZlbnRzID0gbmV3IEV2ZW50TWFuYWdlcihAKVxyXG4gICAgICAgIEBFZmZlY3RzID0gbmV3IEVmZmVjdE1hbmFnZXIoQClcclxuICAgICAgICBAU3RhdGVzID0gbmV3IFN0YXRlTWFjaGluZU1hbmFnZXIoQClcclxuICAgICAgICBAR3JpZCA9IG5ldyBHcmlkTWFuYWdlcihAKVxyXG4gICAgICAgIEBBbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIoQClcclxuICAgICAgICBAQ2xvbmUgPSBuZXcgQ2xvbmVNYW5hZ2VyKEApXHJcblxyXG4gICAgICAgIEB0ZXh0dXJlID0gbnVsbFxyXG4gICAgICAgIEB2aWRlbyA9IG51bGxcclxuXHJcbiAgICAgICAgQGZpeGVkID0gZmFsc2VcclxuICAgICAgICBAZHJhdyA9IHRydWVcclxuICAgICAgICBAcGF1c2VkID0gZmFsc2VcclxuXHJcbiAgICAgICAgQGRyYXdJbmRleCA9IDBcclxuICAgICAgICBAcm90YXRpb24gPSAwXHJcbiAgICAgICAgQG9wYWNpdHkgPSAxXHJcblxyXG4gICAgICAgIEBfdG9yY2hfYWRkID0gXCJTcHJpdGVcIlxyXG4gICAgICAgIEBfdG9yY2hfdWlkID0gXCJcIlxyXG5cclxuICAgICAgICBAZXZlbnRzID0ge31cclxuICAgICAgICBAcmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoQClcclxuXHJcbiAgICAgICAgQGV4cG9ydFZhbHVlcyA9IFtdXHJcblxyXG4gICAgICAgIGdhbWUuQWRkKEApXHJcblxyXG4gICAgVXBkYXRlU3ByaXRlOiAtPlxyXG4gICAgICAgIHJldHVybiBpZiBAcGF1c2VkXHJcbiAgICAgICAgQHJlY3RhbmdsZS54ID0gQHBvc2l0aW9uLnhcclxuICAgICAgICBAcmVjdGFuZ2xlLnkgPSBAcG9zaXRpb24ueVxyXG4gICAgICAgIEBCb2R5LlVwZGF0ZSgpXHJcbiAgICAgICAgQFNpemUuVXBkYXRlKClcclxuICAgICAgICBARXZlbnRzLlVwZGF0ZSgpXHJcbiAgICAgICAgQFN0YXRlcy5VcGRhdGUoKVxyXG4gICAgICAgIEBHcmlkLlVwZGF0ZSgpXHJcbiAgICAgICAgQEFuaW1hdGlvbnMuVXBkYXRlKClcclxuICAgICAgICBARWZmZWN0cy5VcGRhdGUoKVxyXG4gICAgICAgIEBDb2xsaXNpb25zLlVwZGF0ZSgpICMgdGhpcyBuZWVkcyB0byBiZSBhZnRlciB0aGUgcmVjdGFuZ2xlIHRoaW5nLCBHb2Qga25vd3Mgd2h5XHJcblxyXG4gICAgICAgIGlmIEBnYW1lLmJvdW5kYXJ5IGFuZCBub3QgQHJlY3RhbmdsZS5JbnRlcnNlY3RzKCBAZ2FtZS5ib3VuZGFyeSApXHJcbiAgICAgICAgICAgIEBFbWl0IFwiT3V0T2ZCb3VuZHNcIiwgbmV3IEV2ZW50KCBAZ2FtZSwgeyBzcHJpdGU6IEAgfSApXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIEBVcGRhdGVTcHJpdGUoKVxyXG5cclxuICAgIERyYXc6IC0+XHJcbiAgICAgICAgQHJlbmRlcmVyLkRyYXcoKVxyXG5cclxuICAgIE5vdFNlbGY6IChvdGhlclNwcml0ZSkgLT5cclxuICAgICAgICByZXR1cm4gKG90aGVyU3ByaXRlLnRvcmNoX3VpZCBpc250IEB0b3JjaF91aWQpXHJcblxyXG4gICAgV3JhcDogLT5cclxuICAgICAgICBAT24gXCJPdXRPZkJvdW5kc1wiLCA9PlxyXG4gICAgICAgICAgICByZXR1cm4gaWYgbm90IEBnYW1lLmJvdW5kYXJ5XHJcblxyXG4gICAgICAgICAgICBpZiBAcG9zaXRpb24ueSA8IEBnYW1lLmJvdW5kYXJ5LnlcclxuICAgICAgICAgICAgICAgIEBwb3NpdGlvbi55ID0gQGdhbWUuYm91bmRhcnkuaGVpZ2h0IC0gQHJlY3RhbmdsZS5oZWlnaHRcclxuXHJcbiAgICAgICAgICAgIGlmIEBwb3NpdGlvbi55ID4gQGdhbWUuYm91bmRhcnkuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBAcG9zaXRpb24ueSA9IEBnYW1lLmJvdW5kYXJ5LnkgKyBAcmVjdGFuZ2xlLmhlaWdodFxyXG5cclxuICAgICAgICAgICAgaWYgQHBvc2l0aW9uLnggPiBAZ2FtZS5ib3VuZGFyeS53aWR0aFxyXG4gICAgICAgICAgICAgICAgQHBvc2l0aW9uLnggPSBAZ2FtZS5ib3VuZGFyeS54ICsgQHJlY3RhbmdsZS53aWR0aFxyXG5cclxuICAgICAgICAgICAgaWYgQHBvc2l0aW9uLnggPCBAZ2FtZS5ib3VuZGFyeS54XHJcbiAgICAgICAgICAgICAgICBAcG9zaXRpb24ueCA9IEBnYW1lLmJvdW5kYXJ5LndpZHRoIC0gQHJlY3RhbmdsZS53aWR0aFxyXG5cclxuICAgIENsb25lOiAtPlxyXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKCBAIClcclxuXHJcbiAgICBDZW50ZXI6IC0+XHJcbiAgICAgICAgd2lkdGggPSBAZ2FtZS5jYW52YXNOb2RlLndpZHRoXHJcbiAgICAgICAgeCA9ICh3aWR0aCAvIDIpIC0gKEByZWN0YW5nbGUud2lkdGgvMilcclxuICAgICAgICBAcG9zaXRpb24ueCA9IHhcclxuICAgICAgICByZXR1cm4gQFxyXG5cclxuICAgIENlbnRlclZlcnRpY2FsOiAtPlxyXG4gICAgICAgIGhlaWdodCA9IEBnYW1lLmNhbnZhc05vZGUuaGVpZ2h0XHJcbiAgICAgICAgeSA9IChoZWlnaHQgLyAyKSAtIChAcmVjdGFuZ2xlLmhlaWdodC8yKVxyXG4gICAgICAgIEBwb3NpdGlvbi55ID0geVxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgQ29sbGlkZXNXaXRoOiAob3RoZXJTcHJpdGUpIC0+XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25EZXRlY3RvcihALCBvdGhlclNwcml0ZSlcclxuXHJcbiAgICBQYXVzZTogKHNob3VsZFBhdXNlID0gdHJ1ZSkgLT5cclxuICAgICAgICAjIHByZXZlbnRzIHRoZSBzcHJpdGUgZnJvbSB1cGRhdGluZ1xyXG4gICAgICAgIEBwYXVzZWQgPSBzaG91bGRQYXVzZVxyXG5cclxuICAgIEV4cG9ydDogKGF0dHJpYnNUb0V4cG9ydC4uLikgLT5cclxuICAgICAgICBAZXhwb3J0VmFsdWVzID0gYXR0cmlic1RvRXhwb3J0XHJcblxuaWYgZG9jdW1lbnQ/XHJcbiAgICBfbWVhc3VyZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJDQU5WQVNcIilcclxuICAgIF9tZWFzdXJlQ2FudmFzLndpZHRoID0gNTAwXHJcbiAgICBfbWVhc3VyZUNhbnZhcy5oZWlnaHQgPSA1MDBcclxuZWxzZVxyXG4gICAgX21lYXN1cmVDYW52YXMgPVxyXG4gICAgICAgIGdldENvbnRleHQ6IC0+XHJcblxyXG5Ub3JjaE1vZHVsZSBjbGFzcyBUZXh0IGV4dGVuZHMgU3ByaXRlXHJcbiAgICBURVhUOiB0cnVlXHJcbiAgICBAbWVhc3VyZUNhbnZhczogX21lYXN1cmVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXHJcblxyXG4gICAgIyB3ZSBuZWVkIHByb3BlcnRpZXMgYmVjYXVzZSB0aGUgdGV4dCBuZWVkcyB0byByZS1yZW5kZXJcclxuICAgICMgd2hlbmV2ZXIgaXQgaXMgY2hhbmdlZFxyXG4gICAgQHByb3BlcnR5ICdmb250U2l6ZScsXHJcbiAgICAgICAgZ2V0OiAtPiByZXR1cm4gQF9mb250U2l6ZVxyXG4gICAgICAgIHNldDogKGZvbnRTaXplKSAtPlxyXG4gICAgICAgICAgICBAX2ZvbnRTaXplID0gZm9udFNpemVcclxuICAgICAgICAgICAgVXRpbC5GdW5jdGlvbiggPT4gQFJlbmRlcigpICkuRGVmZXIoKVxyXG5cclxuICAgIEBwcm9wZXJ0eSAnZm9udCcsXHJcbiAgICAgICAgZ2V0OiAtPiByZXR1cm4gQF9mb250XHJcbiAgICAgICAgc2V0OiAoZm9udCkgLT5cclxuICAgICAgICAgICAgQF9mb250ID0gZm9udFxyXG4gICAgICAgICAgICBVdGlsLkZ1bmN0aW9uKCA9PiBAUmVuZGVyKCkgKS5EZWZlcigpXHJcblxyXG4gICAgQHByb3BlcnR5ICdmb250V2VpZ2h0JyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX2ZvbnRXZWlnaHRcclxuICAgICAgICBzZXQ6IChmb250V2VpZ2h0KSAtPlxyXG4gICAgICAgICAgICBAX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0XHJcbiAgICAgICAgICAgIFV0aWwuRnVuY3Rpb24oID0+IEBSZW5kZXIoKSApLkRlZmVyKClcclxuXHJcbiAgICBAcHJvcGVydHkgJ2NvbG9yJyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX2NvbG9yXHJcbiAgICAgICAgc2V0OiAoY29sb3IpIC0+XHJcbiAgICAgICAgICAgIEBfY29sb3IgPSBjb2xvclxyXG4gICAgICAgICAgICBVdGlsLkZ1bmN0aW9uKCA9PiBAUmVuZGVyKCkgKS5EZWZlcigpXHJcblxyXG4gICAgQHByb3BlcnR5ICd0ZXh0JyxcclxuICAgICAgICBnZXQ6IC0+IHJldHVybiBAX3RleHRcclxuICAgICAgICBzZXQ6ICh0ZXh0KSAtPlxyXG4gICAgICAgICAgICBAX3RleHQgPSB0ZXh0XHJcbiAgICAgICAgICAgIFV0aWwuRnVuY3Rpb24oID0+IEBSZW5kZXIoKSApLkRlZmVyKClcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKGdhbWUsIHgsIHksIGRhdGEpIC0+XHJcbiAgICAgICAgQEluaXRUZXh0KGdhbWUsIHgsIHksIGRhdGEpXHJcblxyXG4gICAgSW5pdFRleHQ6IChnYW1lLCB4LCB5LCBkYXRhKSAtPlxyXG4gICAgICAgIEBJbml0U3ByaXRlKGdhbWUseCx5KVxyXG4gICAgICAgIEBkYXRhID0gZGF0YVxyXG4gICAgICAgIEBfZm9udCA9IFwiQXJpYWxcIlxyXG4gICAgICAgIEBfZm9udFNpemUgPSAxNlxyXG4gICAgICAgIEBfZm9udFdlaWdodCA9IFwiXCJcclxuICAgICAgICBAX2NvbG9yID0gXCIjMmI0NTMxXCJcclxuICAgICAgICBAX3RleHQgPSBcIlwiXHJcbiAgICAgICAgQHdpZHRoID0gMTAwXHJcbiAgICAgICAgQGhlaWdodCA9IDEwMFxyXG4gICAgICAgIEBTaXplLnNjYWxlID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9XHJcbiAgICAgICAgQEluaXQoKVxyXG5cclxuICAgIEluaXQ6IC0+XHJcbiAgICAgICAgaWYgQGRhdGEuZm9udCAgICAgICAgICAgIHRoZW4gQF9mb250ID0gICAgICAgICAgIEBkYXRhLmZvbnRcclxuICAgICAgICBpZiBAZGF0YS5mb250U2l6ZSAgICAgICAgdGhlbiBAX2ZvbnRTaXplID0gICAgICAgQGRhdGEuZm9udFNpemVcclxuICAgICAgICBpZiBAZGF0YS5mb250V2VpZ2h0ICAgICAgdGhlbiBAX2ZvbnRXZWlnaHQgPSAgICAgQGRhdGEuZm9udFdlaWdodFxyXG4gICAgICAgIGlmIEBkYXRhLmNvbG9yICAgICAgICAgICB0aGVuIEBfY29sb3IgPSAgICAgICAgICBAZGF0YS5jb2xvclxyXG4gICAgICAgIGlmIEBkYXRhLnRleHQgICAgICAgICAgICB0aGVuIEBfdGV4dCA9ICAgICAgICAgICBAZGF0YS50ZXh0XHJcbiAgICAgICAgaWYgQGRhdGEucmVjdGFuZ2xlICAgICAgIHRoZW4gQHJlY3RhbmdsZSA9ICAgICAgQGRhdGEucmVjdGFuZ2xlXHJcbiAgICAgICAgaWYgQGRhdGEuYnVmZkhlaWdodCAgICAgIHRoZW4gQGJ1ZmZIZWlnaHQgPSAgICAgQGRhdGEuYnVmZkhlaWdodFxyXG5cclxuICAgICAgICBAUmVuZGVyKClcclxuXHJcbiAgICBSZW5kZXI6IC0+XHJcbiAgICAgICAgY252ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkNBTlZBU1wiKVxyXG4gICAgICAgIFRleHQubWVhc3VyZUNhbnZhcy5mb250ID0gQF9mb250U2l6ZSArIFwicHggXCIgKyBAX2ZvbnRcclxuICAgICAgICBjbnYud2lkdGggPSBUZXh0Lm1lYXN1cmVDYW52YXMubWVhc3VyZVRleHQoQF90ZXh0KS53aWR0aCAjIG5lZWQgdG8gZml4IHRoaXMgdG8gYWNjb3VudCBmb3IgYm9sZCBmb250c1xyXG4gICAgICAgIGNudi5oZWlnaHQgPSBAX2ZvbnRTaXplXHJcblxyXG4gICAgICAgIGlmIEBidWZmSGVpZ2h0XHJcbiAgICAgICAgICAgIGNudi5oZWlnaHQgKz0gQGJ1ZmZIZWlnaHRcclxuXHJcbiAgICAgICAgY2FudmFzID0gY252LmdldENvbnRleHQoXCIyZFwiKVxyXG4gICAgICAgIGNhbnZhcy5maWxsU3R5bGUgPSBAX2NvbG9yXHJcbiAgICAgICAgY2FudmFzLmZvbnQgPSBAX2ZvbnRXZWlnaHQgKyBcIiBcIiArIEBfZm9udFNpemUgKyBcInB4IFwiICsgQF9mb250XHJcbiAgICAgICAgY2FudmFzLmZpbGxUZXh0KEBfdGV4dCwwLGNudi5oZWlnaHQpXHJcblxyXG4gICAgICAgICMgZ2VuZXJhdGUgdGhlIGltYWdlXHJcbiAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxyXG4gICAgICAgIGltYWdlLnNyYyA9IGNudi50b0RhdGFVUkwoKVxyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9ID0+XHJcbiAgICAgICAgICAgICAgICBAQmluZC5UZXh0dXJlKGltYWdlKVxyXG5cclxuICAgICAgICBAcmVjdGFuZ2xlLndpZHRoID0gY252LndpZHRoXHJcbiAgICAgICAgQHJlY3RhbmdsZS5oZWlnaHQgPSBAX2ZvbnRTaXplXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIHN1cGVyKClcclxuXHJcblRvcmNoTW9kdWxlIGNsYXNzIEJpdG1hcFRleHRcclxuICAgIGNvbnN0cnVjdG9yOiAtPlxyXG5cbiMjI1xyXG4gICAgV2UgbmVlZCB0byBoYXZlIGNpcmNsZXMsIHJlY3RhbmdsZXMsIGxpbmVzLCBhbmQgcG9seXNcclxuIyMjXHJcblNoYXBlcyA9IHtuYW1lOiBcIlNoYXBlc1wifVxyXG5cclxuVG9yY2hNb2R1bGUgU2hhcGVzXHJcblxyXG5jbGFzcyBTaGFwZXMuQ2lyY2xlIGV4dGVuZHMgU3ByaXRlXHJcbiAgICB0b3JjaF9yZW5kZXJfdHlwZTogXCJDaXJjbGVcIlxyXG4gICAgcmFkaXVzOiAwXHJcbiAgICBmaWxsQ29sb3I6IFwiYmxhY2tcIlxyXG4gICAgc3Ryb2tlQ29sb3I6IFwiYmxhY2tcIlxyXG4gICAgc3RhcnRBbmdsZTogMFxyXG4gICAgZW5kQW5nbGU6IDIgKiBNYXRoLlBJXHJcbiAgICBkcmF3RGlyZWN0aW9uOiBcImNsb2Nrd2lzZVwiICMgb3IgY291bnRlcmNsb2Nrd2lzZVxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoZ2FtZSwgeCwgeSwgcmFkaXVzLCBmaWxsQ29sb3IgPSBcImJsYWNrXCIsIHN0cm9rZUNvbG9yID0gXCJibGFja1wiKS0+XHJcbiAgICAgICAgQEluaXRTcHJpdGUoZ2FtZSwgeCwgeSlcclxuICAgICAgICBAcmFkaXVzID0gcmFkaXVzXHJcbiAgICAgICAgQGZpbGxDb2xvciA9IGZpbGxDb2xvclxyXG4gICAgICAgIEBzdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yXHJcblxyXG5jbGFzcyBTaGFwZXMuTGluZSBleHRlbmRzIFNwcml0ZVxyXG4gICAgdG9yY2hfcmVuZGVyX3R5cGU6IFwiTGluZVwiICMgcmVuZGVyIGl0IG5hdGl2ZWx5XHJcbiAgICBjb2xvcjogXCJibGFja1wiXHJcbiAgICBsaW5lV2lkdGg6IDFcclxuXHJcbiAgICBlbmRQb3NpdGlvbjogbnVsbFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoZ2FtZSwgeCwgeSwgZW5kWCwgZW5kWSwgQGNvbG9yLCBjb25maWcpIC0+XHJcbiAgICAgICAgQEluaXRTcHJpdGUoZ2FtZSwgeCwgeSlcclxuXHJcbiAgICAgICAgQGVuZFBvc2l0aW9uID0gbmV3IFBvaW50KGVuZFgsIGVuZFkpXHJcblxyXG4gICAgICAgIFV0aWwuT2JqZWN0KEApLkV4dGVuZChjb25maWcpXHJcblxyXG5jbGFzcyBTaGFwZXMuQm94IGV4dGVuZHMgU3ByaXRlXHJcbiAgICB0b3JjaF9yZW5kZXJfdHlwZTogXCJCb3hcIlxyXG4gICAgdG9yY2hfc2hhcGU6IHRydWVcclxuICAgIGZpbGxDb2xvcjogXCJibGFja1wiXHJcbiAgICBzdHJva2VDb2xvcjogXCJibGFja1wiXHJcbiAgICB3aWR0aDogMFxyXG4gICAgaGVpZ2h0OiAwXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChnYW1lLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsQ29sb3IgPSBcImJsYWNrXCIsIHN0cm9rZUNvbG9yID0gXCJibGFja1wiKSAtPlxyXG4gICAgICAgIEBJbml0U3ByaXRlKGdhbWUsIHgsIHkpXHJcbiAgICAgICAgQHdpZHRoID0gd2lkdGhcclxuICAgICAgICBAaGVpZ2h0ID0gaGVpZ2h0XHJcbiAgICAgICAgQGZpbGxDb2xvciA9IGZpbGxDb2xvclxyXG4gICAgICAgIEBzdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yXHJcblxyXG5jbGFzcyBTaGFwZXMuUG9seWdvbiBleHRlbmRzIFNwcml0ZVxyXG4gICAgdG9yY2hfcmVuZGVyX3R5cGU6IFwiUG9seWdvblwiXHJcbiAgICBjb25zdHJ1Y3RvcjogKGdhbWUsIHgsIHksIEBwb2ludHMsIEBmaWxsQ29sb3IsIEBzdHJva2VDb2xvcikgLT5cclxuICAgICAgICBASW5pdFNwcml0ZShnYW1lLCB4LCB5KVxyXG5cclxuICAgIEBSZWd1bGFyOiAoZ2FtZSwgeCwgeSwgc2lkZXMsIHdpZHRoLCBmaWxsQ29sb3IsIHN0cm9rZUNvbG9yKSAtPlxyXG4gICAgICAgIGFuZ2xlSW50ZXJ2YWwgPSAoTWF0aC5QSSAqIDIpIC8gc2lkZXNcclxuICAgICAgICBwb2ludHMgPSBbXVxyXG4gICAgICAgIGFuZ2xlID0gMFxyXG5cclxuICAgICAgICB3aGlsZSBhbmdsZSA8PSBNYXRoLlBJICogMlxyXG5cclxuICAgICAgICAgICAgcHggPSBNYXRoLmNvcyhhbmdsZSkgKiB3aWR0aFxyXG4gICAgICAgICAgICBweSA9IE1hdGguc2luKGFuZ2xlKSAqIHdpZHRoXHJcblxyXG4gICAgICAgICAgICBwb2ludHMucHVzaCggbmV3IFBvaW50KHB4LHB5KSApXHJcblxyXG4gICAgICAgICAgICBhbmdsZSArPSBhbmdsZUludGVydmFsXHJcblxyXG5cclxuICAgICAgICBzaGFwZSA9IG5ldyBTaGFwZXMuUG9seWdvbihnYW1lLCB4LCB5LCBwb2ludHMsIGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IpXHJcbiAgICAgICAgc2hhcGUucmVjdGFuZ2xlLndpZHRoID0gc2hhcGUucmVjdGFuZ2xlLmhlaWdodCA9IHdpZHRoXHJcblxyXG4gICAgICAgIHJldHVybiBzaGFwZVxyXG5cblRvcmNoTW9kdWxlIGNsYXNzIFNwcml0ZUdyb3VwIGV4dGVuZHMgR2FtZVRoaW5nXHJcbiAgICBATWl4SW4gRXZlbnREaXNwYXRjaGVyXHJcblxyXG4gICAgc3ByaXRlczogbnVsbFxyXG4gICAgcG9zaXRpb246IG51bGxcclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUsIHgsIHkpIC0+XHJcbiAgICAgICAgQEluaXRFdmVudERpc3BhdGNoKClcclxuICAgICAgICBAZ2FtZS5BZGQoQClcclxuICAgICAgICBAc3ByaXRlcyA9IFtdXHJcbiAgICAgICAgQHBvc2l0aW9uID0gbmV3IFZlY3Rvcih4LHkpXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGZpbHRlcmVkID0gW11cclxuICAgICAgICBmb3Igc3ByaXRlIGluIEBzcHJpdGVzXHJcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goIHNwcml0ZSApIGlmIG5vdCBzcHJpdGUudHJhc2hcclxuXHJcbiAgICAgICAgQHNwcml0ZXMgPSBmaWx0ZXJlZFxyXG5cclxuICAgICAgICBpZiBmaWx0ZXJlZC5sZW5ndGggPD0gMFxyXG4gICAgICAgICAgICBARW1pdCBcIkVtcHR5XCIsIG5ldyBFdmVudChAZ2FtZSwge3Nwcml0ZUdyb3VwOiBAfSApXHJcblxyXG4gICAgRXZlcnk6IChjYWxiYWNrKSAtPlxyXG4gICAgICAgIGZvciBzcHJpdGUgaW4gQHNwcml0ZXNcclxuICAgICAgICAgICAgY2FsYmFjayhzcHJpdGUpXHJcblxyXG4gICAgR3JpZDogKHNwcml0ZVRvQ29weSwgcm93cywgY29sdW1ucywgcGFkZGluZyA9IDApIC0+XHJcbiAgICAgICAgIyBUT0RPXHJcbiAgICAgICAgIyBzdXBwb3J0IGNsb25pbmcgc3ByaXRlc1xyXG4gICAgICAgICMgc3VwcG9ydCBkaWZmZXJlbnQgd2lkdGhzL2hlaWdodHNcclxuICAgICAgICBkaXN0cmlidXRpb24gPSBudWxsXHJcbiAgICAgICAgaWYgVXRpbC5UeXBlKHNwcml0ZVRvQ29weSkgaXNudCBcImFycmF5XCJcclxuICAgICAgICAgICAgZmlyc3QgPSBuZXcgc3ByaXRlVG9Db3B5KCBAZ2FtZSwgQHBvc2l0aW9uLngsIEBwb3NpdGlvbi55IClcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRpc3RyaWJ1dGlvbiA9IHNwcml0ZVRvQ29weVxyXG4gICAgICAgICAgICBmaXJzdCA9IG5ldyBkaXN0cmlidXRpb25bMF0oIEBnYW1lLCBAcG9zaXRpb24ueCwgQHBvc2l0aW9uLnkgKVxyXG5cclxuICAgICAgICB3aWR0aCA9IGZpcnN0LnJlY3RhbmdsZS53aWR0aFxyXG4gICAgICAgIGhlaWdodCA9IGZpcnN0LnJlY3RhbmdsZS5oZWlnaHRcclxuXHJcbiAgICAgICAgZmlyc3QuVHJhc2goKSAjIHRoaXMgaXMgaWZmeVxyXG4gICAgICAgIHdpZHRoICs9IHBhZGRpbmdcclxuICAgICAgICBoZWlnaHQgKz0gcGFkZGluZ1xyXG5cclxuICAgICAgICBpID0gMFxyXG4gICAgICAgIHdoaWxlIGkgPCByb3dzXHJcblxyXG4gICAgICAgICAgICBqID0gMFxyXG4gICAgICAgICAgICB3aGlsZSBqIDwgY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgaWYgZGlzdHJpYnV0aW9uIGlzIG51bGxcclxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbmV3IHNwcml0ZVRvQ29weSggQGdhbWUsIEBwb3NpdGlvbi54ICsgKCBpICogd2lkdGggKSwgQHBvc2l0aW9uLnkgKyAoIGogKiBoZWlnaHQgKSApXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZSgwLCBkaXN0cmlidXRpb24ubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGlzdHJpYnV0aW9uLCBpbmRleClcclxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbmV3IGRpc3RyaWJ1dGlvbltpbmRleF0oIEBnYW1lLCBAcG9zaXRpb24ueCArICggaSAqIHdpZHRoICksIEBwb3NpdGlvbi55ICsgKCBqICogaGVpZ2h0ICkgKVxyXG5cclxuICAgICAgICAgICAgICAgIEBzcHJpdGVzLnB1c2goY29weSlcclxuICAgICAgICAgICAgICAgIGorK1xyXG5cclxuICAgICAgICAgICAgaSsrXHJcblxuY2xhc3MgQ29sbGlzaW9uRGV0ZWN0b3JcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNwcml0ZSwgQG90aGVyU3ByaXRlKSAtPlxyXG5cclxuICAgIEFBQkI6IC0+XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKEBzcHJpdGUsIEBvdGhlclNwcml0ZSkuRXhlY3V0ZSgpXHJcblxyXG4gICAgQ2lyY2xlOiAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKEBzcHJpdGUsIEBvdGhlclNwcml0ZSkuRXhlY3V0ZSgpXHJcblxyXG4gICAgU0FUOiAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgU0FUKEBzcHJpdGUsIEBvdGhlclNwcml0ZSkuRXhlY3V0ZSgpXHJcblxuY2xhc3MgQUFCQlxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlLCBAb3RoZXJTcHJpdGUpIC0+XHJcblxyXG4gICAgRXhlY3V0ZTogLT5cclxuICAgICAgICByZXR1cm4gQHNwcml0ZS5yZWN0YW5nbGUuSW50ZXJzZWN0cyhAb3RoZXJTcHJpdGUucmVjdGFuZ2xlKVxyXG5cbmNsYXNzIENpcmNsZVxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlLCBAb3RoZXJTcHJpdGUpIC0+XHJcblxyXG4gICAgRXhlY3V0ZTogLT5cclxuICAgICAgICBjaXJjbGUxID1cclxuICAgICAgICAgICAgcmFkaXVzOiBAc3ByaXRlLldpZHRoKClcclxuICAgICAgICAgICAgeDogQHNwcml0ZS5Qb3NpdGlvbihcInhcIilcclxuICAgICAgICAgICAgeTogQHNwcml0ZS5Qb3NpdGlvbihcInlcIilcclxuXHJcbiAgICAgICAgY2lyY2xlMiA9XHJcbiAgICAgICAgICAgIHJhZGl1czogQG90aGVyU3ByaXRlLldpZHRoKClcclxuICAgICAgICAgICAgeDogQG90aGVyU3ByaXRlLlBvc2l0aW9uKFwieFwiKVxyXG4gICAgICAgICAgICB5OiBAb3RoZXJTcHJpdGUuUG9zaXRpb24oXCJ5XCIpXHJcblxyXG4gICAgICAgIGR4ID0gY2lyY2xlMS54IC0gY2lyY2xlMi54XHJcbiAgICAgICAgZHkgPSBjaXJjbGUxLnkgLSBjaXJjbGUyLnlcclxuICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcclxuXHJcbiAgICAgICAgaWYgZGlzdGFuY2UgPCBjaXJjbGUxLnJhZGl1cyArIGNpcmNsZTIucmFkaXVzXHJcbiAgICAgICAgICAgICNjb2xsaXNpb24gZGV0ZWN0ZWQhXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcblxuXG5Db2xsaXNpb24gPVxyXG4gICAgQUFCQjogMVxyXG4gICAgQ2lyY2xlOiAyXHJcbiAgICBTQVQ6IDNcclxuXHJcbmNsYXNzIENvbGxpc2lvbk1hbmFnZXJcclxuICAgIG1vZGU6IENvbGxpc2lvbi5BQUJCXHJcbiAgICBzcHJpdGU6IG51bGxcclxuICAgIGZpbHRlcjogbnVsbFxyXG4gICAgbGltaXQ6IG51bGxcclxuICAgIGVuYWJsZWQ6IGZhbHNlXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAc3ByaXRlKSAtPlxyXG4gICAgICAgIEBmaWx0ZXIgPSB7fVxyXG4gICAgICAgIEBnYW1lID0gQHNwcml0ZS5nYW1lXHJcblxyXG4gICAgTW9uaXRvcjogLT5cclxuICAgICAgICBAZW5hYmxlZCA9IHRydWVcclxuXHJcbiAgICBOb3RGaWx0ZXJlZDogKHNwcml0ZSkgLT5cclxuICAgICAgICAjIGV2YWx1YXRlIHRoZSBzcHJpdGUgdG8gc2VlIGlmIGl0IGlzIGZpbHRlcmVkIG91dFxyXG4gICAgICAgICMgYnkgY29tcGFyaW5nIGl0cyBhdHRyaWJ1dGVzIHdpdGggZmlsdGVyIG9iamVjdHNcclxuXHJcbiAgICAgICAgIyBjaGVjayBnYW1lLXdpZGUgZmlsdGVyc1xyXG4gICAgICAgIGZvciBrZXksdmFsdWUgb2YgQGdhbWUuZmlsdGVyXHJcbiAgICAgICAgICAgICMgY2hlY2sgc3BlY2lhbCBmbGFnXHJcbiAgICAgICAgICAgIGlmIGtleSBpcyBcIl9fdHlwZV9fXCJcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIGlzIHNwcml0ZS5jb25zdHJ1Y3Rvci5uYW1lXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiB2YWx1ZSBpcyBzcHJpdGVba2V5XVxyXG5cclxuICAgICAgICAjIGNoZWNrIHNwcml0ZS1zcGVjaWZpYyBmaWx0ZXJzXHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAZmlsdGVyXHJcbiAgICAgICAgICAgICMgY2hlY2sgc3BlY2lhbCBmbGFnXHJcbiAgICAgICAgICAgIGlmIGtleSBpcyBcIl9fdHlwZV9fXCJcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIGlzIHNwcml0ZS5jb25zdHJ1Y3Rvci5uYW1lXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZSBpZiB2YWx1ZSBpcyBzcHJpdGVba2V5XVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG5cclxuICAgIEluTGltaXQ6IChzcHJpdGUpIC0+XHJcbiAgICAgICAgIyBldmFsdWF0ZSBzcHJpdGUgdG8gbWFrZSBzdXJlIGl0IGhhcyBhdHRyaWJ1dGVzXHJcbiAgICAgICAgIyB0aGF0IG1hdGNoIGxpbWl0IG9iamVjdFxyXG5cclxuICAgICAgICAjIGNoZWNrIHNwcml0ZS1zcGVjaWZpYyBsaW1pdHNcclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBsaW1pdFxyXG4gICAgICAgICAgICAjIGNoZWNrIHNwZWNpYWwgZmxhZ1xyXG4gICAgICAgICAgICBpZiBrZXkgaXMgXCJfX3R5cGVfX1wiXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZSBpZiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIGlzIHNwcml0ZS5jb25zdHJ1Y3Rvci5uYW1lXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIHZhbHVlIGlzIHNwcml0ZVtrZXldXHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG5cclxuICAgIFZhbGlkOiAoc3ByaXRlKSAtPlxyXG4gICAgICAgIGlmIEBsaW1pdCBpc250IG51bGxcclxuICAgICAgICAgICAgcmV0dXJuIEBJbkxpbWl0KHNwcml0ZSlcclxuXHJcbiAgICAgICAgcmV0dXJuIEBOb3RGaWx0ZXJlZChzcHJpdGUpXHJcblxyXG4gICAgRmlsdGVyOiAoX2ZpbHRlcikgLT5cclxuICAgICAgICBAZmlsdGVyID0gX2ZpbHRlclxyXG5cclxuICAgIExpbWl0OiAoX2xpbWl0KSAtPlxyXG4gICAgICAgIEBsaW1pdCA9IF9saW1pdFxyXG5cclxuICAgIE1vZGU6IChfbW9kZSkgLT5cclxuICAgICAgICBtb2RlID0gX21vZGVcclxuXHJcbiAgICBVcGRhdGU6IC0+XHJcbiAgICAgICAgcmV0dXJuIGlmIG5vdCBAc3ByaXRlLmdhbWUgb3Igbm90IEBlbmFibGVkXHJcbiAgICAgICAgQGdhbWUgPSBAc3ByaXRlLmdhbWVcclxuICAgICAgICBhbnlDb2xsaXNpb25zID0gZmFsc2VcclxuXHJcbiAgICAgICAgZm9yIG90aGVyU3ByaXRlIGluIEBnYW1lLnRoaW5nc1xyXG4gICAgICAgICAgICBpZiBvdGhlclNwcml0ZS50b3JjaF90eXBlIGlzIFwiU3ByaXRlXCJcclxuICAgICAgICAgICAgICAgIGlmIEBzcHJpdGUuTm90U2VsZihvdGhlclNwcml0ZSkgYW5kIEBWYWxpZChvdGhlclNwcml0ZSlcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25EZXRlY3RlZCA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRGF0YSA9IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIEBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gQ29sbGlzaW9uLkFBQkJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkRhdGEgPSBAc3ByaXRlLkNvbGxpZGVzV2l0aChvdGhlclNwcml0ZSkuQUFCQigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25EZXRlY3RlZCA9IGNvbGxpc2lvbkRhdGEgaXNudCBmYWxzZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiBjb2xsaXNpb25EZXRlY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25EYXRhLnNlbGYgPSBAc3ByaXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkRhdGEuY29sbGlkZXIgPSBvdGhlclNwcml0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbnlDb2xsaXNpb25zID09IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgQHNwcml0ZS5FbWl0KFwiQ29sbGlzaW9uXCIsIG5ldyBUb3JjaC5FdmVudChAZ2FtZSwge2NvbGxpc2lvbkRhdGE6IGNvbGxpc2lvbkRhdGF9KSlcclxuXHJcbiAgICAgICAgQHNwcml0ZS5FbWl0KFwiTm9Db2xsaXNpb25cIiwgbmV3IFRvcmNoLkV2ZW50KEBnYW1lLCB7fSkpXHJcblxyXG4gICAgU2ltcGxlQ29sbGlzaW9uSGFuZGxlOiAoZXZlbnQsIHNpbmsgPSAxKSAtPlxyXG4gICAgICAgIG9mZnNldCA9IGV2ZW50LmNvbGxpc2lvbkRhdGFcclxuICAgICAgICB0b3VjaGluZyA9IHtsZWZ0OiBmYWxzZSwgcmlnaHQ6IGZhbHNlLCB0b3A6IGZhbHNlLCBib3R0b206IGZhbHNlfVxyXG4gICAgICAgIGlmIG9mZnNldC52eCA8IG9mZnNldC5oYWxmV2lkdGhzIGFuZCBvZmZzZXQudnkgPCBvZmZzZXQuaGFsZkhlaWdodHNcclxuICAgICAgICAgICAgaWYgb2Zmc2V0LnggPCBvZmZzZXQueVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIG9mZnNldC52eCA+IDBcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5jb2xsaXNpb25EYXRhLnNlbGYucG9zaXRpb24ueCArPSBvZmZzZXQueCAqIHNpbmtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZy5sZWZ0ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICNjb2xEaXIgPSBcImxcIlxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiBvZmZzZXQudnggPCAwXHJcbiAgICAgICAgICAgICAgICAgICAgI2NvbERpciA9IFwiclwiXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY29sbGlzaW9uRGF0YS5zZWxmLnBvc2l0aW9uLnggLT0gb2Zmc2V0LnggKiBzaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmcucmlnaHQgPSB0cnVlXHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIG9mZnNldC54ID4gb2Zmc2V0LnlcclxuXHJcbiAgICAgICAgICAgICAgICBpZiBvZmZzZXQudnkgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgI2NvbERpciA9IFwidFwiXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY29sbGlzaW9uRGF0YS5zZWxmLnBvc2l0aW9uLnkgKz0gb2Zmc2V0LnkgKiBzaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmcudG9wID0gdHJ1ZVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgIG9mZnNldC52eSA8IDBcclxuICAgICAgICAgICAgICAgICAgICAjY29sRGlyID0gXCJiXCJcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5jb2xsaXNpb25EYXRhLnNlbGYucG9zaXRpb24ueSAtPSBvZmZzZXQueSAqIHNpbmtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZy5ib3R0b20gPSB0cnVlXHJcblxyXG4gICAgICAgIHJldHVybiB0b3VjaGluZ1xyXG5cclxuICAgIENhc3RSYXk6IC0+XHJcbiAgICAgICAgIyAuLi5cclxuXG5jbGFzcyBMb29wXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG4gICAgICAgIEBmcHMgPSA1MFxyXG4gICAgICAgIEBmcmFtZVRpbWUgPSAxMDAwL0BmcHNcclxuICAgICAgICBAbGFnID0gMFxyXG4gICAgICAgIEB1cGRhdGVEZWx0YSA9IDBcclxuICAgICAgICBAZHJhd0RlbHRhID0gMFxyXG4gICAgICAgIEBsYWdPZmZzZXRcclxuICAgIFVwZGF0ZTogLT5cclxuICAgICAgICBAZ2FtZS51cGRhdGUoQGdhbWUpXHJcbiAgICAgICAgQGdhbWUuU3RhdGUuVXBkYXRlKClcclxuICAgICAgICBAZ2FtZS5HYW1lUGFkcy5VcGRhdGUoKVxyXG4gICAgICAgIEBnYW1lLlVwZGF0ZVRoaW5ncygpXHJcblxyXG4gICAgRHJhdzogLT5cclxuICAgICAgICBAZ2FtZS5kcmF3KEBnYW1lKVxyXG4gICAgICAgIEBnYW1lLkRyYXdUaGluZ3MoKVxyXG5cclxuXHJcbiAgICBBZHZhbmNlRnJhbWU6ICh0aW1lc3RhbXApIC0+XHJcbiAgICAgICAgaWYgQGdhbWUudGltZSBpcyB1bmRlZmluZWRcclxuICAgICAgICAgICAgQGdhbWUudGltZSA9IHRpbWVzdGFtcFxyXG5cclxuICAgICAgICBAZ2FtZS5kZWx0YVRpbWUgPSBNYXRoLnJvdW5kKHRpbWVzdGFtcCAtIEBnYW1lLnRpbWUpXHJcbiAgICAgICAgQGdhbWUudGltZSA9IHRpbWVzdGFtcFxyXG4gICAgICAgIGVsYXBzZWQgPSBAZ2FtZS5kZWx0YVRpbWVcclxuICAgICAgICBAZHJhd0RlbHRhID0gZWxhcHNlZFxyXG4gICAgICAgIEB1cGRhdGVEZWx0YSA9IEBmcmFtZVRpbWVcclxuXHJcbiAgICAgICAgaWYgZWxhcHNlZCA+IDEwMDBcclxuICAgICAgICAgICAgZWxhcHNlZCA9IEBmcmFtZVRpbWVcclxuXHJcbiAgICAgICAgQGxhZyArPSBlbGFwc2VkXHJcblxyXG4gICAgICAgIHdoaWxlIEBsYWcgPj0gQGZyYW1lVGltZVxyXG4gICAgICAgICAgICBAVXBkYXRlKClcclxuXHJcbiAgICAgICAgICAgIEBsYWcgLT0gQGZyYW1lVGltZVxyXG5cclxuICAgICAgICBAbGFnT2Zmc2V0ID0gQGxhZyAvIEBmcmFtZVRpbWVcclxuXHJcbiAgICAgICAgQERyYXcoKVxyXG5cclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICh0aW1lc3RhbXApID0+XHJcbiAgICAgICAgICAgIEBBZHZhbmNlRnJhbWUodGltZXN0YW1wKVxyXG5cclxuICAgIFJ1bjogKHRpbWVzdGFtcCkgLT5cclxuICAgICAgICBAQWR2YW5jZUZyYW1lKDApXHJcblxuY2xhc3MgQXNzZXRNYW5hZ2VyXHJcbiAgICBnYW1lOiBudWxsXHJcbiAgICB0ZXh0dXJlczogbnVsbFxyXG4gICAgYXVkaW86IG51bGxcclxuICAgIHZpZGVvOiBudWxsXHJcbiAgICBmaWxlczogbnVsbFxyXG4gICAgdGV4dHVyZUF0bGFzZXM6IG51bGxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG4gICAgICAgIEB0ZXh0dXJlcyA9IHt9XHJcbiAgICAgICAgQGF1ZGlvID0ge31cclxuICAgICAgICBAdmlkZW8gPSB7fVxyXG4gICAgICAgIEB0ZXh0dXJlQXRsYXNlcyA9IHt9XHJcbiAgICAgICAgQGZpbGVzID0ge31cclxuXHJcbiAgICBHZXRUZXh0dXJlOiAoaWQpIC0+XHJcbiAgICAgICAgcmV0dXJuIEB0ZXh0dXJlc1tpZF1cclxuXHJcbiAgICBHZXRBdWRpbzogKGlkKSAtPlxyXG4gICAgICAgIHJldHVybiBAYXVkaW9baWRdXHJcblxyXG4gICAgR2V0VmlkZW86IChpZCkgLT5cclxuICAgICAgICByZXR1cm4gQHZpZGVvW2lkXVxyXG5cclxuICAgIEdldFRleHR1cmVBdGxhczogKGlkKSAtPlxyXG4gICAgICAgIHJldHVybiBAdGV4dHVyZUF0bGFzZXNbaWRdXHJcblxyXG4gICAgR2V0RmlsZTogKGlkKSAtPlxyXG4gICAgICAgIHJldHVybiBAZmlsZXNbaWRdXHJcblxuTG9hZFR5cGUgPSBVdGlsLkVudW0oXCJUZXh0dXJlXCIsIFwiQXVkaW9cIiwgXCJWaWRlb1wiLCBcIkZpbGVcIiwgXCJUZXh0dXJlQXRsYXNcIilcclxuXHJcbmNsYXNzIExvYWRKb2JcclxuICAgIGNvbnN0cnVjdG9yOiAoQGxvYWRUeXBlLCBAaWQsIEBwYXRoKSAtPlxyXG5cclxuY2xhc3MgTG9hZFxyXG4gICAgIyBUT0RPOlxyXG4gICAgIyBXYXJuIHdoZW4gYXNzZXRzIGFyZSBvdmVyd3JpdHRlblxyXG5cclxuICAgIEBNaXhJbiBFdmVudERpc3BhdGNoZXJcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG4gICAgICAgIEBJbml0RXZlbnREaXNwYXRjaCgpXHJcblxyXG4gICAgICAgIEBmaWxlcyA9IEBnYW1lLkFzc2V0cy5maWxlc1xyXG4gICAgICAgIEB0ZXh0dXJlcyA9IEBnYW1lLkFzc2V0cy50ZXh0dXJlc1xyXG4gICAgICAgIEBhdWRpbyA9IEBnYW1lLkFzc2V0cy5hdWRpb1xyXG4gICAgICAgIEB2aWRlbyA9IEBnYW1lLkFzc2V0cy52aWRlb1xyXG4gICAgICAgIEB0ZXh0dXJlQXRsYXNlcyA9IEBnYW1lLkFzc2V0cy50ZXh0dXJlQXRsYXNlc1xyXG5cclxuICAgICAgICBAbG9hZEpvYnMgPSBbXVxyXG5cclxuICAgICAgICBAaXRlbXNMZWZ0VG9Mb2FkID0gMFxyXG4gICAgICAgIEBwcm9ncmVzcyA9IDBcclxuXHJcbiAgICAgICAgQGxvYWRlZCA9IGZhbHNlXHJcblxyXG4gICAgICAgIEBsb2FkTG9nID0gXCJcIlxyXG5cclxuICAgIEF1ZGlvOiAocGF0aCwgaWQpIC0+XHJcbiAgICAgICAgQGxvYWRKb2JzLnB1c2goIG5ldyBMb2FkSm9iKExvYWRUeXBlLkF1ZGlvLCBpZCwgcGF0aCkgKVxyXG5cclxuICAgIFRleHR1cmU6IChwYXRoLCBpZCkgLT5cclxuICAgICAgICBAbG9hZEpvYnMucHVzaCggbmV3IExvYWRKb2IoTG9hZFR5cGUuVGV4dHVyZSwgaWQsIHBhdGgpIClcclxuXHJcbiAgICBUZXh0dXJlQXRsYXM6IChwYXRoLCBpZCkgLT5cclxuICAgICAgICBAbG9hZEpvYnMucHVzaCggbmV3IExvYWRKb2IoTG9hZFR5cGUuVGV4dHVyZUF0bGFzLCBpZCwgcGF0aCkgKVxyXG5cclxuICAgIFZpZGVvOiAocGF0aCwgaWQpIC0+XHJcbiAgICAgICAgQGxvYWRKb2JzLnB1c2goIG5ldyBMb2FkSm9iKExvYWRUeXBlLlZpZGVvLCBpZCwgcGF0aCkgKVxyXG5cclxuICAgIEZpbGU6IChwYXRoLCBpZCkgLT5cclxuICAgICAgICBAbG9hZEpvYnMucHVzaCggbmV3IExvYWRKb2IoTG9hZFR5cGUuRmlsZSwgaWQsIHBhdGgpIClcclxuXHJcbiAgICBGb250OiAocGF0aCwgbmFtZSkgLT5cclxuICAgICAgICAjIHRoaXMgY2FuIGJlIGRvbmUgcmlnaHQgb2ZmIHRoZSBiYXRcclxuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxyXG4gICAgICAgIG1hbnVhbExvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpXHJcblxyXG4gICAgICAgIGNzc0ZvbnRSdWxlID0gXCJcIlwiXHJcbiAgICAgICAgICAgIEBmb250LWZhY2V7XHJcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogI3tuYW1lfTtcclxuICAgICAgICAgICAgICAgIHNyYzogdXJsKCN7cGF0aH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXCJcIlwiXHJcbiAgICAgICAgY3NzRm9udFJ1bGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NGb250UnVsZSlcclxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NGb250UnVsZSlcclxuXHJcbiAgICAgICAgbWFudWFsTG9hZGVyLmlubmVySFRNTCA9IFwiVEVTVFwiXHJcbiAgICAgICAgbWFudWFsTG9hZGVyLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lXHJcblxyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtYW51YWxMb2FkZXIpXHJcblxyXG4gICAgICAgICNtYW51YWxMb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtYW51YWxMb2FkZXIpXHJcblxyXG4gICAgTG9hZEl0ZW1GaW5pc2hlZDogLT5cclxuICAgICAgICBAaXRlbXNMZWZ0VG9Mb2FkIC09IDFcclxuXHJcbiAgICAgICAgQHByb2dyZXNzID0gKEB0b3RhbExvYWQgLSBAaXRlbXNMZWZ0VG9Mb2FkKSAvIEB0b3RhbExvYWRcclxuXHJcbiAgICAgICAgQGdhbWUuRW1pdCBcIkxvYWRQcm9ncmVzc2VkXCIsIG5ldyBFdmVudCBAZ2FtZSxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IEBwcm9ncmVzc1xyXG5cclxuICAgICAgICBpZiBAaXRlbXNMZWZ0VG9Mb2FkIDw9IDBcclxuICAgICAgICAgICAgIyBsb2FkIGhhcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZm9udC1sb2FkZXJcIilbMF0/LnJlbW92ZSgpXHJcbiAgICAgICAgICAgIHRpbWVUb0xvYWQgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBAc3RhcnRUaW1lKSAvIDEwMDBcclxuXHJcbiAgICAgICAgICAgIEBFbWl0IFwiTG9hZEZpbmlzaGVkXCIsIG5ldyBFdmVudCBAZ2FtZSxcclxuICAgICAgICAgICAgICAgIHRpbWVUb0xvYWQ6IHRpbWVUb0xvYWRcclxuXHJcbiAgICAgICAgICAgICMgc3VjY2Vzc2Z1bCBsb2FkXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nIFwiJWMje0BnYW1lLm5hbWV9IGxvYWRlZCBpbiAje3RpbWVUb0xvYWR9c1wiLFxyXG4gICAgICAgICAgICAgICAgXCJcIlwiYmFja2dyb3VuZC1jb2xvcjpncmVlbjtcclxuICAgICAgICAgICAgICAgICAgIGNvbG9yOndoaXRlO1xyXG4gICAgICAgICAgICAgICAgICAgcGFkZGluZzoycHg7XHJcbiAgICAgICAgICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OjVweDtcclxuICAgICAgICAgICAgICAgICAgIHBhZGRpbmctbGVmdDo1cHhcIlwiXCJcclxuXHJcbiAgICBMb2FkOiAtPlxyXG4gICAgICAgIEB0b3RhbExvYWQgPSBAbG9hZEpvYnMubGVuZ3RoXHJcbiAgICAgICAgQGl0ZW1zTGVmdFRvTG9hZCA9IEB0b3RhbExvYWRcclxuXHJcbiAgICAgICAgQHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXHJcblxyXG4gICAgICAgIHRyeVxyXG4gICAgICAgICAgICBmb3IgbG9hZEpvYiBpbiBAbG9hZEpvYnNcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggbG9hZEpvYi5sb2FkVHlwZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGVuIExvYWRUeXBlLlRleHR1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgQExvYWRUZXh0dXJlKGxvYWRKb2IpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoZW4gTG9hZFR5cGUuVmlkZW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgQExvYWRWaWRlbyhsb2FkSm9iKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGVuIExvYWRUeXBlLkF1ZGlvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBMb2FkQXVkaW8obG9hZEpvYilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hlbiBMb2FkVHlwZS5GaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBMb2FkRmlsZShsb2FkSm9iKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGVuIExvYWRUeXBlLlRleHR1cmVBdGxhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBATG9hZFRleHR1cmVBdGxhcyhsb2FkSm9iKVxyXG5cclxuICAgICAgICBjYXRjaCBlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nIFwiJWMje0BnYW1lLm5hbWV9IGNvdWxkIG5vdCBsb2FkIVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiXCJiYWNrZ3JvdW5kLWNvbG9yOiN7Q29sb3IuUnVieX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOndoaXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjJweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZy1yaWdodDo1cHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmctbGVmdDo1cHhcIlwiXCJcclxuICAgICAgICAgICAgVG9yY2guRmF0YWxFcnJvcihlKVxyXG5cclxuICAgIExvYWRUZXh0dXJlOiAobG9hZEpvYikgLT5cclxuICAgICAgICBpbSA9IG5ldyBJbWFnZSgpXHJcbiAgICAgICAgaW0uc3JjID0gbG9hZEpvYi5wYXRoXHJcblxyXG4gICAgICAgIEB0ZXh0dXJlc1tsb2FkSm9iLmlkXSA9IGltXHJcblxyXG4gICAgICAgIGltLm9ubG9hZCA9ID0+XHJcbiAgICAgICAgICAgIEBMb2FkSXRlbUZpbmlzaGVkKClcclxuXHJcbiAgICBMb2FkVGV4dHVyZUF0bGFzOiAobG9hZEpvYikgLT5cclxuICAgICAgICBsb2FkZXIgPSBuZXcgVG9yY2guQWpheExvYWRlcihsb2FkSm9iLnBhdGgsIFRvcmNoLkFqYXhEYXRhLlRleHQpXHJcbiAgICAgICAgbG9hZGVyLmxvYWRKb2IgPSBsb2FkSm9iXHJcbiAgICAgICAgbG9hZGVyLkZpbmlzaCAoZGF0YSwgbG9hZGVyKSA9PlxyXG4gICAgICAgICAgICBATG9hZEl0ZW1GaW5pc2hlZCgpXHJcbiAgICAgICAgICAgIEB0ZXh0dXJlQXRsYXNlc1tsb2FkZXIubG9hZEpvYi5pZF0gPSBKU09OLnBhcnNlKGRhdGEpXHJcbiAgICAgICAgbG9hZGVyLkxvYWQoKVxyXG5cclxuICAgIExvYWRWaWRlbzogKGxvYWRKb2IpIC0+XHJcbiAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIilcclxuICAgICAgICB2aWRlby5zcmMgPSBsb2FkSm9iLnBhdGhcclxuXHJcbiAgICAgICAgQHZpZGVvW2xvYWRKb2IuaWRdID0gdmlkZW9cclxuXHJcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lciBcImxvYWRlZGRhdGFcIiwgPT5cclxuICAgICAgICAgICAgQExvYWRJdGVtRmluaXNoZWQoKVxyXG5cclxuICAgIExvYWRBdWRpbzogKGxvYWRKb2IpIC0+XHJcbiAgICAgICAgbG9hZGVyID0gbmV3IFRvcmNoLkFqYXhMb2FkZXIobG9hZEpvYi5wYXRoLCBUb3JjaC5BamF4RGF0YS5BcnJheUJ1ZmZlcilcclxuICAgICAgICBsb2FkZXIubG9hZEpvYiA9IGxvYWRKb2JcclxuICAgICAgICBsb2FkZXIuRmluaXNoIChkYXRhLCBsb2FkZXIpID0+XHJcbiAgICAgICAgICAgIEBhdWRpb1tsb2FkZXIubG9hZEpvYi5pZF0gPSB7fVxyXG4gICAgICAgICAgICBAYXVkaW9bbG9hZGVyLmxvYWRKb2IuaWRdLmVuY29kZWRBdWRpb0RhdGEgPSBkYXRhXHJcbiAgICAgICAgICAgIEBnYW1lLkF1ZGlvLkRlY29kZUF1ZGlvRGF0YSBkYXRhLCAoYnVmZmVyKSA9PlxyXG4gICAgICAgICAgICAgICAgQGF1ZGlvW2xvYWRlci5sb2FkSm9iLmlkXS5hdWRpb0RhdGEgPSBidWZmZXJcclxuICAgICAgICAgICAgICAgIEBMb2FkSXRlbUZpbmlzaGVkKClcclxuICAgICAgICBsb2FkZXIuTG9hZCgpXHJcblxyXG4gICAgTG9hZEZpbGU6IChsb2FkSm9iKSAtPlxyXG4gICAgICAgIGxvYWRlciA9IG5ldyBUb3JjaC5BamF4TG9hZGVyKGxvYWRKb2IucGF0aCwgVG9yY2guQWpheERhdGEuVGV4dClcclxuICAgICAgICBsb2FkZXIubG9hZEpvYiA9IGxvYWRKb2JcclxuICAgICAgICBsb2FkZXIuRmluaXNoIChkYXRhLCBsb2FkZXIpID0+XHJcbiAgICAgICAgICAgIEBMb2FkSXRlbUZpbmlzaGVkKClcclxuICAgICAgICAgICAgQGZpbGVzW2xvYWRlci5sb2FkSm9iLmlkXSA9IGRhdGFcclxuICAgICAgICBsb2FkZXIuTG9hZCgpXHJcblxuY2xhc3MgVGltZXJcclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUpLT5cclxuXHJcbiAgICBTZXRGdXR1cmVFdmVudDogKHRpbWVUb09jY3VyLCBoYW5kbGUpIC0+XHJcbiAgICAgICAgZXYgPSBuZXcgRnV0dXJlRXZlbnQodGltZVRvT2NjdXIsIGhhbmRsZSwgQGdhbWUpXHJcbiAgICAgICAgQGdhbWUuQWRkKCBldiApXHJcblxyXG4gICAgICAgIHJldHVybiBldlxyXG5cclxuICAgIFNldFNjaGVkdWxlZEV2ZW50OiAoaW50ZXJ2YWwsIGhhbmRsZSkgLT5cclxuICAgICAgICBldiA9IG5ldyBTY2hlZHVsZWRFdmVudChpbnRlcnZhbCwgaGFuZGxlLCBAZ2FtZSlcclxuICAgICAgICBAZ2FtZS5BZGQoIGV2IClcclxuXHJcbiAgICAgICAgcmV0dXJuIGV2XHJcblxyXG5jbGFzcyBGdXR1cmVFdmVudCBleHRlbmRzIEdhbWVUaGluZ1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoQHRpbWVUb09jY3VyLCBAaGFuZGxlLCBAZ2FtZSkgLT5cclxuICAgICAgICBAdGltZSA9IDBcclxuICAgIFVwZGF0ZTogLT5cclxuICAgICAgICBAdGltZSArPSBAZ2FtZS5Mb29wLnVwZGF0ZURlbHRhXHJcbiAgICAgICAgaWYgQHRpbWUgPj0gQHRpbWVUb09jY3VyXHJcbiAgICAgICAgICAgIGlmIEBoYW5kbGUgaXNudCBudWxsIGFuZCBAaGFuZGxlIGlzbnQgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBAaGFuZGxlKClcclxuICAgICAgICAgICAgICAgIEBoYW5kbGUgPSBudWxsXHJcblxyXG5jbGFzcyBTY2hlZHVsZWRFdmVudCBleHRlbmRzIEdhbWVUaGluZ1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoQGludGVydmFsLCBAaGFuZGxlLCBAZ2FtZSkgLT5cclxuICAgICAgICBAZWxhcHNlZFRpbWUgPSAwXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIEBlbGFwc2VkVGltZSArPSBAZ2FtZS5Mb29wLnVwZGF0ZURlbHRhXHJcblxyXG4gICAgICAgIGlmIEBlbGFwc2VkVGltZSA+PSBAaW50ZXJ2YWxcclxuICAgICAgICAgICAgQGhhbmRsZSgpIGlmIEBoYW5kbGU/XHJcbiAgICAgICAgICAgIEBlbGFwc2VkVGltZSA9IDBcclxuXG5jbGFzcyBNb3VzZVxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSkgLT5cclxuICAgICAgICBAeCA9IDBcclxuICAgICAgICBAeSA9IDBcclxuICAgICAgICBAZG93biA9IGZhbHNlXHJcblxyXG4gICAgU2V0TW91c2VQb3M6IChjLCBldnQpIC0+XHJcbiAgICAgICAgcmVjdCA9IGMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICBAeCA9IGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0XHJcbiAgICAgICAgQHkgPSBldnQuY2xpZW50WSAtIHJlY3QudG9wXHJcblxyXG4gICAgR2V0UmVjdGFuZ2xlOiAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKEB4LCBAeSwgNSwgNSlcclxuXHJcbiAgICBTZXRDdXJzb3I6ICh0ZXh0dXJlSWQpIC0+XHJcbiAgICAgICAgdGV4dHVyZSA9IEBnYW1lLkFzc2V0cy5HZXRUZXh0dXJlKCB0ZXh0dXJlSWQgKVxyXG5cclxuICAgICAgICBAZ2FtZS5jYW52YXNOb2RlLnN0eWxlLmN1cnNvciA9IFwidXJsKCN7dGV4dHVyZS5zcmN9KSwgYXV0b1wiXHJcblxuY2xhc3MgQ2FtZXJhXHJcbiAgICBwb3NpdGlvbjogbnVsbFxyXG4gICAgX2plcmtGb2xsb3c6IG51bGxcclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUpIC0+XHJcbiAgICAgICAgQHBvc2l0aW9uID0gbmV3IFBvaW50KDAsMClcclxuICAgICAgICBAVmlld3BvcnQgPSBuZXcgVmlld3BvcnQoQClcclxuXHJcbiAgICBKZXJrRm9sbG93OiAoc3ByaXRlLCBvZmZzZXQgPSA1LCBjb25maWcpIC0+XHJcbiAgICAgICAgaWYgbm90IGNvbmZpZz9cclxuICAgICAgICAgICAgY29uZmlnID1cclxuICAgICAgICAgICAgICAgIG1heExlZnQ6IC01MDBcclxuICAgICAgICAgICAgICAgIG1heFJpZ2h0OiAyMDAwXHJcbiAgICAgICAgICAgICAgICBtYXhUb3A6IC01MDBcclxuICAgICAgICAgICAgICAgIG1heEJvdHRvbTogMjAwMFxyXG5cclxuICAgICAgICBAX2plcmtGb2xsb3cgPSBuZXcgSmVya0ZvbGxvdyhALCBzcHJpdGUsIG9mZnNldCwgY29uZmlnKVxyXG4gICAgICAgIEBnYW1lLkFkZCggQF9qZXJrRm9sbG93IClcclxuXHJcbmNsYXNzIFZpZXdwb3J0XHJcbiAgICB3aWR0aDogMFxyXG4gICAgaGVpZ2h0OiAwXHJcbiAgICBtYXhXaWR0aDogMFxyXG4gICAgbWF4SGVpZ2h0OiAwXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBjYW1lcmEpIC0+XHJcbiAgICAgICAgQG1heFdpZHRoID0gQHdpZHRoID0gd2luZG93LmlubmVyV2lkdGhcclxuICAgICAgICBAbWF4SGVpZ2h0ID0gQGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxyXG4gICAgICAgIEByZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKEBjYW1lcmEucG9zaXRpb24ueCwgQGNhbWVyYS5wb3NpdGlvbi55LCBAd2lkdGgsIEBoZWlnaHQpXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIEByZWN0YW5nbGUueCA9IEBjYW1lcmEucG9zaXRpb24ueFxyXG4gICAgICAgIEByZWN0YW5nbGUueSA9IEBjYW1lcmEucG9zaXRpb24ueVxyXG4gICAgICAgIEByZWN0YW5nbGUud2lkdGggPSBAd2lkdGhcclxuICAgICAgICBAcmVjdGFuZ2xlLmhlaWdodCA9IEBoZWlnaHRcclxuXHJcbmNsYXNzIEplcmtGb2xsb3cgZXh0ZW5kcyBHYW1lVGhpbmdcclxuICAgIGJvdW5kTGVmdDogMFxyXG4gICAgYm91bmRSaWdodDogMFxyXG4gICAgYm91bmRUb3A6IDBcclxuICAgIGJvdW5kQm90dG9tOiAwXHJcbiAgICBJbmM6IDBcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBjYW1lcmEsIEBzcHJpdGUsIG9mZnNldCwgQGNvbmZpZykgLT5cclxuICAgICAgICB2ID0gQGNhbWVyYS5WaWV3cG9ydFxyXG4gICAgICAgIEBnYW1lID0gQGNhbWVyYS5nYW1lXHJcbiAgICAgICAgQEluYyA9IHYud2lkdGggLyBvZmZzZXRcclxuICAgICAgICBAYm91bmRMZWZ0ID0gdi53aWR0aCAvIG9mZnNldFxyXG4gICAgICAgIEBib3VuZFJpZ2h0ID0gdi53aWR0aCAtIEBib3VuZExlZnRcclxuICAgICAgICBAYm91bmRUb3AgPSAwXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGlmIEBzcHJpdGUucG9zaXRpb24ueCA+PSBAYm91bmRSaWdodFxyXG5cclxuICAgICAgICAgICAgaWYgQHNwcml0ZS5wb3NpdGlvbi54ID49IEBjb25maWcubWF4UmlnaHRcclxuICAgICAgICAgICAgICAgIEBzcHJpdGUucG9zaXRpb24ueCA9IEBib3VuZFJpZ2h0XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuXHJcbiAgICAgICAgICAgIEBib3VuZFJpZ2h0ICs9IEBJbmNcclxuICAgICAgICAgICAgQGJvdW5kTGVmdCArPSBASW5jXHJcblxyXG4gICAgICAgICAgICBAZ2FtZS5Ud2VlbnMuVHdlZW4oIEBjYW1lcmEucG9zaXRpb24sIDUwMCwgVG9yY2guRWFzaW5nLlNtb290aCApLlRvKHt4OiBAY2FtZXJhLnBvc2l0aW9uLnggLSBASW5jfSlcclxuXHJcbiAgICAgICAgaWYgQHNwcml0ZS5wb3NpdGlvbi54IDw9IEBib3VuZExlZnRcclxuXHJcbiAgICAgICAgICAgIGlmIEBzcHJpdGUucG9zaXRpb24ueCA8PSBAY29uZmlnLm1heExlZnRcclxuICAgICAgICAgICAgICAgIEBzcHJpdGUucG9zaXRpb24ueCA9IEBib3VuZExlZnRcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG5cclxuICAgICAgICAgICAgQGJvdW5kUmlnaHQgLT0gQEluY1xyXG4gICAgICAgICAgICBAYm91bmRMZWZ0IC09IEBJbmNcclxuXHJcbiAgICAgICAgICAgIEBnYW1lLlR3ZWVucy5Ud2VlbiggQGNhbWVyYS5wb3NpdGlvbiwgNTAwLCBUb3JjaC5FYXNpbmcuU21vb3RoICkuVG8oe3g6IEBjYW1lcmEucG9zaXRpb24ueCArIEBJbmN9KVxyXG5cclxuICAgICAgICBpZiBAc3ByaXRlLnBvc2l0aW9uLnkgPD0gQGJvdW5kVG9wXHJcblxyXG4gICAgICAgICAgICBpZiBAc3ByaXRlLnBvc2l0aW9uLnkgPD0gQGNvbmZpZy5tYXhUb3BcclxuICAgICAgICAgICAgICAgIEBzcHJpdGUucG9zaXRpb24ueSA9IEBib3VuZFRvcFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcblxyXG4gICAgICAgICAgICBAYm91bmRUb3AgLT0gQEluY1xyXG4gICAgICAgICAgICBAYm91bmRCb3R0b20gLT0gQEluY1xyXG5cclxuICAgICAgICAgICAgQGdhbWUuVHdlZW5zLlR3ZWVuKCBAY2FtZXJhLnBvc2l0aW9uLCA1MDAsIFRvcmNoLkVhc2luZy5TbW9vdGggKS5Ubyh7eDogQGNhbWVyYS5wb3NpdGlvbi55ICsgQEluY30pXHJcblxuY2xhc3MgTGF5ZXJcclxuICAgIGNvbnN0cnVjdG9yOiAoQGRyYXdJbmRleCktPlxyXG4gICAgICAgIEBjaGlsZHJlbiA9IFtdXHJcbiAgICAgICAgQG1hcEluZGV4IC0gQGRyYXdJbmRleFxyXG5cclxuICAgIERyYXdJbmRleDogKGluZGV4KSAtPlxyXG4gICAgICAgIHJldHVybiBAZHJhd0luZGV4IGlmIG5vdCBpbmRleFxyXG5cclxuICAgICAgICBAZHJhd0luZGV4ID0gaW5kZXhcclxuICAgICAgICBmb3IgY2hpbGQgaW4gQGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGNoaWxkLkRyYXdJbmRleChpbmRleClcclxuXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbiAgICBBZGQ6IChjaGlsZCkgLT5cclxuICAgICAgICBjaGlsZC5EcmF3SW5kZXgoQGluZGV4KVxyXG4gICAgICAgIEBjaGlsZHJlbi5wdXNoKGNoaWxkKVxyXG5cclxuY2xhc3MgTGF5ZXJzXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG4gICAgICAgIEBsYXllcnMgPSBbXVxyXG4gICAgICAgIEBsYXllck1hcCA9IHt9XHJcblxyXG4gICAgQWRkOiAobGF5ZXJOYW1lKSAtPlxyXG4gICAgICAgIGxheWVyID0gbnVsbFxyXG4gICAgICAgIGlmIHR5cGVvZiBsYXllck5hbWUgaXMgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICBsYXllciA9IG5ldyBMYXllciggQGxheWVycy5sZW5ndGggKVxyXG4gICAgICAgICAgICBAbGF5ZXJOYW1lW2xheWVyTmFtZV0gPSBsYXllclxyXG4gICAgICAgICAgICBAbGF5ZXJzLmFkZCggbGF5ZXIgKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZm9yIG5hbWUgaW4gbGF5ZXJOYW1lXHJcbiAgICAgICAgICAgICAgICBsYXllciA9IG5ldyBMYXllciggQGxheWVycy5sZW5ndGggKVxyXG4gICAgICAgICAgICAgICAgQGxheWVyTWFwW25hbWVdID0gbGF5ZXJcclxuICAgICAgICAgICAgICAgIEBsYXllcnMuYWRkKCBsYXllciApXHJcblxyXG4gICAgUmVtb3ZlOiAobGF5ZXJOYW1lLCB0cnlUb0ZpbGwpIC0+XHJcbiAgICAgICAgaWYgbm90IEBsYXllck1hcFtsYXllck5hbWVdXHJcbiAgICAgICAgICAgIFRvcmNoLkZhdGFsRXJyb3IoXCJVbmFibGUgdG8gcmVtb3ZlIGxheWVyICcjeyBsYXllck5hbWUgfScuIExheWVyIGRvZXMgbm90IGV4aXN0XCIpXHJcblxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgY2xlYW5lZExheWVycyA9IFtdXHJcbiAgICAgICAgICAgIGxheWVyID0gbGF5ZXJNYXBbbGF5ZXJOYW1lXVxyXG4gICAgICAgICAgICBsYXllci5UcmFzaCgpXHJcblxyXG4gICAgICAgICAgICBkZWxldGUgQGxheWVyTWFwW2xheWVyTmFtZV1cclxuXHJcbiAgICAgICAgICAgIGZvciBpdGVtLGluZGV4IGluIEBsYXllcnNcclxuICAgICAgICAgICAgICAgIGwgPSBjbGVhbmVkTGF5ZXJzW2luZGV4XVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIGluZGV4IGlzbnQgbGF5ZXIubWFwSW5kZXhcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbmVkTGF5ZXJzLnB1c2gobClcclxuICAgICAgICAgICAgICAgICAgICBsLkRyYXdJbmRleCggbC5EcmF3SW5kZXgoKSAtIDEgKSBpZiB0cnlUb0ZpbGxcclxuXHJcblxyXG4gICAgR2V0OiAobGF5ZXJOYW1lKSAtPlxyXG4gICAgICAgIGlmIG5vdCBAbGF5ZXJNYXBbbGF5ZXJOYW1lXVxyXG4gICAgICAgICAgICBUb3JjaC5GYXRhbEVycm9yKFwiVW5hYmxlIHRvIGdldCBsYXllciAnI3sgbGF5ZXJOYW1lIH0nLiBMYXllciBkb2VzIG5vdCBleGlzdFwiKVxyXG5cclxuICAgICAgICBlbHNlIHJldHVybiBAbGF5ZXJNYXBbbGF5ZXJOYW1lXVxyXG5cbmNsYXNzIEtleVxyXG4gICAgS2V5Lk1peEluKEV2ZW50RGlzcGF0Y2hlcilcclxuXHJcbiAgICBkb3duIDogZmFsc2VcclxuICAgIGNvbnN0cnVjdG9yOiAoQGtleUNvZGUpIC0+XHJcbiAgICAgICAgQEluaXRFdmVudERpc3BhdGNoKClcclxuXHJcblxyXG5cclxuY2xhc3MgS2V5c1xyXG4gICAgS2V5cy5NaXhJbihFdmVudERpc3BhdGNoZXIpXHJcblxyXG4gICAgY29uc3RydWN0b3I6IC0+XHJcbiAgICAgICAgQHNwZWNpYWxLZXlzID1cclxuICAgICAgICAgICAgODogXCJEZWxldGVcIlxyXG4gICAgICAgICAgICA5OiBcIlRhYlwiXHJcbiAgICAgICAgICAgIDEzOiBcIkVudGVyXCJcclxuICAgICAgICAgICAgMTY6IFwiU2hpZnRcIlxyXG4gICAgICAgICAgICAxNzogXCJDb250cm9sXCJcclxuICAgICAgICAgICAgMTg6IFwiQWx0XCJcclxuICAgICAgICAgICAgMTk6IFwiUGF1c2VCcmVha1wiXHJcbiAgICAgICAgICAgIDIwOiBcIkNhcHNMb2NrXCJcclxuICAgICAgICAgICAgMjc6IFwiRXNjYXBlXCJcclxuICAgICAgICAgICAgMzI6IFwiU3BhY2VcIlxyXG4gICAgICAgICAgICAzMzogXCJQYWdlVXBcIlxyXG4gICAgICAgICAgICAzNDogXCJQYWdlRG93blwiXHJcbiAgICAgICAgICAgIDM1OiBcIkVuZFwiXHJcbiAgICAgICAgICAgIDM2OiBcIkhvbWVcIlxyXG4gICAgICAgICAgICAzNzogXCJMZWZ0QXJyb3dcIlxyXG4gICAgICAgICAgICAzODogXCJVcEFycm93XCJcclxuICAgICAgICAgICAgMzk6IFwiUmlnaHRBcnJvd1wiXHJcbiAgICAgICAgICAgIDQwOiBcIkRvd25BcnJvd1wiXHJcbiAgICAgICAgICAgIDQ1OiBcIkluc2VydFwiXHJcbiAgICAgICAgICAgIDQ2OiBcIkRlbGV0ZTJcIlxyXG4gICAgICAgICAgICA0ODogXCJOdW0wXCJcclxuICAgICAgICAgICAgNDk6IFwiTnVtMVwiXHJcbiAgICAgICAgICAgIDUwOiBcIk51bTJcIlxyXG4gICAgICAgICAgICA1MTogXCJOdW0zXCJcclxuICAgICAgICAgICAgNTI6IFwiTnVtNFwiXHJcbiAgICAgICAgICAgIDUzOiBcIk51bTVcIlxyXG4gICAgICAgICAgICA1NDogXCJOdW02XCJcclxuICAgICAgICAgICAgNTU6IFwiTnVtN1wiXHJcbiAgICAgICAgICAgIDU2OiBcIk51bThcIlxyXG4gICAgICAgICAgICA1NzogXCJOdW05XCJcclxuICAgICAgICAgICAgOTY6IFwiTnVtUGFkMFwiXHJcbiAgICAgICAgICAgIDk3OiBcIk51bVBhZDFcIlxyXG4gICAgICAgICAgICA5ODogXCJOdW1QYWQyXCJcclxuICAgICAgICAgICAgOTk6IFwiTnVtUGFkM1wiXHJcbiAgICAgICAgICAgIDEwMDogXCJOdW1QYWQ0XCJcclxuICAgICAgICAgICAgMTAxOiBcIk51bVBhZDVcIlxyXG4gICAgICAgICAgICAxMDI6IFwiTnVtUGFkNlwiXHJcbiAgICAgICAgICAgIDEwMzogXCJOdW1QYWQ3XCJcclxuICAgICAgICAgICAgMTA0OiBcIk51bVBhZDhcIlxyXG4gICAgICAgICAgICAxMDU6IFwiTnVtUGFkOVwiXHJcbiAgICAgICAgICAgIDEwNjogXCJOdW1QYWRNdWx0aXBseVwiXHJcbiAgICAgICAgICAgIDEwNzogXCJOdW1QYWRQbHVzXCJcclxuICAgICAgICAgICAgMTA5OiBcIk51bVBhZE1pbnVzXCJcclxuICAgICAgICAgICAgMTEwOiBcIk51bVBhZFBlcmlvZFwiXHJcbiAgICAgICAgICAgIDExMTogXCJOdW1QYWREaXZpZGVcIlxyXG4gICAgICAgICAgICAxMTI6IFwiRjFcIlxyXG4gICAgICAgICAgICAxMTM6IFwiRjJcIlxyXG4gICAgICAgICAgICAxMTQ6IFwiRjNcIlxyXG4gICAgICAgICAgICAxMTU6IFwiRjRcIlxyXG4gICAgICAgICAgICAxMTY6IFwiRjVcIlxyXG4gICAgICAgICAgICAxMTc6IFwiRjZcIlxyXG4gICAgICAgICAgICAxMTg6IFwiRjdcIlxyXG4gICAgICAgICAgICAxMTk6IFwiRjhcIlxyXG4gICAgICAgICAgICAxMjA6IFwiRjlcIlxyXG4gICAgICAgICAgICAxMjE6IFwiRjEwXCJcclxuICAgICAgICAgICAgMTIyOiBcIkYxMVwiXHJcbiAgICAgICAgICAgIDEyMzogXCJGMTJcIlxyXG4gICAgICAgICAgICAxNDQ6IFwiTnVtTG9ja1wiXHJcbiAgICAgICAgICAgIDE0NTogXCJTY3JvbGxMb2NrXCJcclxuICAgICAgICAgICAgMTg2OiBcIkNvbG9uXCJcclxuICAgICAgICAgICAgMTg3OiBcIk51bVBsdXNcIlxyXG4gICAgICAgICAgICAxODg6IFwiQ29tbWFcIlxyXG4gICAgICAgICAgICAxODk6IFwiTnVtTWludXNcIlxyXG4gICAgICAgICAgICAxOTA6IFwiUGVyaW9kXCJcclxuICAgICAgICAgICAgMTkxOiBcIkZvcndhcmRTbGFzaFwiXHJcbiAgICAgICAgICAgIDE5MjogXCJUaWxkYVwiXHJcbiAgICAgICAgICAgIDIxOTogXCJCcmFja2V0TGVmdFwiXHJcbiAgICAgICAgICAgIDIyMTogXCJCcmFja2V0UmlnaHRcIlxyXG4gICAgICAgICAgICAyMjA6IFwiQmFja1NsYXNoXCJcclxuICAgICAgICAgICAgMjIyOiBcIlF1b3RlXCJcclxuXHJcbiAgICAgICAgQEluaXRLZXlzKClcclxuXHJcbiAgICBTcGVjaWFsS2V5OiAoa2V5Q29kZSkgLT5cclxuICAgICAgICBmb3Iga2V5LHZhbHVlIG9mIEBzcGVjaWFsS2V5c1xyXG4gICAgICAgICAgICBpZiBrZXlDb2RlLnRvU3RyaW5nKCkgaXMga2V5LnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIHJldHVybiBAW3ZhbHVlXVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG5cclxuICAgIEluaXRLZXlzOiAtPlxyXG4gICAgICAgIF9rZXlzID0gQFxyXG4gICAgICAgIGkgPSAwXHJcbiAgICAgICAgd2hpbGUgaSA8IDIzMFxyXG4gICAgICAgICAgICBfY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSkudG9VcHBlckNhc2UoKVxyXG4gICAgICAgICAgICBfa2V5c1tfY2hhcl0gPSBuZXcgS2V5KGkpXHJcbiAgICAgICAgICAgIGkrK1xyXG5cclxuICAgICAgICBmb3Iga2V5Q29kZSx2YWx1ZSBvZiBAc3BlY2lhbEtleXNcclxuICAgICAgICAgICAgX2tleXNbdmFsdWVdID0gbmV3IEtleShrZXlDb2RlKVxyXG5cbmNsYXNzIFR3ZWVuIGV4dGVuZHMgR2FtZVRoaW5nXHJcbiAgICBATWl4SW4gRXZlbnREaXNwYXRjaGVyXHJcblxyXG4gICAgb2JqZWN0VG9Ud2VlbjogbnVsbFxyXG4gICAgdHdlZW5Qcm9wZXJ0aWVzOiBudWxsXHJcbiAgICBvcmlnaW5hbE9iamVjdFZhbHVlczogbnVsbFxyXG4gICAgZWxhcHNlZFRpbWU6IDBcclxuICAgIHRpbWVUd2VlblNob3VsZFRha2U6IDBcclxuICAgIGVhc2luZzogbnVsbFxyXG4gICAgcmVwZWF0OiBmYWxzZVxyXG4gICAgY3ljbGU6IGZhbHNlXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSwgQG9iamVjdFRvVHdlZW4sIEB0d2VlblByb3BlcnRpZXMsIEB0aW1lVHdlZW5TaG91bGRUYWtlLCBAZWFzaW5nKSAtPlxyXG4gICAgICAgIEBJbml0RXZlbnREaXNwYXRjaCgpXHJcbiAgICAgICAgQGdhbWUuVHdlZW5zLnR3ZWVucy5wdXNoKEApXHJcbiAgICAgICAgQGdhbWUuQWRkKCBAIClcclxuXHJcbiAgICAgICAgQG9yaWdpbmFsT2JqZWN0VmFsdWVzID0ge31cclxuXHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAdHdlZW5Qcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIEBvcmlnaW5hbE9iamVjdFZhbHVlc1trZXldID0gQG9iamVjdFRvVHdlZW5ba2V5XVxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIG5vcm1hbGl6ZWRUaW1lID0gQGVsYXBzZWRUaW1lIC8gQHRpbWVUd2VlblNob3VsZFRha2VcclxuICAgICAgICBlYXNlZFRpbWUgPSBARWFzZShub3JtYWxpemVkVGltZSlcclxuXHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBAdHdlZW5Qcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIEBvYmplY3RUb1R3ZWVuW2tleV0gPSAoQHR3ZWVuUHJvcGVydGllc1trZXldICogZWFzZWRUaW1lKSArIChAb3JpZ2luYWxPYmplY3RWYWx1ZXNba2V5XSAqICgxIC0gZWFzZWRUaW1lKSlcclxuXHJcbiAgICAgICAgQGVsYXBzZWRUaW1lICs9IEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuICAgICAgICBpZiBAZWxhcHNlZFRpbWUgPj0gQHRpbWVUd2VlblNob3VsZFRha2VcclxuICAgICAgICAgICAgQEVtaXQgXCJGaW5pc2hcIiwgbmV3IFRvcmNoLkV2ZW50KEBnYW1lLCB7dHdlZW46IEB9KVxyXG5cclxuICAgICAgICAgICAgaWYgQGN5Y2xlXHJcbiAgICAgICAgICAgICAgICBAZWxhcHNlZFRpbWUgPSAwXHJcbiAgICAgICAgICAgICAgICB0bXAgPSBPYmplY3QuY3JlYXRlKCBAb3JpZ2luYWxPYmplY3RWYWx1ZXMgKVxyXG4gICAgICAgICAgICAgICAgQG9yaWdpbmFsT2JqZWN0VmFsdWVzID0gT2JqZWN0LmNyZWF0ZSggQHR3ZWVuUHJvcGVydGllcylcclxuICAgICAgICAgICAgICAgIEB0d2VlblByb3BlcnRpZXMgPSB0bXBcclxuXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIEBUcmFzaCgpXHJcblxyXG4gICAgQ3ljbGU6IC0+XHJcbiAgICAgICAgQGN5Y2xlID0gdHJ1ZVxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgRWFzZTogKG5vcm1hbGl6ZWRUaW1lKSAtPlxyXG4gICAgICAgIHN3aXRjaCBAZWFzaW5nXHJcbiAgICAgICAgICAgIHdoZW4gVG9yY2guRWFzaW5nLkxpbmVhclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRUaW1lXHJcblxyXG4gICAgICAgICAgICB3aGVuIFRvcmNoLkVhc2luZy5TcXVhcmVcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhub3JtYWxpemVkVGltZSwgMilcclxuXHJcbiAgICAgICAgICAgIHdoZW4gVG9yY2guRWFzaW5nLkN1YmVcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhub3JtYWxpemVkVGltZSwgMylcclxuXHJcbiAgICAgICAgICAgIHdoZW4gVG9yY2guRWFzaW5nLkludmVyc2VTcXVhcmVcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIG5vcm1hbGl6ZWRUaW1lLCAyKVxyXG5cclxuICAgICAgICAgICAgd2hlbiBUb3JjaC5FYXNpbmcuSW52ZXJzZUN1YmVcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIG5vcm1hbGl6ZWRUaW1lLCAzKVxyXG5cclxuICAgICAgICAgICAgd2hlbiBUb3JjaC5FYXNpbmcuU21vb3RoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZFRpbWUgKiBub3JtYWxpemVkVGltZSAqICgzIC0gMiAqIG5vcm1hbGl6ZWRUaW1lKVxyXG5cclxuICAgICAgICAgICAgd2hlbiBUb3JjaC5FYXNpbmcuU21vb3RoU3F1YXJlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coICggbm9ybWFsaXplZFRpbWUgKiBub3JtYWxpemVkVGltZSAqICggKDMgLSAyICogbm9ybWFsaXplZFRpbWUpICkgKSwgMiApXHJcblxyXG4gICAgICAgICAgICB3aGVuIFRvcmNoLkVhc2luZy5TbW9vdGhDdWJlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coICggbm9ybWFsaXplZFRpbWUgKiBub3JtYWxpemVkVGltZSAqICggKDMgLSAyICogbm9ybWFsaXplZFRpbWUpICkgKSwgMyApXHJcblxyXG4gICAgICAgICAgICB3aGVuIFRvcmNoLkVhc2luZy5TaW5lXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4obm9ybWFsaXplZFRpbWUgKiBNYXRoLlBJIC8gMilcclxuXHJcbiAgICAgICAgICAgIHdoZW4gVG9yY2guRWFzaW5nLkludmVyc2VTaW5lXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc2luKCAoMSAtIG5vcm1hbGl6ZWRUaW1lKSAqIE1hdGguUEkgLyAyIClcclxuXHJcbmNsYXNzIFR3ZWVuU2V0dXBcclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUsIEBvYmplY3QsIEB0aW1lVHdlZW5TaG91bGRUYWtlLCBAZWFzaW5nKSAtPlxyXG5cclxuICAgIFRvOiAodHdlZW5Qcm9wZXJ0aWVzKSAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgVHdlZW4oQGdhbWUsIEBvYmplY3QsIHR3ZWVuUHJvcGVydGllcywgQHRpbWVUd2VlblNob3VsZFRha2UsIEBlYXNpbmcpXHJcblxyXG4gICAgRnJvbTogKHNldFByb3BlcnRpZXMpIC0+XHJcbiAgICAgICAgZm9yIGtleSx2YWx1ZSBvZiBzZXRQcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIEBvYmplY3Rba2V5XSA9IHZhbHVlXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbmNsYXNzIFR3ZWVuTWFuYWdlclxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSkgLT5cclxuICAgICAgICBAdHdlZW5zID0gW11cclxuXHJcbiAgICBUd2VlbjogKG9iamVjdCwgdGltZVR3ZWVuU2hvdWxkVGFrZSwgZWFzaW5nID0gVG9yY2guRWFzaW5nLlNtb290aCkgLT5cclxuICAgICAgICByZXR1cm4gbmV3IFR3ZWVuU2V0dXAoQGdhbWUsIG9iamVjdCwgdGltZVR3ZWVuU2hvdWxkVGFrZSwgZWFzaW5nKVxyXG5cclxuICAgIEFsbDogKGNhbGxiYWNrKSAtPlxyXG4gICAgICAgIGZvciB0d2VlbiBpbiBAZ2FtZS50d2VlbnNcclxuICAgICAgICAgICAgY2FsbGJhY2sodHdlZW4pXHJcblxyXG4jICMgb2JqZWN0cyBvciBwcmltaXRpdmVzXHJcbiMgZ2FtZS5Ud2VlbihzcHJpdGUucG9zaXRpb24sIDUwMCkuVG8oe3g6IDUwMCwgeTogNTAwfSlcclxuIyAjIG9yIHNldCB0aGUgcHJvcGVydGllcyBiZWZvcmUgdHdlZW5pbmdcclxuIyBnYW1lLlR3ZWVuLihzcHJpdGUub3BhY2l0eSwgNTAwKS5Gcm9tKDApLlRvKDEpXHJcblxuY2xhc3MgUGFydGljbGVFbWl0dGVyIGV4dGVuZHMgU3ByaXRlXHJcbiAgICBwYXJ0aWNsZTogbnVsbFxyXG4gICAgYXV0bzogdHJ1ZVxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSwgeCwgeSwgQGludGVydmFsLCBAbG9vcCwgQHBhcnRpY2xlLCBAY29uZmlnKSAtPlxyXG4gICAgICAgIEBJbml0U3ByaXRlKEBnYW1lLCB4LCB5KVxyXG4gICAgICAgIEBlbGFwc2VkVGltZSA9IDBcclxuICAgICAgICBAaGFzRW1pdHRlZCA9IGZhbHNlXHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIHN1cGVyKClcclxuICAgICAgICBpZiBAaW50ZXJ2YWwgaXNudCB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgQGhhc0VtaXR0ZWRcclxuICAgICAgICAgICAgICAgIGlmIEBsb29wIHRoZW4gQFVwZGF0ZVBhcnRpY2xlRW1pdHRlcigpXHJcbiAgICAgICAgICAgIGVsc2UgQFVwZGF0ZVBhcnRpY2xlRW1pdHRlcigpXHJcblxyXG5cclxuICAgIFBhcnRpY2xlOiAocGFydGljbGUpIC0+XHJcbiAgICAgICAgcGFydGljbGUgPSBwYXJ0aWNsZVxyXG5cclxuICAgIFVwZGF0ZVBhcnRpY2xlRW1pdHRlcjogLT5cclxuICAgICAgICByZXR1cm4gaWYgbm90IEBhdXRvXHJcbiAgICAgICAgQGVsYXBzZWRUaW1lICs9IEBnYW1lLkxvb3AudXBkYXRlRGVsdGFcclxuXHJcbiAgICAgICAgaWYgQGVsYXBzZWRUaW1lID49IEBpbnRlcnZhbFxyXG4gICAgICAgICAgICBARW1pdFBhcnRpY2xlcygpXHJcbiAgICAgICAgICAgIEBoYXNFbWl0dGVkID0gdHJ1ZVxyXG4gICAgICAgICAgICBAZWxhcHNlZFRpbWUgPSAwXHJcblxyXG4gICAgRW1pdFBhcnRpY2xlczogKHJlbW92ZUVtaXR0ZXJXaGVuRG9uZSA9IGZhbHNlKSAtPlxyXG4gICAgICAgIGkgPSAwXHJcbiAgICAgICAgd2hpbGUgaSA8IEBjb25maWcuc3ByZWFkXHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgICAgICBARW1pdFBhcnRpY2xlKClcclxuXHJcbiAgICAgICAgaWYgcmVtb3ZlRW1pdHRlcldoZW5Eb25lIHRoZW4gQFRyYXNoKClcclxuXHJcbiAgICBFbWl0UGFydGljbGU6ICgpLT5cclxuICAgICAgICBhbmdsZSA9IFV0aWwuTWF0aC5SYW5kb21JblJhbmdlKEBjb25maWcubWluQW5nbGUsIEBjb25maWcubWF4QW5nbGUpXHJcbiAgICAgICAgc2NhbGUgPSBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZShAY29uZmlnLm1pblNjYWxlLCBAY29uZmlnLm1heFNjYWxlKVxyXG4gICAgICAgIGFscGhhRGVjYXkgPSBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZShAY29uZmlnLm1pbkFscGhhRGVjYXksIEBjb25maWcubWF4QWxwaGFEZWNheSlcclxuICAgICAgICByYWRpdXMgPSBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZShAY29uZmlnLm1pblJhZGl1cywgQGNvbmZpZy5tYXhSYWRpdXMpXHJcbiAgICAgICAgeCA9IEBwb3NpdGlvbi54XHJcbiAgICAgICAgeSA9IEBwb3NpdGlvbi55XHJcblxyXG4gICAgICAgIGlmIHR5cGVvZiBAcGFydGljbGUgaXNudCBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgIHAgPSBuZXcgQHBhcnRpY2xlKEBnYW1lLCB4LCB5KVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcCA9IEBnYW1lLkZhY3RvcnkuU3ByaXRlKCB4LCB5LCBAcGFydGljbGUgKVxyXG5cclxuICAgICAgICAjcC5Cb2R5LmFjY2VsZXJhdGlvbi55ID0gQGNvbmZpZy5ncmF2aXR5XHJcbiAgICAgICAgcC5Cb2R5LnZlbG9jaXR5LnggPSBNYXRoLmNvcyhhbmdsZSkgKiBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZShAY29uZmlnLm1pblZlbG9jaXR5LCBAY29uZmlnLm1heFZlbG9jaXR5KVxyXG4gICAgICAgIHAuQm9keS52ZWxvY2l0eS55ID0gTWF0aC5zaW4oYW5nbGUpICogVXRpbC5NYXRoLlJhbmRvbUluUmFuZ2UoQGNvbmZpZy5taW5WZWxvY2l0eSwgQGNvbmZpZy5tYXhWZWxvY2l0eSlcclxuICAgICAgICBwLkJvZHkub21lZ2EgPSBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZShAY29uZmlnLm1pbk9tZWdhLCBAY29uZmlnLm1heE9tZWdhKVxyXG4gICAgICAgIHAuU2l6ZS5TY2FsZShzY2FsZSwgc2NhbGUpXHJcbiAgICAgICAgcC5kcmF3SW5kZXggPSAxMDAwXHJcblxyXG4gICAgICAgIEBnYW1lLlR3ZWVucy5Ud2VlbihwLCBhbHBoYURlY2F5LCBUb3JjaC5FYXNpbmcuU21vb3RoKVxyXG4gICAgICAgICAgICAuVG8oe29wYWNpdHk6IDB9KVxyXG4gICAgICAgICAgICAuT24gXCJGaW5pc2hcIiwgLT5cclxuICAgICAgICAgICAgICAgIHAuVHJhc2goKVxyXG5cclxuY2xhc3MgUGFydGljbGVNYW5hZ2VyXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG5cclxuICAgIFBhcnRpY2xlRW1pdHRlcjogKHgsIHksIGludGVydmFsLCBzaG91bGRMb29wLCBwYXJ0aWNsZSwgY29uZmlnKS0+XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJ0aWNsZUVtaXR0ZXIoQGdhbWUsIHgsIHksIGludGVydmFsLCBzaG91bGRMb29wLCBwYXJ0aWNsZSwgY29uZmlnKVxyXG5cclxuXHJcbiMgIyB1c2FnZVxyXG4jIGVtaXR0ZXIgPSBuZXcgVG9yY2guUGFydGljbGVFbWl0dGVyIGdhbWUsIDAsIDAsIDEwMDAsIHRydWUsXHJcbiMgICAgIHNwcmVhZDogMjBcclxuIyAgICAgZ3Jhdml0eTogMC4xXHJcbiMgICAgIG1pblJhZGl1czogMVxyXG4jICAgICBtYXhSYWRpdXM6IDJcclxuIyAgICAgbWluQW5nbGU6IDBcclxuIyAgICAgbWF4QW5nbGU6IE1hdGguUEkgKiAyXHJcbiMgICAgIG1pblNjYWxlOiAxXHJcbiMgICAgIG1heFNjYWxlOiAyXHJcbiMgICAgIG1pblZlbG9jaXR5OiAxXHJcbiMgICAgIG1heFZlbG9jaXR5OiAyXHJcbiMgICAgIG1pbkFscGhhRGVjYXk6IDEwMFxyXG4jICAgICBtYXhBbHBoYURlY2F5OiAyMDBcclxuIyAgICAgbWluT21lZ2E6IDFcclxuIyAgICAgbWF4T21lZ2E6IDJcclxuIyBlbWl0dGVyLlBhcnRpY2xlIEVmZmVjdFBpZWNlcy5GaXJlLCAocGFydGljbGUpIC0+XHJcbiMgICAgICMgZG8gc29tZXRoaW5nIHRvIHRoZSBwYXJ0aWNsZSB3aGVuIGl0J3MgZW1pdHRlZFxyXG4jXHJcbiNcclxuIyBlbWl0dGVyLkJvZHkudmVsb2NpdHkueCA9IDVcclxuXG5jbGFzcyBTb3VuZFxyXG4gICAgdm9sdW1lOiAxXHJcbiAgICBwYW46IDBcclxuICAgIGNvbnN0cnVjdG9yOiAoQHNvdW5kSWQpIC0+XHJcbmNsYXNzIEF1ZGlvXHJcbiAgICBhdWRpb0NvbnRleHQ6IG51bGxcclxuICAgIE1hc3RlclZvbHVtZTogMVxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSkgLT5cclxuICAgICAgICBAR2V0QXVkaW9Db250ZXh0KClcclxuXHJcbiAgICBHZXRBdWRpb0NvbnRleHQ6IC0+XHJcbiAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IG9yIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XHJcbiAgICAgICAgICAgIEBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcclxuXHJcbiAgICAgICAgY2F0Y2ggZVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBhdWRpby4uLlwiKVxyXG5cclxuICAgIERlY29kZUF1ZGlvRGF0YTogKGRhdGEsIGNhbGxiYWNrKSAtPlxyXG4gICAgICAgIEBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhIGRhdGEsIChidWZmZXIpIC0+XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGJ1ZmZlcilcclxuXHJcbiAgICBDcmVhdGVBdWRpb1BsYXllcjogLT5cclxuICAgICAgICByZXR1cm4gbmV3IEF1ZGlvUGxheWVyKEApXHJcblxyXG5jbGFzcyBBdWRpb1BsYXllclxyXG4gICAgdm9sdW1lOiAxXHJcbiAgICBjb25zdHJ1Y3RvcjogKGF1ZCkgLT5cclxuICAgICAgICBAYXVkaW9Db250ZXh0ID0gYXVkLmF1ZGlvQ29udGV4dFxyXG4gICAgICAgIEBnYW1lID0gYXVkLmdhbWVcclxuXHJcbiAgICBDcmVhdGVHYWluOiAoZ2FpbiA9IDEpIC0+XHJcbiAgICAgICAgZ2Fpbk5vZGUgPSBAYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKVxyXG4gICAgICAgIGdhaW5Ob2RlLmdhaW4udmFsdWUgPSBnYWluXHJcbiAgICAgICAgcmV0dXJuIGdhaW5Ob2RlXHJcblxyXG4gICAgUGxheTogKHNvdW5kKSAtPlxyXG4gICAgICAgIEBnYW1lLkZhdGFsRXJyb3IoXCJDYW5ub3QgcGxheSBzb3VuZC4gc291bmQgbXVzdCBiZSBUb3JjaC5Tb3VuZFwiKVxyXG5cclxuICAgIFBsYXlTb3VuZDogKGlkLCB0aW1lID0gMCwgZmlsdGVycyA9IG51bGwpIC0+XHJcbiAgICAgICAgc291cmNlID0gQGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBAZ2FtZS5Bc3NldHMuYXVkaW9baWRdLmF1ZGlvRGF0YVxyXG5cclxuICAgICAgICBpZiBAZ2FtZS5BdWRpby5NYXN0ZXJWb2x1bWUgaXNudCAxXHJcbiAgICAgICAgICAgIGlmIGZpbHRlcnMgaXMgbnVsbFxyXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IFtAQ3JlYXRlR2FpbihAZ2FtZS5BdWRpby5NYXN0ZXJWb2x1bWUpXVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goQENyZWF0ZUdhaW4oQGdhbWUuQXVkaW8uTWFzdGVyVm9sdW1lKSlcclxuXHJcbiAgICAgICAgaWYgZmlsdGVycyBpcyBudWxsXHJcbiAgICAgICAgICAgIGZpbHRlcnMgPSBbQENyZWF0ZUdhaW4oQHZvbHVtZSldXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBmaWx0ZXJzID0gW2ZpbHRlcnMuLi4sIEBDcmVhdGVHYWluKEB2b2x1bWUpXVxyXG5cclxuICAgICAgICBsYXN0RmlsdGVyID0gbnVsbFxyXG5cclxuICAgICAgICBmb3IgZmlsdGVyLGluZGV4IGluIGZpbHRlcnNcclxuICAgICAgICAgICAgaWYgbGFzdEZpbHRlciBpcyBudWxsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuY29ubmVjdChmaWx0ZXIpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXIuY29ubmVjdChmaWx0ZXIpXHJcblxyXG4gICAgICAgICAgICBsYXN0RmlsdGVyID0gZmlsdGVyXHJcblxyXG4gICAgICAgICAgICBpZiBpbmRleCBpcyBmaWx0ZXJzLmxlbmd0aCAtIDFcclxuICAgICAgICAgICAgICAgIGZpbHRlci5jb25uZWN0KEBhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pXHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3RhcnQodGltZSlcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG5cclxuICAgICAgICBzb3VyY2UuY29ubmVjdChAYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxyXG4gICAgICAgIHNvdXJjZS5zdGFydCh0aW1lKVxyXG5cbmNsYXNzIEhvb2tNYW5hZ2VyXHJcbiAgICBwb3NpdGlvblRyYW5zZm9ybTogbnVsbFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUpIC0+XHJcbiAgICAgICAgQHBvc2l0aW9uVHJhbnNmb3JtID0gbmV3IFBvaW50KDAsMClcclxuXG5jbGFzcyBHYW1lVGhpbmdGYWN0b3J5XHJcbiAgICBnYW1lOiBudWxsXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG5cclxuICAgIFNwcml0ZTogKHgsIHksIHRleHR1cmUpIC0+XHJcbiAgICAgICAgc3ByaXRlID0gbmV3IFNwcml0ZSggQGdhbWUsIHgsIHkgKVxyXG4gICAgICAgIHNwcml0ZS5CaW5kLlRleHR1cmUodGV4dHVyZSkgaWYgdGV4dHVyZT9cclxuXHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZVxyXG5cclxuICAgIEdyb3VwOiAoeCwgeSkgLT5cclxuICAgICAgICBncm91cCA9IG5ldyBTcHJpdGVHcm91cChAZ2FtZSwgeCwgeSApXHJcblxyXG4gICAgICAgIHJldHVybiBncm91cFxyXG5cclxuICAgIFRleHQ6ICh4LCB5LCBjb25maWcgPSB7fSkgLT5cclxuICAgICAgICB0ZXh0ID0gbmV3IFRleHQoQGdhbWUsIHgsIHksIGNvbmZpZylcclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRcclxuXHJcbiAgICBUaGluZzogKHVwZGF0ZSwgZHJhdykgLT5cclxuICAgICAgICB0aGluZyA9IG5ldyBHYW1lVGhpbmcoKVxyXG5cclxuICAgICAgICB0aGluZy5VcGRhdGUgPSB1cGRhdGUgaWYgdXBkYXRlP1xyXG4gICAgICAgIHRoaW5nLkRyYXcgPSBkcmF3IGlmIGRyYXc/XHJcblxyXG4gICAgICAgIEBnYW1lLkFkZCggdGhpbmcgKVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpbmdcclxuXHJcbiAgICBCdXR0b246ICh4LCB5LCB0ZXh0Q29uZmlnLCBiYWNrZ3JvdW5kQ29uZmlnKSAtPlxyXG4gICAgICAgIHRleHQgPSBAVGV4dCB4LCB5LFxyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0Q29uZmlnLnRleHQgb3IgXCJidXR0b25cIlxyXG4gICAgICAgICAgICBjb2xvcjogdGV4dENvbmZpZy5jb2xvciBvciBcIndoaXRlXCJcclxuICAgICAgICAgICAgZm9udDogdGV4dENvbmZpZy5mb250IG9yIFwibW9ub3NwYWNlXCJcclxuICAgICAgICAgICAgZm9udFNpemU6IHRleHRDb25maWcuZm9udFNpemUgb3IgMTJcclxuXHJcbiAgICAgICAgYnV0dG9uID0gQFNwcml0ZSh4LCB5LCBiYWNrZ3JvdW5kQ29uZmlnLm1haW5CYWNrZ3JvdW5kKVxyXG5cclxuICAgICAgICB0ZXh0LkdyaWQuQ2VudGVyKCkuQ2VudGVyVmVydGljYWwoKVxyXG4gICAgICAgIGJ1dHRvbi5HcmlkLkFwcGVuZCggdGV4dCApXHJcblxyXG4gICAgICAgIGJ1dHRvbi5PbiBcIlRyYXNoXCIsIC0+XHJcbiAgICAgICAgICAgIHRleHQuVHJhc2goKVxyXG5cclxuICAgICAgICBidXR0b24uT24gXCJNb3VzZURvd25cIiwgLT5cclxuICAgICAgICAgICAgYnV0dG9uLkJpbmQuVGV4dHVyZSggYmFja2dyb3VuZENvbmZpZy5tb3VzZURvd25CYWNrZ3JvdW5kIG9yIGJhY2tncm91bmRDb25maWcubWFpbkJhY2tncm91bmQgKVxyXG5cclxuICAgICAgICBidXR0b24uT24gXCJNb3VzZVVwXCIsIC0+XHJcbiAgICAgICAgICAgIGJ1dHRvbi5CaW5kLlRleHR1cmUgYmFja2dyb3VuZENvbmZpZy5tYWluQmFja2dyb3VuZFxyXG5cclxuICAgICAgICByZXR1cm4gYnV0dG9uXHJcblxuY2xhc3MgR2FtZVBhZFxyXG4gICAgQE1peEluIEV2ZW50RGlzcGF0Y2hlclxyXG5cclxuICAgIGNvbm5lY3RlZDogZmFsc2VcclxuICAgIGJ1dHRvbnM6IG51bGxcclxuICAgIHN0aWNrczogbnVsbFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoQGdhbWUsIEBpbmRleCkgLT5cclxuICAgICAgICBASW5pdEV2ZW50RGlzcGF0Y2goKVxyXG4gICAgICAgIEBidXR0b25zID1cclxuICAgICAgICAgICAgQTogbmV3IEdhbWVQYWRCdXR0b24oQCwgMSlcclxuICAgICAgICAgICAgQjogbmV3IEdhbWVQYWRCdXR0b24oQCwgMilcclxuICAgICAgICAgICAgWDogbmV3IEdhbWVQYWRCdXR0b24oQCwgMylcclxuICAgICAgICAgICAgWTogbmV3IEdhbWVQYWRCdXR0b24oQCwgNClcclxuICAgICAgICAgICAgTGVmdEJ1bXBlcjogbmV3IEdhbWVQYWRCdXR0b24oQCwgNSlcclxuICAgICAgICAgICAgUmlnaHRCdW1wZXI6IG5ldyBHYW1lUGFkQnV0dG9uKEAsIDYpXHJcbiAgICAgICAgICAgIExlZnRUcmlnZ2VyOiBuZXcgR2FtZVBhZEJ1dHRvbihALCA3KVxyXG4gICAgICAgICAgICBSaWdodFRyaWdnZXI6IG5ldyBHYW1lUGFkQnV0dG9uKEAsIDgpXHJcbiAgICAgICAgICAgIEJhY2s6IG5ldyBHYW1lUGFkQnV0dG9uKEAsIDkpXHJcbiAgICAgICAgICAgIFN0YXJ0OiBuZXcgR2FtZVBhZEJ1dHRvbihALCAxMClcclxuICAgICAgICAgICAgTGVmdFN0aWNrOiBuZXcgR2FtZVBhZEJ1dHRvbihALCAxMSlcclxuICAgICAgICAgICAgUmlnaHRTdGljazogbmV3IEdhbWVQYWRCdXR0b24oQCwgMTIpXHJcbiAgICAgICAgICAgIERQYWRVcDogbmV3IEdhbWVQYWRCdXR0b24oQCwgMTMpXHJcbiAgICAgICAgICAgIERQYWREb3duOiBuZXcgR2FtZVBhZEJ1dHRvbihALCAxNClcclxuICAgICAgICAgICAgRFBhZExlZnQ6IG5ldyBHYW1lUGFkQnV0dG9uKEAsIDE1KVxyXG4gICAgICAgICAgICBEUGFkUmlnaHQ6IG5ldyBHYW1lUGFkQnV0dG9uKEAsIDE2KVxyXG5cclxuXHJcbiAgICAgICAgQGJ1dHRvbk1hcCA9IFtcIkFcIiwgXCJCXCIsIFwiWFwiLCBcIllcIiwgXCJMZWZ0QnVtcGVyXCIsIFwiUmlnaHRCdW1wZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJMZWZ0VHJpZ2dlclwiLCAnUmlnaHRUcmlnZ2VyJywgXCJCYWNrXCIsIFwiU3RhcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJMZWZ0U3RpY2tcIiwgXCJSaWdodFN0aWNrXCIsIFwiRFBhZFVwXCIsIFwiRFBhZERvd25cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJEUGFkTGVmdFwiLCBcIkRQYWRSaWdodFwiXHJcbiAgICAgICAgICAgICAgICAgICAgIF1cclxuXHJcbiAgICAgICAgQHN0aWNrcyA9XHJcbiAgICAgICAgICAgIExlZnRTdGljazogbmV3IEdhbWVQYWRTdGljayhAKVxyXG4gICAgICAgICAgICBSaWdodFN0aWNrOiBuZXcgR2FtZVBhZFN0aWNrKEApXHJcblxyXG4gICAgU2V0U3RhdGU6IChuYXRpdmVHYW1lUGFkKSAtPlxyXG4gICAgICAgIEBjb25uZWN0ZWQgPSBuYXRpdmVHYW1lUGFkLmNvbm5lY3RlZFxyXG4gICAgICAgIGZvciBuYXRpdmVCdXR0b24saW5kZXggaW4gbmF0aXZlR2FtZVBhZC5idXR0b25zXHJcbiAgICAgICAgICAgIGJ1dHRvbiA9IEBidXR0b25zWyBAYnV0dG9uTWFwW2luZGV4XSBdXHJcblxyXG4gICAgICAgICAgICBpZiBidXR0b24/XHJcbiAgICAgICAgICAgICAgICBidXR0b24uU2V0U3RhdGUobmF0aXZlQnV0dG9uKVxyXG5cclxuICAgICAgICBheGVzID0gbmF0aXZlR2FtZVBhZC5heGVzXHJcbiAgICAgICAgQHN0aWNrcy5MZWZ0U3RpY2suU2V0U3RhdGUoIGF4ZXNbMF0sIGF4ZXNbMV0gKVxyXG4gICAgICAgIEBzdGlja3MuUmlnaHRTdGljay5TZXRTdGF0ZSggYXhlc1syXSwgYXhlc1szXSApXHJcblxyXG5cclxuY2xhc3MgR2FtZVBhZE1hbmFnZXJcclxuICAgIF9wYWRzOiBudWxsXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lKSAtPlxyXG4gICAgICAgIEBfcGFkcyA9IFtuZXcgR2FtZVBhZChAZ2FtZSksbmV3IEdhbWVQYWQoQGdhbWUpLG5ldyBHYW1lUGFkKEBnYW1lKSxuZXcgR2FtZVBhZChAZ2FtZSldXHJcblxyXG4gICAgUGFkOiAoaW5kZXgpIC0+XHJcbiAgICAgICAgcmV0dXJuIEBfcGFkc1tpbmRleF1cclxuXHJcbiAgICBVcGRhdGU6IC0+XHJcbiAgICAgICAgbmF0aXZlR2FtZVBhZHMgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVxyXG5cclxuICAgICAgICBmb3IgcGFkLGluZGV4IGluIG5hdGl2ZUdhbWVQYWRzXHJcblxyXG4gICAgICAgICAgICBpZiBwYWQ/XHJcbiAgICAgICAgICAgICAgICBAX3BhZHNbaW5kZXhdLlNldFN0YXRlKHBhZClcclxuXHJcbmNsYXNzIEdhbWVQYWRCdXR0b25cclxuICAgIEBNaXhJbiBFdmVudERpc3BhdGNoZXJcclxuICAgIF93YXNEb3duOiBmYWxzZVxyXG4gICAgZG93bjogZmFsc2VcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBnYW1lUGFkLCBAYnV0dG9uQ29kZSkgLT5cclxuICAgICAgICBASW5pdEV2ZW50RGlzcGF0Y2goKVxyXG4gICAgICAgIEBnYW1lID0gQGdhbWVQYWQuZ2FtZVxyXG5cclxuICAgIFNldFN0YXRlOiAobmF0aXZlR2FtZVBhZEJ1dHRvbikgLT5cclxuICAgICAgICBpZiBAX3dhc0Rvd24gYW5kIG5vdCBuYXRpdmVHYW1lUGFkQnV0dG9uLnByZXNzZWRcclxuICAgICAgICAgICAgQEVtaXQgXCJCdXR0b25QcmVzc2VkXCIsIG5ldyBUb3JjaC5FdmVudChAZ2FtZSwge2J1dHRvbjogQH0pXHJcblxyXG4gICAgICAgIEBkb3duID0gbmF0aXZlR2FtZVBhZEJ1dHRvbi5wcmVzc2VkXHJcbiAgICAgICAgQF93YXNEb3duID0gQGRvd25cclxuXHJcbmNsYXNzIEdhbWVQYWRTdGlja1xyXG4gICAgQE1peEluIEV2ZW50RGlzcGF0Y2hlclxyXG4gICAgaG9yaXpvbnRhbEF4aXM6IDBcclxuICAgIHZlcnRpY2FsQXhpczogMFxyXG4gICAgRVBTSUxPTjogMC4xXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZVBhZCkgLT5cclxuXHJcbiAgICBTZXRTdGF0ZTogKGhvcml6b250YWxBeGlzLCB2ZXJ0aWNhbEF4aXMpIC0+XHJcbiAgICAgICAgaWYgTWF0aC5hYnMoaG9yaXpvbnRhbEF4aXMpID4gQEVQU0lMT05cclxuICAgICAgICAgICAgQGhvcml6b250YWxBeGlzID0gaG9yaXpvbnRhbEF4aXNcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIEBob3Jpem9udGFsQXhpcyA9IDBcclxuXHJcbiAgICAgICAgaWYgTWF0aC5hYnModmVydGljYWxBeGlzKSA+IEBFUFNJTE9OXHJcbiAgICAgICAgICAgIEB2ZXJ0aWNhbEF4aXMgPSB2ZXJ0aWNhbEF4aXNcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIEB2ZXJ0aWNhbEF4aXMgPSAwXHJcblxuY2xhc3MgQ2FudmFzR2FtZVxyXG4gICAgdG9yY2hfdHlwZTogXCJHYW1lXCJcclxuICAgIGNvbnN0cnVjdG9yOiAoQGNhbnZhc0lkLCBAd2lkdGgsIEBoZWlnaHQsIEBuYW1lLCBAZ3JhcGhpY3NUeXBlLCBAcGl4ZWwgPSAwKSAtPlxyXG4gICAgICAgIEBJbml0R2FtZSgpXHJcblxyXG4gICAgQ2FudmFzR2FtZS5NaXhJbihFdmVudERpc3BhdGNoZXIpXHJcblxyXG4gICAgSW5pdEdhbWU6IC0+XHJcbiAgICAgICAgQEluaXRFdmVudERpc3BhdGNoKClcclxuICAgICAgICBASW5pdEdyYXBoaWNzKClcclxuICAgICAgICBASW5pdENvbXBvbmVudHMoKVxyXG4gICAgICAgIEBTdHlsZSgpXHJcblxyXG4gICAgSW5pdENvbXBvbmVudHM6IC0+XHJcbiAgICAgICAgc3R5bGVTdHJpbmcgPSBcImJhY2tncm91bmQtY29sb3I6I3tDb2xvci5GbGFtZS5HZXRIdG1sU3RyaW5nKCl9OyBjb2xvcjoje0NvbG9yLlJ1YnkuR2V0SHRtbFN0cmluZygpfTsgZm9udC13ZWlnaHQ6IGJvbGQ7IHBhZGRpbmc6MnB4OyBwYWRkaW5nLXJpZ2h0OjVweDtwYWRkaW5nLWxlZnQ6NXB4XCJcclxuICAgICAgICBncmFwaGljc1N0cmluZyA9IFwiV2ViR0xcIlxyXG5cclxuICAgICAgICBpZiBAZ3JhcGhpY3NUeXBlIGlzIFRvcmNoLkNBTlZBUyB0aGVuIGdyYXBoaWNzU3RyaW5nID0gXCJDYW52YXNcIlxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIiVjIFRvcmNoIHYje1RvcmNoOjp2ZXJzaW9ufSB8I3tncmFwaGljc1N0cmluZ318IC0gI3tAbmFtZX1cIiwgc3R5bGVTdHJpbmcpXHJcblxyXG4gICAgICAgIEBMb29wID0gbmV3IExvb3AoQClcclxuICAgICAgICBAQXNzZXRzID0gbmV3IEFzc2V0TWFuYWdlcihAKVxyXG4gICAgICAgIEBMb2FkID0gbmV3IExvYWQoQClcclxuICAgICAgICBATW91c2UgPSBuZXcgTW91c2UoQClcclxuICAgICAgICBAVGltZXIgPSBuZXcgVGltZXIoQClcclxuICAgICAgICBAQ2FtZXJhID0gbmV3IENhbWVyYShAKVxyXG4gICAgICAgIEBMYXllcnMgPSBuZXcgTGF5ZXJzKEApXHJcbiAgICAgICAgQEtleXMgPSBuZXcgS2V5cyhAKVxyXG4gICAgICAgIEBUd2VlbnMgPSBuZXcgVHdlZW5NYW5hZ2VyKEApXHJcbiAgICAgICAgQFBhcnRpY2xlcyA9IG5ldyBQYXJ0aWNsZU1hbmFnZXIoQClcclxuICAgICAgICBAQXVkaW8gPSBuZXcgQXVkaW8oQClcclxuICAgICAgICBASG9va3MgPSBuZXcgSG9va01hbmFnZXIoQClcclxuICAgICAgICBARmFjdG9yeSA9IG5ldyBHYW1lVGhpbmdGYWN0b3J5KEApXHJcbiAgICAgICAgQFN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShAKVxyXG4gICAgICAgIEBHYW1lUGFkcyA9IG5ldyBHYW1lUGFkTWFuYWdlcihAKVxyXG5cclxuICAgICAgICBAZGVsdGFUaW1lID0gMFxyXG4gICAgICAgIEBmcHMgPSAwXHJcbiAgICAgICAgQGF2ZXJhZ2VGcHMgPSAwXHJcbiAgICAgICAgQGFsbEZQUyA9IDBcclxuICAgICAgICBAdGlja3MgPSAwXHJcbiAgICAgICAgQHpvb20gPSAxXHJcbiAgICAgICAgQHVpZENvdW50ZXIgPSAwXHJcblxyXG4gICAgICAgIEBwYXVzZWQgPSBmYWxzZVxyXG5cclxuICAgICAgICBAYm91bmRhcnkgPSBudWxsXHJcbiAgICAgICAgQHRpbWUgPSBudWxsXHJcbiAgICAgICAgQExhc3RUaW1lU3RhbXAgPSBudWxsXHJcblxyXG4gICAgICAgIEB0aGluZ3MgPSBbXVxyXG4gICAgICAgIEBEcmF3U3RhY2sgPSBbXVxyXG4gICAgICAgIEBBZGRTdGFjayA9IFtdXHJcblxyXG4gICAgICAgIEB0aGluZ01hcCA9IHt9XHJcbiAgICAgICAgQGZpbHRlciA9IHt9XHJcblxyXG4gICAgSW5pdEdyYXBoaWNzOiAtPlxyXG4gICAgICAgIEBjYW52YXNOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkNBTlZBU1wiKVxyXG4gICAgICAgIEBjYW52YXNOb2RlLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcclxuICAgICAgICBAY2FudmFzTm9kZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoQGNhbnZhc0lkKS5hcHBlbmRDaGlsZChAY2FudmFzTm9kZSlcclxuXHJcbiAgICAgICAgQGNhbnZhcyA9IEBjYW52YXNOb2RlLmdldENvbnRleHQoXCIyZFwiKVxyXG4gICAgICAgIEBDbGVhcihcIiNjYzUyMDBcIilcclxuXHJcbiAgICBQaXhlbFNjYWxlOiAtPlxyXG4gICAgICAgIEBjYW52YXMubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2VcclxuICAgICAgICBAY2FudmFzLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlXHJcblxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgU3RhcnQ6IChjb25maWdPYmplY3QpIC0+XHJcbiAgICAgICAgZGVmYXVsdENvbmZpZ09iamVjdCA9XHJcbiAgICAgICAgICAgIExvYWQ6IC0+XHJcbiAgICAgICAgICAgIFVwZGF0ZTogLT5cclxuICAgICAgICAgICAgRHJhdzogLT5cclxuICAgICAgICAgICAgSW5pdDogLT5cclxuXHJcbiAgICAgICAgVXRpbC5PYmplY3QoIGRlZmF1bHRDb25maWdPYmplY3QgKS5FeHRlbmQoY29uZmlnT2JqZWN0KVxyXG5cclxuICAgICAgICBAbG9hZCA9IGRlZmF1bHRDb25maWdPYmplY3QuTG9hZFxyXG4gICAgICAgIEB1cGRhdGUgPSBkZWZhdWx0Q29uZmlnT2JqZWN0LlVwZGF0ZVxyXG4gICAgICAgIEBkcmF3ID0gZGVmYXVsdENvbmZpZ09iamVjdC5EcmF3XHJcbiAgICAgICAgQGluaXQgPSBkZWZhdWx0Q29uZmlnT2JqZWN0LkluaXRcclxuXHJcbiAgICAgICAgQGxvYWQoQClcclxuXHJcbiAgICAgICAgQExvYWQuTG9hZCgpXHJcbiAgICAgICAgQExvYWQuT24gXCJMb2FkRmluaXNoZWRcIiwgPT5cclxuICAgICAgICAgICAgQGluaXQoQClcclxuICAgICAgICAgICAgQFdpcmVVcEV2ZW50cygpXHJcbiAgICAgICAgICAgIEBSdW4oKVxyXG5cclxuICAgICAgICBAY2FudmFzTm9kZS53aWR0aCA9IEB3aWR0aFxyXG4gICAgICAgIEBjYW52YXNOb2RlLmhlaWdodCA9IEBoZWlnaHRcclxuXHJcbiAgICAgICAgaWYgdHlwZW9mKEB3aWR0aCkgaXMgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICBAY2FudmFzTm9kZS53aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGhcclxuXHJcbiAgICAgICAgaWYgdHlwZW9mKEBoZWlnaHQpIGlzIFwic3RyaW5nXCJcclxuICAgICAgICAgICAgQGNhbnZhc05vZGUuaGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHRcclxuXHJcbiAgICBBZGQ6IChvKSAtPlxyXG4gICAgICAgIGlmIG5vdCBvLnRvcmNoX2dhbWVfdGhpbmdcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVSLkFyZ3VtZW50RXJyb3IoKVxyXG5cclxuICAgICAgICBAdWlkQ291bnRlcisrXHJcbiAgICAgICAgby50b3JjaF91aWQgPSBcInRoaW5nI3tAdWlkQ291bnRlcn1cIlxyXG4gICAgICAgIG8udG9yY2hfYWRkX29yZGVyID0gQHVpZENvdW50ZXJcclxuXHJcbiAgICAgICAgQEFkZFN0YWNrLnB1c2gobylcclxuXHJcbiAgICBHZXRCeUlkOiAoaWQpIC0+XHJcbiAgICAgICAgcmV0dXJuIEB0aGluZ01hcFtpZF1cclxuXHJcbiAgICBSdW46ICh0aW1lc3RhbXApIC0+XHJcbiAgICAgICAgQExvb3AuUnVuKDApXHJcblxyXG4gICAgRmF0YWxFcnJvcjogKGVycm9yKSAtPlxyXG4gICAgICAgIGlmIEBmYXRhbFxyXG4gICAgICAgICAgICByZXR1cm5cclxuXHJcbiAgICAgICAgQGZhdGFsID0gdHJ1ZVxyXG5cclxuICAgICAgICBpZiB0eXBlb2YgZXJyb3IgPT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcilcclxuXHJcbiAgICAgICAgQENsZWFyKFwiIzAwMFwiKVxyXG4gICAgICAgIHN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxuL2csIFwiPGJyPjxicj5cIilcclxuICAgICAgICBlcnJvckh0bWwgPSBcIlwiXCJcclxuICAgICAgICA8Y29kZSBzdHlsZT0nY29sb3I6I0M5MzAyQ21hcmdpbi1sZWZ0OjE1JWZvbnQtc2l6ZToyNHB4Jz4je2Vycm9yfTwvY29kZT5cclxuICAgICAgICA8YnI+XHJcbiAgICAgICAgPGNvZGUgc3R5bGU9J2NvbG9yOiNDOTMwMkNmb250LXNpemU6MjBweGZvbnQtd2VpZ2h0OmJvbGQnPlN0YWNrIFRyYWNlOjwvY29kZT5cclxuICAgICAgICA8YnI+XHJcbiAgICAgICAgPGNvZGUgc3R5bGU9J2NvbG9yOiNDOTMwMkNmb250LXNpemU6MjBweCc+I3tzdGFja308L2NvZGU+XHJcbiAgICAgICAgPGJyPlxyXG4gICAgICAgIDxjb2RlIHN0eWxlPSdjb2xvcjojQzkzMDJDZm9udC1zaXplOjE4cHgnPlRpbWU6ICN7QHRpbWV9PC9jb2RlPlxyXG4gICAgICAgIFwiXCJcIlxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gZXJyb3JIdG1sXHJcblxyXG4gICAgICAgIEBSdW5HYW1lID0gLT5cclxuICAgICAgICBAUnVuID0gLT5cclxuICAgICAgICBARW1pdCBcIkZhdGFsRXJyb3JcIiwgbmV3IFRvcmNoLkV2ZW50IEAsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxyXG4gICAgICAgIHRocm93IGVycm9yXHJcblxyXG4gICAgVXBkYXRlVGhpbmdzOiAtPlxyXG4gICAgICAgIGZpbHRlcmVkID0gW11cclxuICAgICAgICBmb3IgdGhpbmcgaW4gQHRoaW5nc1xyXG4gICAgICAgICAgICBpZiBub3QgdGhpbmcudHJhc2hcclxuICAgICAgICAgICAgICAgIGlmIG5vdCB0aGluZy5wYXVzZWRcclxuICAgICAgICAgICAgICAgICAgICB0aGluZy5VcGRhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2godGhpbmcpXHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaW5nLnRyYXNoZWQgPSB0cnVlXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgdGhpbmcuRW1pdD9cclxuICAgICAgICAgICAgICAgICAgICB0aGluZy5FbWl0IFwiVHJhc2hcIiwgbmV3IFRvcmNoLkV2ZW50KEApXHJcblxyXG4gICAgICAgIEB0aGluZ3MgPSBmaWx0ZXJlZFxyXG4gICAgICAgIEB0aGluZ3MgPSBAdGhpbmdzLmNvbmNhdCggQEFkZFN0YWNrIClcclxuICAgICAgICBAQWRkU3RhY2sgPSBbXVxyXG5cclxuICAgIERyYXdUaGluZ3M6IC0+XHJcbiAgICAgICAgIyB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBlbnRpcmUgc2NyZWVuXHJcbiAgICAgICAgQGNhbnZhcy5jbGVhclJlY3QoMCwgMCwgQENhbWVyYS5WaWV3cG9ydC5tYXhXaWR0aCwgQENhbWVyYS5WaWV3cG9ydC5tYXhIZWlnaHQpXHJcblxyXG4gICAgICAgIEB0aGluZ3Muc29ydCAoYSwgYikgLT5cclxuICAgICAgICAgICAgaWYgYS5kcmF3SW5kZXggaXMgYi5kcmF3SW5kZXhcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnRvcmNoX2FkZF9vcmRlciAtIGIudG9yY2hfYWRkX29yZGVyXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYS5kcmF3SW5kZXggLSBiLmRyYXdJbmRleFxyXG5cclxuICAgICAgICBmb3Igc3ByaXRlIGluIEB0aGluZ3NcclxuICAgICAgICAgICAgaWYgbm90IHNwcml0ZS50cmFzaFxyXG4gICAgICAgICAgICAgICAgc3ByaXRlLkRyYXcoKVxyXG5cclxuICAgIENsZWFyOiAoY29sb3IpIC0+XHJcbiAgICAgICAgaWYgY29sb3IgaXMgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIEBGYXRhbEVycm9yKFwiQ2Fubm90IGNsZWFyIHVuZGVmaW5lZCBjb2xvclwiKVxyXG4gICAgICAgIGlmIHR5cGVvZiBjb2xvciBpcyBcIm9iamVjdFwiXHJcbiAgICAgICAgICAgIGNvbG9yID0gY29sb3IuaGV4XHJcblxyXG4gICAgICAgIEBjYW52YXNOb2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbiAgICBTZXRCb3VuZGFyaWVzOiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSAtPlxyXG4gICAgICAgIEBib3VuZGFyeSA9IG5ldyBSZWN0YW5nbGUoIHgsIHksIHdpZHRoLCBoZWlnaHQgKVxyXG5cclxuICAgIGdldENhbnZhc0V2ZW50czogLT5cclxuICAgICAgICBldnRzID0gW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBcIm1vdXNlbW92ZVwiLCAoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBATW91c2UuU2V0TW91c2VQb3MoQGNhbnZhc05vZGUsIGUpXHJcbiAgICAgICAgICAgICAgICAgICAgQEVtaXQgXCJNb3VzZU1vdmVcIiwgbmV3IFRvcmNoLkV2ZW50IEAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBlXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgXCJtb3VzZWRvd25cIiwgKGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgQE1vdXNlLmRvd24gPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgQEVtaXQgXCJNb3VzZURvd25cIiwgbmV3IFRvcmNoLkV2ZW50IEAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBlXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgXCJtb3VzZXVwXCIsIChlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIEBNb3VzZS5kb3duID0gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBARW1pdCBcIk1vdXNlVXBcIiwgbmV3IFRvcmNoLkV2ZW50IEAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBlXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsIChlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIEBNb3VzZS5kb3duID0gdHJ1ZVxyXG5cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBcInRvdWNoZW5kXCIsIChlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIEBNb3VzZS5kb3duID0gZmFsc2VcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBcImNsaWNrXCIsIChlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICBARW1pdCBcIkNsaWNrXCIsIG5ldyBUb3JjaC5FdmVudCBALFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDogZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICByZXR1cm4gZXZ0c1xyXG5cclxuICAgIGdldEJvZHlFdmVudHM6IC0+XHJcbiAgICAgICAgYm9keUV2ZW50cyA9XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBcImtleWRvd25cIiwgKGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGUua2V5Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IEBLZXlzLlNwZWNpYWxLZXkoYylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYga2V5IGlzIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gQEtleXNbU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpLnRvVXBwZXJDYXNlKCldXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleS5kb3duID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleS5FbWl0KFwiS2V5RG93blwiLCBuZXcgVG9yY2guRXZlbnQoQCwge25hdGl2ZUV2ZW50OiBlfSkpXHJcblxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFwia2V5dXBcIiwgKGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGUua2V5Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IEBLZXlzLlNwZWNpYWxLZXkoYylcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYga2V5IGlzIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gQEtleXNbU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpLnRvVXBwZXJDYXNlKCldXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleS5kb3duID0gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBrZXkuRW1pdChcIktleVVwXCIsIG5ldyBUb3JjaC5FdmVudChALCB7bmF0aXZlRXZlbnQ6IGV9KSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgICAgICByZXR1cm4gYm9keUV2ZW50c1xyXG5cclxuICAgIFdpcmVVcEV2ZW50czogLT5cclxuICAgICAgICBmb3IgZXZlbnRJdGVtIGluIEBnZXRDYW52YXNFdmVudHMoKVxyXG4gICAgICAgICAgICBAY2FudmFzTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50SXRlbVswXSwgZXZlbnRJdGVtWzFdLCBmYWxzZSlcclxuXHJcbiAgICAgICAgZm9yIGV2ZW50SXRlbSBpbiBAZ2V0Qm9keUV2ZW50cygpXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudEl0ZW1bMF0sIGV2ZW50SXRlbVsxXSwgZmFsc2UpXHJcblxyXG4gICAgICAgICMgd2luZG93IHJlc2l6ZSBldmVudFxyXG4gICAgICAgIHJlc2l6ZSA9IChldmVudCkgPT5cclxuICAgICAgICAgICAgQEVtaXQgXCJSZXNpemVcIiwgbmV3IFRvcmNoLkV2ZW50IEAsXHJcbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCByZXNpemUsIGZhbHNlIClcclxuXHJcbiAgICAgICAgcGFkcyA9IG5hdmlnYXRvci5nZXRHYW1lcGFkcygpXHJcblxyXG4gICAgVG9nZ2xlUGF1c2U6IC0+XHJcbiAgICAgICAgaWYgbm90IEBwYXVzZWRcclxuICAgICAgICAgICAgQHBhdXNlZCA9IHRydWVcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIEBwYXVzZWQgPSBmYWxzZVxyXG4gICAgICAgIHJldHVybiBAXHJcblxyXG4gICAgU3R5bGU6IC0+XHJcbiAgICAgICAgIyBhIGZldyBzdHlsZSBmaXhlcyB0byBnZXQgYXJvdW5kIGhhdmluZyBhIGNzcyBmaWxlXHJcblxyXG4gICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5XHJcblxyXG4gICAgICAgIGJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJibGFja1wiXHJcbiAgICAgICAgYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCJcclxuICAgICAgICBib2R5LnN0eWxlLm1hcmdpbiA9IDBcclxuXHJcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJDQU5WQVNcIilbMF1cclxuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCJcclxuXG4jIGNsYXNzIEdhbWVcclxuIyAgICAgY29uc3RydWN0b3I6IChjYW52YXNJZCwgd2lkdGgsIGhlaWdodCwgbmFtZSwgZ3JhcGhpY3NUeXBlLCBwaXhlbCkgLT5cclxuI1xyXG4jICAgICAgICAgcmV0dXJuIG5ldyBUb3JjaC5DYW52YXNHYW1lKGNhbnZhc0lkLCB3aWR0aCwgaGVpZ2h0LCBuYW1lLCBncmFwaGljc1R5cGUsIHBpeGVsKSBpZiBncmFwaGljc1R5cGUgaXMgVG9yY2guQ0FOVkFTXHJcbiMgICAgICAgICByZXR1cm4gbmV3IFRvcmNoLldlYkdMR2FtZShjYW52YXNJZCwgd2lkdGgsIGhlaWdodCwgbmFtZSwgZ3JhcGhpY3NUeXBlLCBwaXhlbCkgIGlmIGdyYXBoaWNzVHlwZSBpcyBUb3JjaC5XRUJHTFxyXG5cclxuR2FtZSA9IENhbnZhc0dhbWVcclxuXHJcblRvcmNoTW9kdWxlIEdhbWUsIFwiR2FtZVwiXHJcblxuVG9yY2hNb2R1bGUgY2xhc3MgVGV4dHVyZVxyXG4gICAgaW1hZ2U6IG51bGxcclxuICAgIGRyYXdQYXJhbXM6IG51bGxcclxuICAgIHdpZHRoOiAwXHJcbiAgICBoZWlnaHQ6IDBcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBpbWFnZSkgLT5cclxuICAgICAgICBAd2lkdGggPSBAaW1hZ2Uud2lkdGhcclxuICAgICAgICBAaGVpZ2h0ID0gQGltYWdlLmhlaWdodFxyXG4gICAgICAgIEBkcmF3UGFyYW1zID0gbmV3IERyYXdQYXJhbXMoQHdpZHRoLCBAaGVpZ2h0KVxyXG5cclxuY2xhc3MgRHJhd1BhcmFtc1xyXG4gICAgY2xpcFg6IDBcclxuICAgIGNsaXBZOiAwXHJcbiAgICBjbGlwV2lkdGg6IDBcclxuICAgIGNsaXBIZWlnaHQ6IDBcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBjbGlwV2lkdGgsIEBjbGlwSGVpZ2h0KSAtPlxyXG5cblRvcmNoTW9kdWxlIGNsYXNzIFZpZGVvXHJcbiAgICB2aWRlbzogbnVsbFxyXG4gICAgZHJhd1BhcmFtczogbnVsbFxyXG4gICAgd2lkdGg6IDBcclxuICAgIGhlaWdodDogMFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiAoQHZpZGVvKSAtPlxyXG4gICAgICAgIEB3aWR0aCA9IEB2aWRlby52aWRlb1dpZHRoXHJcbiAgICAgICAgQGhlaWdodCA9IEB2aWRlby52aWRlb0hlaWdodFxyXG5cclxuICAgICAgICBAZHJhd1BhcmFtcyA9IG5ldyBEcmF3UGFyYW1zKEB3aWR0aCwgQGhlaWdodClcclxuXHJcbiAgICBQbGF5OiAtPlxyXG4gICAgICAgIEB2aWRlby5wbGF5KClcclxuXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbiAgICBTdG9wOiAtPlxyXG4gICAgICAgIEB2aWRlby5zdG9wKClcclxuXHJcbiAgICAgICAgcmV0dXJuIEBcclxuXHJcbiAgICBMb29wOiAodHVybk9uID0gdHJ1ZSktPlxyXG4gICAgICAgIEB2aWRlby5sb29wID0gdHVybk9uXHJcblxyXG4gICAgICAgIHJldHVybiBAXHJcblxuVG9yY2hNb2R1bGUgY2xhc3MgU3RhdGVNYWNoaW5lXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBvYmopIC0+XHJcbiAgICAgICAgQGN1cnJlbnRTdGF0ZSA9IG51bGxcclxuICAgICAgICBAc3RhdGVzID0ge31cclxuICAgICAgICBAZ2FtZSA9IEBvYmouZ2FtZVxyXG5cclxuICAgIFN0YXRlOiAoc3RhdGVOYW1lLCBzdGF0ZU9iaikgLT5cclxuICAgICAgICBpZiBzdGF0ZU9iaiBpcyB1bmRlZmluZWRcclxuXHJcbiAgICAgICAgICAgIGlmIEBzdGF0ZXNbc3RhdGVOYW1lXSBpcyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIFRvcmNoLkZhdGFsRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHN0YXRlLiBTdGF0ZSAnI3tzdGF0ZU5hbWV9JyBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIHN0YXRlIG1hY2hpbmVcIilcclxuICAgICAgICAgICAgcmV0dXJuIEBzdGF0ZXNbc3RhdGVOYW1lXVxyXG5cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YXRlT2JqLnN0YXRlTWFjaGluZSA9IEBcclxuICAgICAgICAgICAgc3RhdGVPYmouZ2FtZSA9IEBnYW1lXHJcbiAgICAgICAgICAgIEBzdGF0ZXNbc3RhdGVOYW1lXSA9IHN0YXRlT2JqXHJcblxyXG4gICAgQWRkU3RhdGU6IChzdGF0ZU5hbWUsIHN0YXRlT2JqKSAtPlxyXG4gICAgICAgIEBzdGF0ZXNbc3RhdGVOYW1lXSA9IHN0YXRlT2JqXHJcbiAgICAgICAgc3RhdGVPYmouZ2FtZSA9IEBnYW1lXHJcbiAgICAgICAgc3RhdGVPYmouc3RhdGVNYWNoaW5lID0gQFxyXG5cclxuICAgIFN3aXRjaDogKG5ld1N0YXRlLCBhcmdzLi4uKSAtPlxyXG4gICAgICAgIGlmIEBjdXJyZW50U3RhdGUgYW5kIEBjdXJyZW50U3RhdGUuRW5kIGlzbnQgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIEBjdXJyZW50U3RhdGUuRW5kKEBvYmosIGFyZ3MuLi4pXHJcblxyXG4gICAgICAgIGlmIEBTdGF0ZShuZXdTdGF0ZSkuU3RhcnQgaXNudCB1bmRlZmluZWRcclxuICAgICAgICAgICAgQFN0YXRlKG5ld1N0YXRlKS5TdGFydChAb2JqLCBhcmdzLi4uKTtcclxuXHJcbiAgICAgICAgQGN1cnJlbnRTdGF0ZSA9IEBTdGF0ZShuZXdTdGF0ZSk7XHJcblxyXG4gICAgVXBkYXRlOiAtPlxyXG4gICAgICAgIGlmIEBjdXJyZW50U3RhdGUgaXNudCBudWxsIGFuZCBAY3VycmVudFN0YXRlIGlzbnQgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIEBjdXJyZW50U3RhdGUuRXhlY3V0ZShAb2JqKTtcclxuXHJcbmNsYXNzIFN0YXRlXHJcbiAgICBjb25zdHJ1Y3RvcjogKEBFeGVjdXRlLCBAU3RhcnQsIEBFbmQpIC0+XHJcblxuVG9yY2hNb2R1bGUgY2xhc3MgQ29sb3JcclxuICAgIGhleDogbnVsbFxyXG4gICAgcjogbnVsbFxyXG4gICAgZzogbnVsbFxyXG4gICAgYjogbnVsbFxyXG4gICAgY29uc3RydWN0b3I6IChyT3JIZXgsIGcsIGIpIC0+XHJcbiAgICAgICAgQFNldChyT3JIZXgsIGcsIGIpXHJcblxyXG4gICAgU2V0OiAock9ySGV4LCBnLCBiKSAtPlxyXG4gICAgICAgIGlmIHR5cGVvZiByT3JIZXggaXMgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICBAaGV4ID0gck9ySGV4XHJcbiAgICAgICAgICAgIEBEZWNvZGVIZXgoKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgQHIgPSByT3JIZXhcclxuICAgICAgICAgICAgQGcgPSBnXHJcbiAgICAgICAgICAgIEBiID0gYlxyXG4gICAgICAgICAgICBARW5jb2RlSGV4KClcclxuXHJcbiAgICBEZWNvZGVIZXg6IC0+XHJcbiAgICAgICAgY2h1bmtzID0gVXRpbC5TdHJpbmcoQGhleCkuQ2h1bmsoMilcclxuXHJcbiAgICAgICAgQHIgPSBwYXJzZUludChjaHVua3NbMF0sIDE2KVxyXG4gICAgICAgIEBnID0gcGFyc2VJbnQoY2h1bmtzWzFdLCAxNilcclxuICAgICAgICBAYiA9IHBhcnNlSW50KGNodW5rc1syXSwgMTYpXHJcblxyXG4gICAgRW5jb2RlSGV4OiAtPlxyXG4gICAgICAgIEBoZXggPSBcIlwiXHJcbiAgICAgICAgQGhleCArPSBAci50b1N0cmluZygxNilcclxuICAgICAgICBAaGV4ICs9IEBnLnRvU3RyaW5nKDE2KVxyXG4gICAgICAgIEBoZXggKz0gQGIudG9TdHJpbmcoMTYpXHJcblxyXG4gICAgR2V0SHRtbFN0cmluZzogLT5cclxuICAgICAgICByZXR1cm4gXCIjXCIgKyBAaGV4XHJcblxyXG4gICAgSW52ZXJ0OiAtPlxyXG4gICAgICAgIEBTZXQoIE1hdGguZmxvb3IoIE1hdGguYWJzKCAyNTUgLSBAciApICksIE1hdGguZmxvb3IoIE1hdGguYWJzKCAyNTUgLSBAZyApICksIE1hdGguZmxvb3IoIE1hdGguYWJzKCAyNTUgLSBAYiApICkgKVxyXG5cclxuICAgICMgc3RhdGljIGNvbG9yIG1ldGhvZHNcclxuXHJcbiAgICBAUmFuZG9tOiAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoIE1hdGguZmxvb3IoIFV0aWwuTWF0aC5SYW5kb21JblJhbmdlKDAsMjU1KSApLCBNYXRoLmZsb29yKCBVdGlsLk1hdGguUmFuZG9tSW5SYW5nZSgwLDI1NSkgKSwgTWF0aC5mbG9vciggVXRpbC5NYXRoLlJhbmRvbUluUmFuZ2UoMCwyNTUpICkgKVxyXG5cclxuQ29sb3IuUmVkID0gbmV3IENvbG9yKDI1NiwgMCwgMCwgMSlcclxuQ29sb3IuR3JlZW4gPSBuZXcgQ29sb3IoMCwgMjU2LCAwLCAxKVxyXG5Db2xvci5CbHVlID0gbmV3IENvbG9yKDAsIDAsIDI1NiwgMSlcclxuQ29sb3IuRmxhbWUgPSBuZXcgQ29sb3IoXCJmZjgwMDBcIilcclxuQ29sb3IuUnVieSA9IG5ldyBDb2xvcihcImU2MDAwMFwiKVxyXG5cblRvcmNoTW9kdWxlIGNsYXNzIFJlY3RhbmdsZVxyXG4gICAgY29uc3RydWN0b3I6IChAeCwgQHksIEB3aWR0aCwgQGhlaWdodCkgLT5cclxuICAgICAgICBAeiA9IDBcclxuXHJcbiAgICBHZXRPZmZzZXQ6IChyZWN0YW5nbGUpIC0+XHJcbiAgICAgICAgdnggPSAoIEB4ICsgKCBAd2lkdGggLyAyICkgKSAtICggcmVjdGFuZ2xlLnggKyAoIHJlY3RhbmdsZS53aWR0aCAvIDIgKSApXHJcbiAgICAgICAgdnkgPSAoIEB5ICsgKEBoZWlnaHQgLyAyICkgKSAtICggcmVjdGFuZ2xlLnkgKyAoIHJlY3RhbmdsZS5oZWlnaHQgLyAyICkgKVxyXG4gICAgICAgIGhhbGZXaWR0aHMgPSAoQHdpZHRoIC8gMikgKyAocmVjdGFuZ2xlLndpZHRoIC8gMilcclxuICAgICAgICBoYWxmSGVpZ2h0cyA9IChAaGVpZ2h0IC8gMikgKyAocmVjdGFuZ2xlLmhlaWdodCAvIDIpXHJcbiAgICAgICAgc2hhcmVkWFBsYW5lID0gKEB4ICsgQHdpZHRoKSAtIChyZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aClcclxuICAgICAgICBzaGFyZWRZUGxhbmUgPSAoQHkgKyBAaGVpZ2h0KSAtIChyZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpXHJcblxyXG4gICAgICAgIG9mZnNldCA9XHJcbiAgICAgICAgICAgIHg6IGhhbGZXaWR0aHMgLSBNYXRoLmFicyh2eClcclxuICAgICAgICAgICAgeTogaGFsZkhlaWdodHMgLSBNYXRoLmFicyh2eSlcclxuICAgICAgICAgICAgdng6IHZ4XHJcbiAgICAgICAgICAgIHZ5OiB2eVxyXG4gICAgICAgICAgICBoYWxmV2lkdGhzOiBoYWxmV2lkdGhzXHJcbiAgICAgICAgICAgIGhhbGZIZWlnaHRzOiBoYWxmSGVpZ2h0c1xyXG4gICAgICAgICAgICBzaGFyZWRYUGxhbmU6IHNoYXJlZFhQbGFuZVxyXG4gICAgICAgICAgICBzaGFyZWRZUGxhbmU6IHNoYXJlZFlQbGFuZVxyXG5cclxuICAgICAgICByZXR1cm4gb2Zmc2V0XHJcblxyXG5cclxuICAgIEludGVyc2VjdHM6IChyZWN0YW5nbGUpIC0+XHJcbiAgICAgICAgYSA9IEBcclxuICAgICAgICBiID0gcmVjdGFuZ2xlXHJcbiAgICAgICAgaWYgYS54IDwgKGIueCArIGIud2lkdGgpICYmIChhLnggKyBhLndpZHRoKSA+IGIueCAmJiBhLnkgPCAoYi55ICsgYi5oZWlnaHQpICYmIChhLnkgKyBhLmhlaWdodCkgPiBiLnlcclxuICAgICAgICAgICAgcmV0dXJuIGEuR2V0T2Zmc2V0KGIpXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuXHJcbiAgICBTaGlmdEZyb206IChyZWN0YW5nbGUsIHRyYW5zWCwgdHJhbnNZKSAtPlxyXG4gICAgICAgIHggPSBudWxsXHJcbiAgICAgICAgeSA9IG51bGxcclxuXHJcbiAgICAgICAgaWYgdHJhbnNYIGlzIHVuZGVmaW5lZCB0aGVuIHggPSByZWN0YW5nbGUueFxyXG4gICAgICAgIGVsc2UgeCA9IHJlY3RhbmdsZS54ICsgdHJhbnNYXHJcblxyXG4gICAgICAgIGlmIHRyYW5zWSBpcyB1bmRlZmluZWQgdGhlbiB5ID0gcmVjdGFuZ2xlLnlcclxuICAgICAgICBlbHNlIHkgPSByZWN0YW5nbGUueSArIHRyYW5zWVxyXG5cclxuICAgICAgICBAeCA9IHhcclxuICAgICAgICBAeSA9IHlcclxuXHJcblRvcmNoTW9kdWxlIGNsYXNzIFZlY3RvclxyXG4gICAgI19fdG9yY2hfXzogVG9yY2guVHlwZXMuVmVjdG9yXHJcbiAgICB4OiBudWxsXHJcbiAgICB5OiBudWxsXHJcbiAgICBhbmdsZTogbnVsbFxyXG4gICAgbWFnbml0dWRlOiBudWxsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IChAeCwgQHkpIC0+XHJcbiAgICAgICAgQFJlc29sdmVWZWN0b3JQcm9wZXJ0aWVzKClcclxuXHJcbiAgICBSZXNvbHZlVmVjdG9yUHJvcGVydGllczogLT5cclxuICAgICAgICBAbWFnbml0dWRlID0gTWF0aC5zcXJ0KCBAeCAqIEB4ICsgQHkgKiBAeSApXHJcbiAgICAgICAgQGFuZ2xlID0gTWF0aC5hdGFuMihAeSwgQHgpXHJcblxyXG4gICAgUmVzb2x2ZTogLT5cclxuICAgICAgICBAUmVzb2x2ZVZlY3RvclByb3BlcnRpZXMoKVxyXG5cclxuICAgIENsb25lOiAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKEB4LCBAeSlcclxuXHJcbiAgICBTZXQ6ICh4LHkpIC0+XHJcbiAgICAgICAgQHggPSB4XHJcbiAgICAgICAgQHkgPSB5XHJcbiAgICAgICAgQFJlc29sdmVWZWN0b3JQcm9wZXJ0aWVzKClcclxuXHJcbiAgICBBZGRTY2FsYXI6IChuKSAtPlxyXG4gICAgICAgIEB4ICs9IG5cclxuICAgICAgICBAeSArPSBuXHJcbiAgICAgICAgQFJlc29sdmVWZWN0b3JQcm9wZXJ0aWVzKClcclxuXHJcbiAgICBNdWx0aXBseVNjYWxhcjogKG4pIC0+XHJcbiAgICAgICAgQHggKj0gblxyXG4gICAgICAgIEB5ICo9IG5cclxuICAgICAgICBAUmVzb2x2ZVZlY3RvclByb3BlcnRpZXMoKVxyXG5cclxuICAgIERpdmlkZVNjYWxhcjogKG4pIC0+XHJcbiAgICAgICAgQHggLz0gblxyXG4gICAgICAgIEB5IC89IG5cclxuICAgICAgICBAUmVzb2x2ZVZlY3RvclByb3BlcnRpZXMoKVxyXG5cclxuICAgIFN1YnRyYWN0VmVjdG9yOiAodikgLT5cclxuICAgICAgICBAeCAtPSB2LnhcclxuICAgICAgICBAeSAtPSB2LnlcclxuICAgICAgICBAUmVzb2x2ZVZlY3RvclByb3BlcnRpZXMoKVxyXG5cclxuICAgIEFkZFZlY3RvcjogKHYpIC0+XHJcbiAgICAgICAgQHggKz0gdi54XHJcbiAgICAgICAgQHkgKz0gdi55XHJcbiAgICAgICAgQFJlc29sdmVWZWN0b3JQcm9wZXJ0aWVzKClcclxuXHJcbiAgICBOb3JtYWxpemU6IC0+XHJcbiAgICAgICAgQERpdmlkZVNjYWxhcihAbWFnbml0dWRlKVxyXG5cclxuICAgIERvdFByb2R1Y3Q6ICh2KSAtPlxyXG4gICAgICAgIHJldHVybiBAeCAqIHYueCArIEB5ICogdi55XHJcblxyXG4gICAgUmV2ZXJzZTogLT5cclxuICAgICAgICBATXVsdGlwbHlTY2FsYXIoIC0xIClcclxuXHJcbiAgICBJc1BlcnBlbmRpY3VsYXI6ICh2KSAtPlxyXG4gICAgICAgIHJldHVybiBARG90UHJvZHVjdCh2KSBpcyAwXHJcblxyXG4gICAgSXNTYW1lRGlyZWN0aW9uOiAodikgLT5cclxuICAgICAgICByZXR1cm4gQERvdFByb2R1Y3QodikgPiAwXHJcblxyXG5Ub3JjaE1vZHVsZSBjbGFzcyBQb2ludFxyXG4gICAgY29uc3RydWN0b3I6IChAeCwgQHksIEB6ID0gMCkgLT5cclxuXHJcbiAgICBBcHBseTogKHBvaW50KSAtPlxyXG4gICAgICAgIEB4ICs9IHBvaW50LnhcclxuICAgICAgICBAeSArPSBwb2ludC55XHJcblxyXG4gICAgU3VidHJhY3Q6IChwKSAtPlxyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoIHAueCAtIEB4LCBwLnkgLSBAeSApXHJcblxyXG4gICAgQ2xvbmU6IC0+XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChAeCwgQHkpXHJcblxyXG4gICAgQEdldENlbnRlclBvaW50OiAocG9pbnRzKSAtPlxyXG4gICAgICAgIG1heFggPSAwXHJcbiAgICAgICAgbWF4WSA9IDBcclxuXHJcbiAgICAgICAgbWluWSA9IEluZmluaXR5XHJcbiAgICAgICAgbWluWCA9IEluZmluaXR5XHJcblxyXG4gICAgICAgIGZvciBwb2ludCBpbiBwb2ludHNcclxuICAgICAgICAgICAgaWYgcG9pbnQueCA+IG1heFggdGhlbiBtYXhYID0gcG9pbnQueFxyXG4gICAgICAgICAgICBpZiBwb2ludC55ID4gbWF4WSB0aGVuIG1heFkgPSBwb2ludC55XHJcblxyXG4gICAgICAgICAgICBpZiBwb2ludC54IDwgbWluWCB0aGVuIG1pblggPSBwb2ludC54XHJcbiAgICAgICAgICAgIGlmIHBvaW50LnkgPCBtaW5ZIHRoZW4gbWluWSA9IHBvaW50LnlcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggKG1heFggLSBtaW5YKSAqIDAuNSwgKCBtYXhZIC0gbWluWSkgKiAwLjUpXHJcblxuZXhwb3J0cyA9IHRoaXMgIyB0aGlzIHdpbGwgZWl0aGVyIGJlICd3aW5kb3cnIGZvciBDaHJvbWUgb3JcclxuICAgICAgICAgICAgICAgIyAnbW9kdWxlJyBmb3Igbm9kZVxyXG5cclxuIyMjXHJcbiAgICBBIGZldyBub3RlcyB0byBrZWVwIGluIG1pbmQ6XHJcblxyXG4gICAgLSBDb2ZmZWVTY3JpcHQgd3JhcHMgZWFjaCBmaWxlIGludG8gaXQncyBvd24gc2NvcGUgd2hlbiBpdCBpcyBjb21waWxlZCBpbnRvXHJcbiAgICAgIGphdmFzY3JpcHQuIFdoZW4gVG9yY2ggaXMgYnVpbHQsIGl0IHB1dHMgYWxsIHRoZSBjb2ZmZWVzY3JpcHQgaW50byBvbmUgZmlsZVxyXG4gICAgICAodG9yY2gtbGF0ZXN0LmNvZmZlZSkgdGh1cyB0aHJvd2luZyBhbGwgb2YgVG9yY2ggaW50byB0aGUgc2FtZSBzY29wZS4gVGhlIG9ubHlcclxuICAgICAgcGllY2UgdGhhdCBpcyBleHBvc2VkIGlzIGFuIGluc3RhbmNlIG9mIFRvcmNoIGNhbGxlZCAnVG9yY2gnXHJcblxyXG4gICAgLSBUaGVyZSBhcmUgYSBmZXcgY3VzdG9tIG9iamVjdHMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgdG9yY2ggc2NvcGUgYSBsaXR0bGUgb2RseTpcclxuICAgICAgIC0gVXRpbCAtIEFuIGluc3RhbmNlIG9mIFV0aWxpdGllcywgdXNlZCBpbnRlcm5hbGx5IGJ5IFRvcmNoLCBleHBvcnRlZCBhcyBUb3JjaC5VdGlsXHJcbiMjI1xyXG5jbGFzcyBFdmVudFxyXG4gICAgY29uc3RydWN0b3I6IChAZ2FtZSwgQGRhdGEpIC0+XHJcbiAgICAgICAgaWYgQGdhbWUgaXNudCBudWxsXHJcbiAgICAgICAgICAgIEB0aW1lID0gQGdhbWUudGltZVxyXG4gICAgICAgIGZvciBrZXksdmFsdWUgb2YgQGRhdGFcclxuICAgICAgICAgICAgQFtrZXldID0gdmFsdWVcclxuXHJcbmNsYXNzIFRvcmNoXHJcblxyXG4gICAgQ0FOVkFTOiAxXHJcbiAgICBXRUJHTDogMlxyXG4gICAgUElYRUw6IDNcclxuXHJcbiAgICBEVU1QX0VSUk9SUzogZmFsc2VcclxuXHJcbiAgICBAR2FtZVBhZHM6IFV0aWwuRW51bShcIlBhZDFcIiwgXCJQYWQyXCIsIFwiUGFkM1wiLCBcIlBhZDRcIilcclxuICAgIEBBamF4RGF0YTogVXRpbC5FbnVtKFwiRE9NU3RyaW5nXCIsIFwiQXJyYXlCdWZmZXJcIiwgXCJCbG9iXCIsIFwiRG9jdW1lbnRcIiwgXCJKc29uXCIsIFwiVGV4dFwiKVxyXG4gICAgQFR5cGVzOiBVdGlsLkVudW0oXCJTdHJpbmdcIiwgXCJOdW1iZXJcIiwgXCJPYmplY3RcIiwgXCJBcnJheVwiLCBcIkZ1bmN0aW9uXCIsIFwiU3ByaXRlXCIsIFwiR2FtZVwiLCBcIk51bGxcIilcclxuICAgIEBFYXNpbmc6IFV0aWwuRW51bShcIkxpbmVhclwiLCBcIlNxdWFyZVwiLCBcIkN1YmVcIiwgXCJJbnZlcnNlU3F1YXJlXCIsIFwiSW52ZXJzZUN1YmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTbW9vdGhcIiwgXCJTbW9vdGhTcXVhcmVcIiwgXCJTbW9vdGhDdWJlXCIsIFwiU2luZVwiLCBcIkludmVyc2VTaW5lXCIpXHJcblxyXG4gICAgQEFqYXhMb2FkZXI6IEFqYXhMb2FkZXJcclxuICAgIEBFdmVudDogRXZlbnRcclxuICAgIEBVdGlsOiBuZXcgVXRpbGl0aWVzKCkgIyBhIHN0YXRpYyByZWZlcmVuY2UgZm9yIHVzZSB3aXRoaW4gdG9yY2hcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogLT5cclxuICAgICAgICBAR2FtZVBhZHMgPSBUb3JjaC5HYW1lUGFkc1xyXG4gICAgICAgIEBBamF4RGF0YSA9IFRvcmNoLkFqYXhEYXRhXHJcbiAgICAgICAgQFR5cGVzID0gVG9yY2guVHlwZXNcclxuICAgICAgICBARWFzaW5nID0gVG9yY2guRWFzaW5nXHJcblxyXG4gICAgICAgIEBVdGlsID0gVXRpbFxyXG5cclxuICAgICAgICBmb3IgbW9kIGluIFRvcmNoTW9kdWxlc1xyXG4gICAgICAgICAgICBAW21vZC5uYW1lXSA9IG1vZC5tb2RcclxuXHJcbiAgICBARmF0YWxFcnJvcjogKGVycm9yKSAtPlxyXG4gICAgICAgIHJldHVybiBpZiBAZmF0YWxcclxuICAgICAgICBAZmF0YWwgPSB0cnVlXHJcblxyXG4gICAgICAgIGlmIFV0aWwuVHlwZShlcnJvcikgaXMgXCJzdHJpbmdcIlxyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcilcclxuICAgICAgICBlbHNlIGlmIG5vdCBlcnJvci5zdGFjaz9cclxuICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5uYXRpdmVFcnJvclxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmJhY2tncm91bmRDb2xvciA9IFwiYmxhY2tcIlxyXG5cclxuICAgICAgICBpZiBARFVNUF9FUlJPUlNcclxuICAgICAgICAgICAgaWYgcmVxdWlyZSBpc250IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgcmVxdWlyZShcImZzXCIpLndyaXRlRmlsZVN5bmMoXCJ0b3JjaC1lcnJvci5sb2dcIiwgZXJyb3Iuc3RhY2spXHJcblxyXG4gICAgICAgIHN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxuL2csIFwiPGJyPjxicj5cIilcclxuXHJcbiAgICAgICAgZXJyb3JIdG1sID0gXCJcIlwiXHJcbiAgICAgICAgPGNvZGUgc3R5bGU9J2NvbG9yOiNDOTMwMkM7bWFyZ2luLWxlZnQ6MTUlO2ZvbnQtc2l6ZToyNHB4Jz4je2Vycm9yfTwvY29kZT5cclxuICAgICAgICA8YnI+XHJcbiAgICAgICAgPGNvZGUgc3R5bGU9J2NvbG9yOiNDOTMwMkM7Zm9udC1zaXplOjIwcHg7Zm9udC13ZWlnaHQ6Ym9sZCc+U3RhY2sgVHJhY2U6PC9jb2RlPjxicj5cclxuICAgICAgICA8Y29kZSBzdHlsZT0nY29sb3I6I0M5MzAyQztmb250LXNpemU6MjBweCc+I3tzdGFja308L2NvZGU+PGJyPlxyXG4gICAgICAgIFwiXCJcIlxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gZXJyb3JIdG1sXHJcblxyXG4gICAgU3RyaWN0RXJyb3JzOiAtPlxyXG4gICAgICAgIEBTVFJJQ1RfRVJST1JTID0gdHJ1ZVxyXG5cclxuICAgIER1bXBFcnJvcnM6IC0+XHJcbiAgICAgICAgQERVTVBfRVJST1JTID0gdHJ1ZVxyXG5cclxuZXhwb3J0cy5Ub3JjaCA9IG5ldyBUb3JjaCgpXHJcblxuXG5Ub3JjaDo6dmVyc2lvbiA9ICcwLjkuMTg2J1xuIl19
//# sourceURL=C:\dev\Torch\Builds\torch-latest.coffee